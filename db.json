{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/resume_Columbia_University_Zhicheng_Ding.pdf","path":"resume_Columbia_University_Zhicheng_Ding.pdf","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/android-chrome-192x192.png","path":"images/android-chrome-192x192.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/browserconfig.xml","path":"images/browserconfig.xml","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/mstile-150x150.png","path":"images/mstile-150x150.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/safari-pinned-tab.svg","path":"images/safari-pinned-tab.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/site.webmanifest","path":"images/site.webmanifest","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/images/android-chrome-512x512.png","path":"images/android-chrome-512x512.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1540614642971},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1540614642971},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1540614642971},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1540614642972},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1540614642972},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1540614642973},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1540614642972},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1540614642973},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1540614642973},{"_id":"themes/next/README.md","hash":"ec309ec5a764c31df3ca6be624cfec762ff97cea","modified":1540614642973},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1540614642973},{"_id":"themes/next/bower.json","hash":"3f8f416899ab12c48a5cc936265d475fa99ce9fe","modified":1540614642973},{"_id":"themes/next/_config.yml","hash":"52c453d61e885805170a53e6dfd0e3012b328f34","modified":1540614642973},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1540614642974},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1540614642977},{"_id":"themes/next/package.json","hash":"f27fff901d4e34f53cf98cb120d365a8b66c6fd3","modified":1540614642993},{"_id":"source/README.md","hash":"d8f896188a38c25119b1bbbf897a64cefc264748","modified":1540614642948},{"_id":"source/CNAME","hash":"afc93543189a76690a2ad1b7546a202fb87ac2cf","modified":1543932474424},{"_id":"source/.DS_Store","hash":"71642166051f1c4389d03cfba958c4f2a8b06a4b","modified":1543932928761},{"_id":"source/robots.txt","hash":"2c8806cd2dc92734728da893c73876ec3609df78","modified":1540614642958},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1540614642972},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"f846118d7fc68c053df47b24e1f661241645373f","modified":1540614642972},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1540614642972},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1540614642972},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1540614642972},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1540614642972},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1540614642974},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1540614642974},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1540614642974},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1540614642974},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1540614642974},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"bbd5aa9a79cac0f630b666bc6db87025e08fb1ac","modified":1540614642975},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1540614642975},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1540614642975},{"_id":"themes/next/docs/MATH.md","hash":"d047b8a3d9aa49b478a33e5a326195d460cb4589","modified":1540614642975},{"_id":"themes/next/layout/_layout.swig","hash":"60c6438f43e2832dfb8b085e765d050ae63ba844","modified":1540614642982},{"_id":"themes/next/layout/archive.swig","hash":"833a2213d31be45a12b8e4e5e609073978bd251b","modified":1540614642992},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1540614642992},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1540614642992},{"_id":"themes/next/layout/page.swig","hash":"3f9b2444f12251727ebbc28159f02e9e9489742e","modified":1540614642992},{"_id":"themes/next/layout/post.swig","hash":"8e2d079b46076996cc9343213d5bf7da8178d32d","modified":1540614642992},{"_id":"themes/next/layout/projects.ejs","hash":"ee0ce22327cc85802933788f212824f3bcdef219","modified":1540614642992},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1540614642992},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1540614642992},{"_id":"themes/next/scripts/helpers.js","hash":"3c3fb81f575a21dd3131757b36410773b7a9738d","modified":1540614642993},{"_id":"themes/next/scripts/merge-configs.js","hash":"ca9845dc76f5710b4c6fba5fe25ff0d2fcf0adaa","modified":1540614642993},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1540614642993},{"_id":"themes/next/languages/ar.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642977},{"_id":"themes/next/languages/bg.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642977},{"_id":"themes/next/languages/cs.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642977},{"_id":"themes/next/languages/bn.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642977},{"_id":"themes/next/languages/de.yml","hash":"31022b4e7caa10ad7551919159fb37c820788398","modified":1540614642978},{"_id":"themes/next/languages/da.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642978},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1540614642978},{"_id":"themes/next/languages/el.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642978},{"_id":"themes/next/languages/en.yml","hash":"f4db5ae0cd4937a453493a81856f91d8c963a744","modified":1540614642978},{"_id":"themes/next/languages/es.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642978},{"_id":"themes/next/languages/et.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642978},{"_id":"themes/next/languages/fi.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642978},{"_id":"themes/next/languages/fr.yml","hash":"059d66eea84757a2c330e865262cbf5d22e384ca","modified":1540614642978},{"_id":"themes/next/languages/fa.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642978},{"_id":"themes/next/languages/he.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642979},{"_id":"themes/next/languages/hr.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642979},{"_id":"themes/next/languages/hi.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642979},{"_id":"themes/next/languages/hu.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642979},{"_id":"themes/next/languages/id.yml","hash":"6aedba65605a6b63451767f6ac4359c7ca72b4b5","modified":1540614642979},{"_id":"themes/next/languages/ja.yml","hash":"7ff7c14c97291e2e29ad1e10fa96bcab8fe35a18","modified":1540614642979},{"_id":"themes/next/languages/jv.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642979},{"_id":"themes/next/languages/it.yml","hash":"2f183ebc0e26c0ce899e57f1b98b0d1727f8ac06","modified":1540614642979},{"_id":"themes/next/languages/lt.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642980},{"_id":"themes/next/languages/ko.yml","hash":"e8f29cb1684262cc7de8807f70f22ce25b68ae4e","modified":1540614642980},{"_id":"themes/next/languages/lv.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642980},{"_id":"themes/next/languages/nl.yml","hash":"b9e752c19a2fa8b9b24ab382c903da3fcefb48df","modified":1540614642980},{"_id":"themes/next/languages/no.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642980},{"_id":"themes/next/languages/ms.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642980},{"_id":"themes/next/languages/pl.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642980},{"_id":"themes/next/languages/pt-BR.yml","hash":"08a9d21e2ed1c7871ad2e4c14f57cd5d21fecb20","modified":1540614642980},{"_id":"themes/next/languages/pa.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642980},{"_id":"themes/next/languages/pt.yml","hash":"bc1e2b1857b3dbf15632950bd3c06971b9eb7b17","modified":1540614642981},{"_id":"themes/next/languages/ru.yml","hash":"13af9d32b823628453ac732e888e95b80ba03c0a","modified":1540614642981},{"_id":"themes/next/languages/ro.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642981},{"_id":"themes/next/languages/sl.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642981},{"_id":"themes/next/languages/sr.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642981},{"_id":"themes/next/languages/sv.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642981},{"_id":"themes/next/languages/tr.yml","hash":"e0310c719c86e425d97174ce3aa2902251577f15","modified":1540614642981},{"_id":"themes/next/languages/th.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642981},{"_id":"themes/next/languages/uk.yml","hash":"371331112a7ec4a61991cb12870ca85b7856b43d","modified":1540614642982},{"_id":"themes/next/languages/vi.yml","hash":"e32495a468c69e3b4f5f8c2774797a23c8aafa1c","modified":1540614642982},{"_id":"themes/next/languages/zh-CN.yml","hash":"4bc010df6ea139cb5fbb8d7e9dac27110a9eef89","modified":1540614642982},{"_id":"themes/next/languages/zh-tw.yml","hash":"475359a40f23133d33da29f161239f180e208ace","modified":1540614642982},{"_id":"themes/next/languages/zh-hk.yml","hash":"40f3543ec83f15d4d6f5af1782a0424c0cd8a009","modified":1540614642982},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1540614643026},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1540614643027},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1540614643027},{"_id":"source/_posts/2017-09-15-Why Keep Writing Blog.md","hash":"373938963111f72351db349336bd7c2ff6f0ce00","modified":1540614642948},{"_id":"source/_posts/.DS_Store","hash":"095e076b415123a01d53dfa2fdc6f3efc91c9ba8","modified":1541445101420},{"_id":"source/about/index.md","hash":"c1a922d44491a47598d9137ef62eab7a9c121e04","modified":1540614642957},{"_id":"source/tags/index.md","hash":"68e44182940a30af8a4e02ace9b238a6309fc6a5","modified":1540614642958},{"_id":"source/categories/index.md","hash":"6ea4d9be1300d5cc0581612073f1bfb1a83def3d","modified":1540614642957},{"_id":"source/projects/index.md","hash":"531281e9ccc366fd833d50eca2235eb26e03309c","modified":1543933515557},{"_id":"source/projects/.DS_Store","hash":"714a817f458666b42b8221e6fb231bf7782011dd","modified":1543932850911},{"_id":"source/resume_Columbia_University_Zhicheng_Ding.pdf","hash":"5fad12f5f6a769bc68ba08051512132ec8335bcf","modified":1540614642958},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614643009},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1540614642975},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1540614642975},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1540614642976},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1540614642976},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1540614642976},{"_id":"themes/next/docs/ru/README.md","hash":"f12ccabe58dd6944106e71910a2b0914638dba95","modified":1540614642975},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"44e4fb7ce2eca20dfa98cdd1700b50d6def4086f","modified":1540614642976},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1540614642976},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1540614642976},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"0bc0c3eb909f137c859f38c5c66dcb7c29f76ead","modified":1540614642976},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"1c7df019737656fdfd8d124c7c045a64ac8a2a8d","modified":1540614642977},{"_id":"themes/next/docs/zh-CN/README.md","hash":"f4717a926cda6179c89315226ceeb7bfc78fbef5","modified":1540614642977},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"c1ba919f70efe87a39e6217883e1625af0b2c23c","modified":1540614642977},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1540614642982},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1540614642982},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1540614642982},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1540614642983},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"464082e431ea5b06df782d5f312ee25be9e5f169","modified":1540614642983},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1540614642983},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"355ddd5b8af696f7bffb183addd7e84c0a4e2123","modified":1540614642984},{"_id":"themes/next/layout/_macro/reward.swig","hash":"aa620c582143f43ba1cb1a5e59240041a911185b","modified":1540614642983},{"_id":"themes/next/layout/_macro/post.swig","hash":"02227f92dfe2777f2be1cb2e24e1eb81d47a60bd","modified":1540614642983},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"fea45ab314b9ea23edab25c2b8620f909d856b1d","modified":1540614642984},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1540614642984},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5df32b286a8265ba82a4ef5e1439ff34751545ad","modified":1540614642984},{"_id":"themes/next/layout/_partials/footer.swig","hash":"1010d2c37700b673ae863aec96cb21d7f91b015b","modified":1540614642984},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1540614642985},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1540614642985},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1540614642986},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1540614642986},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1540614642986},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1540614642987},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1540614642989},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1540614642990},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1540614642990},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1540614642990},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1540614642990},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1540614642991},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1540614642991},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1540614642991},{"_id":"themes/next/scripts/tags/button.js","hash":"5a61c2da25970a4981fbd65f4a57c5e85db4dcda","modified":1540614642993},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"db70a841e7c1708f95ca97b44413b526b267fa9b","modified":1540614642993},{"_id":"themes/next/scripts/tags/exturl.js","hash":"2b3a4dc15dea33972c0b6d46a1483dabbf06fb5b","modified":1540614642994},{"_id":"themes/next/scripts/tags/full-image.js","hash":"a98fc19a90924f2368e1982f8c449cbc09df8439","modified":1540614642994},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1b97b1b5364945b8ab3e50813bef84273055234f","modified":1540614642994},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"b7600f6b868d8f4f7032126242d9738cd1e6ad71","modified":1540614642994},{"_id":"themes/next/scripts/tags/label.js","hash":"621004f2836040b12c4e8fef77e62cf22c561297","modified":1540614642994},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"460e5e1f305847dcd4bcab9da2038a85f0a1c273","modified":1540614642994},{"_id":"themes/next/scripts/tags/note.js","hash":"4975d4433e11161b2e9a5744b7287c2d667b3c76","modified":1540614642994},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1540614642994},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1540614643009},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1540614643009},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1540614643012},{"_id":"themes/next/source/images/android-chrome-192x192.png","hash":"1c4e77121a942fce2a122f56ad4c8120444f681b","modified":1540614643011},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1540614643012},{"_id":"themes/next/source/images/apple-touch-icon.png","hash":"457f72c374756faeb4b375d4413b2c4eeb921093","modified":1540614643012},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1540614643015},{"_id":"themes/next/source/images/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1540614643015},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1540614643015},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1540614643016},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1540614643015},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1540614643016},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1540614643016},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1540614643016},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"729e9550a1465cbeffdcbea5b70bb27883da981d","modified":1540614643016},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1540614643016},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"b398dd3db0a29507602e6945c4e9606d188d523e","modified":1540614643017},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1540614643017},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1540614643016},{"_id":"themes/next/source/images/favicon.ico","hash":"9c756e07b09d87bd03c30dc4315ac7818fd6c400","modified":1540614643017},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1540614643017},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1540614643017},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1540614643017},{"_id":"themes/next/source/images/mstile-150x150.png","hash":"3b50bc2c1c01c5dc42e4da0ecec5129201612581","modified":1540614643017},{"_id":"themes/next/source/images/safari-pinned-tab.svg","hash":"e2ca3df89ab832d15933d3ea9b71226f662e168d","modified":1540614643018},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1540614643018},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1540614643018},{"_id":"themes/next/source/images/site.webmanifest","hash":"13e5aa58eb2182d8ace63266856c8cc29c47c083","modified":1540614643018},{"_id":"source/_posts/MySQL/2018-10-27-MySQL_connection.md","hash":"71651d55f764e70ea87d357d94d98e677c27216a","modified":1543932474425},{"_id":"source/_posts/Latex/2017-12-05-Latex常见错误整理.md","hash":"2a48a15f4d8c3a8fdafdee54ec3c8fdddb3139b0","modified":1540614642949},{"_id":"source/_posts/ML System Tips/2017-11-30-Get More Data.md","hash":"380ee7886d8c9c7cd18dbf771e81cda6299135d9","modified":1540614642949},{"_id":"source/_posts/Mathematics/2017-10-29-tanh Function.md","hash":"86e17c2c6a8b71a2fbeae0c2e19d78392283bffe","modified":1540614642949},{"_id":"source/_posts/Mathematics/2017-10-28-MatrixToVector.md","hash":"0a56737479dfbf5fe5ecd2799038955067d40ca8","modified":1540614642949},{"_id":"source/_posts/Mathematics/2017-10-29-数据预处理-数据归一化和数据规范化.md","hash":"0d96a6c51f2830dd88a13eab28e595aceead37cd","modified":1540614642949},{"_id":"source/_posts/Mathematics/2017-10-30-Sigmoid Function.md","hash":"34a2af59889839825c5e4623aaaab9d2030e54c7","modified":1540614642950},{"_id":"source/_posts/Mathematics/2017-11-30-Concave and Convex Function.md","hash":"95043b7df2f55eb372689a4838844041f011611b","modified":1540614642950},{"_id":"source/_posts/Mathematics/2017-10-31-数据分割.md","hash":"c6dd6c39ce97916bfbcf5e12ac9f35b29f18b3e6","modified":1540614642950},{"_id":"source/_posts/Mathematics/2017-11-01-线性模型性能分析--混淆矩阵(Confusion Matrix).md","hash":"63164b7eed781caa7f9ba8299d4fcfc110780ece","modified":1540614642950},{"_id":"source/_posts/Visualization/2018-08-17-helpful_visualization_tutorial.md","hash":"e33f4a15d7b240b5b9687b2b9b05036561867edf","modified":1540614642956},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-01-0.Machine Learning Foundation - Table of Contents.md","hash":"c70239285a7e9f3fd1bf164114d6ee4d7371e926","modified":1540614642953},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-02-1.When can Machine Learn - The Learning Problem.md","hash":"38f4345b7193b861c15c324ea07daafe41637c60","modified":1540614642954},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-03-2.When can Machine Learn - Learning to Answer Yes or No.md","hash":"b11e3e728d078be61a6fb911ffb68f21229cf802","modified":1540614642954},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-04-3.When can Machine Learn - Types of Learning.md","hash":"40979c159870cfa7c81cbd079ef2c348c7a2442f","modified":1540614642954},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-06-4.When can Machine Learn - Feasible of Learning.md","hash":"a2463f32f572aa293435223b1ed9d57094943d23","modified":1540614642954},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-08-5.Why Can Machine Learn.md","hash":"c6bbb1a211b388ccb0ddf2f44d55c992557a8dd6","modified":1540614642954},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-09-6.How can Machine Learn - Noice and Error.md","hash":"ae51ef4d78b29f0fed0a4d583fa2ac16bec0d6b0","modified":1540614642955},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-11-7.How can Machine Learn - Linear Regression.md","hash":"7293547ae8b8f42e8ca4e11b4089a7eb8ab573c3","modified":1540614642955},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-13-8.How can Machine Learn - Logistic Regression.md","hash":"71e21f50ad849602ad1f3f96621fac5a604e8eda","modified":1540614642955},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-14-9.How can Machine Learn - Linear Model for Classification.md","hash":"9ecbcbc6f306aa4f08f8932aa8271a194e1e2633","modified":1540614642955},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-15-10.How can Machine Learn - Nonlinear Transformation.md","hash":"ef704a957562eefc2c87187f5e532ed9c633eaee","modified":1540614642955},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-16-11.How can Machine Learn Better - Overfitting and Solution.md","hash":"e47e6882ce28d03bb678a524627d20503aa95d95","modified":1540614642956},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-18-13.How can Machine Learn Better - Validation.md","hash":"cdfda62d3f2d372d41677de895e51b95099937e0","modified":1540614642956},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-17-12.How can Machine Learn Better - Regularization.md","hash":"187f2bb07519833de8e0e6b7380c52386f1021a4","modified":1540614642956},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-21-14.How can Machine Learn Better - Three Learning Principles.md","hash":"ed5497b0aba0a4cc1ae6da85c01ee14d4465decd","modified":1540614642956},{"_id":"source/_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-22-15.Summary - Power of Three.md","hash":"0afb2cf5d67ae58f1b0383a3f5ace7c4160a4580","modified":1540614642956},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614642987},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614642987},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614643009},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614643009},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614643005},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614643005},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1540614643005},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"652b5c1055cfa52ae6005cba00c751b1ec55b8f5","modified":1540614643019},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1540614642983},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1540614642983},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1540614642984},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"cd7e3331a61939c820e0437bf5d815cb0a42fefb","modified":1540614642984},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"9f7aa33a620aea6ede1fb907b61fd071c018c525","modified":1540614642984},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"b5c9f191c55622d778a1f4fb14008f858b87e8f7","modified":1540614642985},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"e76745ff68fc017c250d749880ab67a68a9f2695","modified":1540614642985},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1540614642985},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1540614642985},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1540614642985},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1540614642985},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1540614642986},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1540614642986},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1540614642986},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1540614642986},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1540614642986},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1540614642986},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1540614642987},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1540614642987},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1540614642987},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1540614642987},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1540614642987},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"cee047575ae324398025423696b760db64d04e6f","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1540614642988},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1540614642989},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1540614642989},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1540614642989},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"2fbee33a4ccd7c8217c73e85a9a1488170e05629","modified":1540614642989},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1540614642989},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1540614642989},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"40e3cacbd5fa5f2948d0179eff6dd88053e8648e","modified":1540614642989},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1540614642989},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"c0eb6123464d745ac5324ce6deac8ded601f432f","modified":1540614642990},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"42f62695029834d45934705c619035733762309e","modified":1540614642990},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1540614642990},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1540614642990},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"011ae6303afacddabc4ddf570fe3dd227569cd4f","modified":1540614642990},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1540614642991},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1540614642991},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1540614642991},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1540614642992},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"7a2706304465b9e673d5561b715e7c72a238437c","modified":1540614643009},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1540614643009},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"32392d213f5d05bc26b2dc452f2fc6fea9d44f6d","modified":1540614643009},{"_id":"themes/next/source/css/_variables/base.styl","hash":"cfb03ec629f13883509eac66e561e9dba562333f","modified":1540614643009},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1540614643021},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1540614643021},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1540614643021},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1540614643021},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1540614643021},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1540614643005},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1540614643005},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1540614643005},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"81ca13d6d0beff8b1a4b542a51e3b0fb68f08efd","modified":1540614643005},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1540614643026},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1540614643026},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1540614643026},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1540614643019},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1540614643019},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1540614643019},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"40de94fd18fcbd67a327d63b0d1e242a08aa5404","modified":1540614643019},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1540614643020},{"_id":"themes/next/source/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1540614643020},{"_id":"themes/next/source/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1540614643020},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1540614643020},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1540614643020},{"_id":"themes/next/source/js/src/utils.js","hash":"4284c67ea1435de2acd523f6d48c0d073fd1ad03","modified":1540614643020},{"_id":"source/_posts/Algorithm/Optimize Algorithm/2017-11-30-Batch Gradient Descent.md","hash":"dd48c8724f3f620296c83cbeb13b0f586976dfbf","modified":1540614642948},{"_id":"source/_posts/Algorithm/Optimize Algorithm/2017-12-12-Gradient Descent.md","hash":"ee93f784220bc317fc7db1b4a11ee78ed04bbc1f","modified":1540614642949},{"_id":"source/_posts/Algorithm/Optimize Algorithm/2017-12-11-Stochastic Gradient Descent.md","hash":"7ae46c9c32c28c502ae4e78d9563c7b06115dbf5","modified":1540614642948},{"_id":"source/_posts/Algorithm/Optimize Algorithm/2017-12-12-Maximum Likelihood Estimation.md","hash":"b2775d250d28a99a6613c9d28d6a8d2aa36b1f75","modified":1540614642949},{"_id":"source/_posts/Algorithm/Optimize Algorithm/2017-12-12-Mini-Batch Gradient Descent.md","hash":"21d7762251e9f8a30e46453565a9613c42e7883b","modified":1540614642949},{"_id":"source/_posts/Mathematics/Calculus/2017-11-02-Differentiation Rules.md","hash":"10f44e6000280c0d0ca71bfe08ac5710b08ef368","modified":1540614642950},{"_id":"source/_posts/Mathematics/Calculus/2017-11-02-Function and limit.md","hash":"ca1bf2c615e19d3b31a0712112ae916214013892","modified":1540614642950},{"_id":"source/_posts/Mathematics/Calculus/2017-11-02-What is a one-sided limit.md","hash":"29619af2ea27b6e8feb2fad4b484ed795553e46d","modified":1540614642950},{"_id":"source/_posts/Mathematics/Calculus/2017-11-03-Practical Derivatives.md","hash":"56d1e74a91a1c1661d7e0a198e73705585e6f6c8","modified":1540614642950},{"_id":"source/_posts/Mathematics/Calculus/2017-11-04-Typlor Expansion Example.md","hash":"80cd0da1f2af86eab487b182046b964e4e5eb84f","modified":1540614642951},{"_id":"source/_posts/Others/Git/2018-08-21-Workflow of Resolve Comflicts.md","hash":"caa2093f348a5e492ca15ce3bf217a159ae8fd70","modified":1540614642953},{"_id":"source/_posts/Others/Git/2018-08-23-Git Bash Save Credential - Push without Entering Usename and Password Every Time (git bash in windows).md","hash":"bb63931415070756ecaa88c90b1452dffeaafb20","modified":1540614642953},{"_id":"source/_posts/Others/Hexos/2017-11-22-Deploy Blog With Hexo And Github Page.md","hash":"c5206404e12670075dc1a95a445b3a8673017df6","modified":1540614642953},{"_id":"source/_posts/Others/Markdown/2017-12-03-How to Render the Hyperlink with Braces.md","hash":"297197c0441a588060ce1528509d547744ba596d","modified":1540614642953},{"_id":"source/_posts/Others/Hexos/2017-11-23-Hexo Next Theme Beautification.md","hash":"6c2fdbd3c9b20d8b5c9d5a225f0599c01f7a4b78","modified":1540614642953},{"_id":"source/_posts/Others/Markdown/2017-11-30-How to use MathJax in Markdown.md","hash":"831a877b244b1658386d5e98687d9a41de528959","modified":1540614642953},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1540614643024},{"_id":"themes/next/source/images/alipay.jpg","hash":"e34cd1e8fa17b157c0391bb897f3c10d80cd08f7","modified":1540614643011},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1540614642991},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1540614642991},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1540614643001},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1540614643004},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1540614643004},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1540614643004},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1540614643004},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1540614643004},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1540614643004},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1540614643005},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1540614643021},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1540614643022},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1540614643022},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f362fbc791dafb378807cabbc58abf03e097af6d","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1540614643006},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1540614643007},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1540614643007},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1540614643007},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1540614643007},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1540614643007},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1540614643008},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba1842dbeb97e46c6c4d2ae0e7a2ca6d610ada67","modified":1540614643008},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1540614643008},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1540614643008},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1540614643008},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1540614643008},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1540614643008},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1540614643024},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1540614643025},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1540614643020},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1540614643023},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1540614643024},{"_id":"themes/next/source/images/android-chrome-512x512.png","hash":"668da720cbcb765a3baf9a026abc8b0a65d4d0cd","modified":1540614643012},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1540614643025},{"_id":"source/_posts/Mathematics/Calculus/images/1. one-sided limits.jpg","hash":"1598fbf08396e45a5b5ded0d5806fd89738f61f5","modified":1540614642952},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1540614642995},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1540614642996},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1540614642996},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1540614642996},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1540614642996},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1540614642996},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1540614642996},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1540614642996},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1540614642997},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"0b57ca04dc3998cf70bb90d777b0db05f3928b82","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1540614642998},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1540614642999},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"c0ac49fadd33ca4a9a0a04d5ff2ac6560d0ecd9e","modified":1540614642999},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1540614642999},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1540614642999},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1540614642999},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c06be422bc41fd35e5c7948cdea2c09961207f6","modified":1540614643003},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1540614642999},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1540614642999},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1540614643000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1540614643000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1540614643000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1540614643000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1540614643000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1540614643000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1540614643001},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1540614643001},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1540614643001},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1540614643001},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"5d15cc8bbefe44c77a9b9f96bf04a6033a4b35b8","modified":1540614643001},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1540614643002},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1540614643002},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1540614643002},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1540614643002},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1540614643002},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1540614643002},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1540614643007},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1540614643007},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1540614643023},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1540614643008},{"_id":"source/_posts/Mathematics/Calculus/images/1. one-sided limit graph.jpg","hash":"e9b6f7c3011b7a26c6f53e19d35fd3b77057ef99","modified":1540614642952},{"_id":"themes/next/source/images/avatar.png","hash":"29cd9d85ea4ba7e7eb1be1328b3f708b3b619624","modified":1540614643015},{"_id":"public/search.xml","hash":"ae3654c5402bdb971e715a267da424344c1fca81","modified":1543933246181},{"_id":"public/sitemap.xml","hash":"ada3f4730d4c689173500daae8c2cfc6ec232bcf","modified":1543933523558},{"_id":"public/atom.xml","hash":"09ec8dd1dfff578a3be7177baab24181d566e6a5","modified":1543933078771},{"_id":"public/about/index.html","hash":"5a2884535b069838bf09c81ca780c81659dfb291","modified":1543933078778},{"_id":"public/categories/index.html","hash":"3a4710993cbd25267c6ff5c31ce20e5228154008","modified":1543933078778},{"_id":"public/tags/index.html","hash":"d4ef6572452bfab9950ae543aeaabc6f7c6a15f8","modified":1543933078778},{"_id":"public/projects/index.html","hash":"02b6dbc871d8d4a829b0256686dfb91eec1520aa","modified":1543933523587},{"_id":"public/2018/10/27/MySQL/2018-10-27-MySQL_connection/index.html","hash":"66a6bf17524855ee6dc315864bf543f70c8f2009","modified":1543933078778},{"_id":"public/2018/08/23/Others/Git/2018-08-23-Git Bash Save Credential - Push without Entering Usename and Password Every Time (git bash in windows)/index.html","hash":"a73307fb7c8e10d963c8f47225d7b856a379a3e4","modified":1543933078778},{"_id":"public/2018/08/20/Others/Git/2018-08-21-Workflow of Resolve Comflicts/index.html","hash":"ba5081c76490e9be1405c265f3e80ac771771a90","modified":1543933078778},{"_id":"public/2018/08/17/Visualization/2018-08-17-helpful_visualization_tutorial/index.html","hash":"ed7adc72330b2e88ca1ba845f4e4e24af1381726","modified":1543933078778},{"_id":"public/2017/12/12/Algorithm/Optimize Algorithm/2017-12-12-Maximum Likelihood Estimation/index.html","hash":"60dbf62c40a9d84e4586d31b70da038345d4b1eb","modified":1543933078778},{"_id":"public/2017/12/12/Algorithm/Optimize Algorithm/2017-12-12-Gradient Descent/index.html","hash":"27a7acd8e0df9eb8558e67a5ab25dc547e495375","modified":1543933078778},{"_id":"public/2017/12/12/Algorithm/Optimize Algorithm/2017-12-12-Mini-Batch Gradient Descent/index.html","hash":"d5c56e04f8251977b0f3f4c495bfe719a6f767b9","modified":1543933078778},{"_id":"public/2017/12/11/Algorithm/Optimize Algorithm/2017-12-11-Stochastic Gradient Descent/index.html","hash":"c8e63c03480f4f29c1e58ae2288a47ea26a2145c","modified":1543933078778},{"_id":"public/2017/12/04/Latex/2017-12-05-Latex常见错误整理/index.html","hash":"da98a9121bfbf6f76d5b05fa9126dec6cb95132a","modified":1543933078778},{"_id":"public/2017/12/02/Others/Markdown/2017-12-03-How to Render the Hyperlink with Braces/index.html","hash":"518ef23973831a009a1da60d77ed6566c04f4eaf","modified":1543933078778},{"_id":"public/2017/11/30/Mathematics/2017-11-30-Concave and Convex Function/index.html","hash":"cd76a600dc057d21c9a1673457002184d5c6435e","modified":1543933078778},{"_id":"public/2017/11/30/Algorithm/Optimize Algorithm/2017-11-30-Batch Gradient Descent/index.html","hash":"60b3d9685f8eaf26a14e7a3829913ca774bfb3e5","modified":1543933078779},{"_id":"public/2017/11/29/ML System Tips/2017-11-30-Get More Data/index.html","hash":"8b54ecdceaf08df1a73f44b741df2bb2cbca340e","modified":1543933078779},{"_id":"public/2017/11/29/Others/Markdown/2017-11-30-How to use MathJax in Markdown/index.html","hash":"8c19d83add5a22dc71caac0e5040b119796a3338","modified":1543933078779},{"_id":"public/2017/11/22/Others/Hexos/2017-11-23-Hexo Next Theme Beautification/index.html","hash":"69d2fe1818fac907293ea0eac703dabe7b148988","modified":1543933078779},{"_id":"public/2017/11/21/Others/Hexos/2017-11-22-Deploy Blog With Hexo And Github Page/index.html","hash":"a7f60b64bb6f8e2761ba35bffe5346e231c6e98d","modified":1543933078779},{"_id":"public/2017/11/04/Mathematics/Calculus/2017-11-04-Typlor Expansion Example/index.html","hash":"155baf9d4f1b3a43a5260aebe09fb2b16afc6dc1","modified":1543933078779},{"_id":"public/2017/11/03/Mathematics/Calculus/2017-11-03-Practical Derivatives/index.html","hash":"988a6846c966a93850fa22a6333d0bcc3c970e29","modified":1543933078779},{"_id":"public/2017/11/02/Mathematics/Calculus/2017-11-02-Differentiation Rules/index.html","hash":"b900a0be068799c3c1b53799baa528e7ed444264","modified":1543933078779},{"_id":"public/2017/11/01/Mathematics/Calculus/2017-11-02-What is a one-sided limit/index.html","hash":"56386c73e29068a575f2074b97ad349819ad2792","modified":1543933078780},{"_id":"public/2017/11/01/Mathematics/Calculus/2017-11-02-Function and limit/index.html","hash":"846e7f2c7e68158152f05cdacf3740507110b059","modified":1543933078780},{"_id":"public/2017/11/01/Mathematics/2017-11-01-线性模型性能分析--混淆矩阵(Confusion Matrix)/index.html","hash":"d4273f6621adb024dd7035be6b0458f20ca12e3d","modified":1543933078780},{"_id":"public/2017/10/31/Mathematics/2017-10-31-数据分割/index.html","hash":"1038ba3b51648530c662458e5c54f74df423c02d","modified":1543933078780},{"_id":"public/2017/10/30/Mathematics/2017-10-30-Sigmoid Function/index.html","hash":"f45dfe078d40d6a483e4e499d43594f61918009f","modified":1543933078780},{"_id":"public/2017/10/29/Mathematics/2017-10-29-数据预处理-数据归一化和数据规范化/index.html","hash":"08c309f7e616357ec9ceac90182676b5aa6b42ae","modified":1543933078780},{"_id":"public/2017/10/28/Mathematics/2017-10-29-tanh Function/index.html","hash":"862d78d37e332baf50172d265f4b19bada5e6970","modified":1543933078780},{"_id":"public/2017/10/28/Mathematics/2017-10-28-MatrixToVector/index.html","hash":"e729a2b2b72ce3609524b16b2ef27297620aa114","modified":1543933078780},{"_id":"public/2017/10/22/ReadNote-Machine Learning Foudantion -NTU/2017-10-22-15.Summary - Power of Three/index.html","hash":"464993824d004094d4fa07a07eccb0ff298f6283","modified":1543933078780},{"_id":"public/2017/10/20/ReadNote-Machine Learning Foudantion -NTU/2017-10-21-14.How can Machine Learn Better - Three Learning Principles/index.html","hash":"b12a98d051c6aa1c8a20b89c013e589f011ef421","modified":1543933078780},{"_id":"public/2017/10/18/ReadNote-Machine Learning Foudantion -NTU/2017-10-18-13.How can Machine Learn Better - Validation/index.html","hash":"682fc9cdb66c2e4487b617eae845a40a065e12e6","modified":1543933078780},{"_id":"public/2017/10/16/ReadNote-Machine Learning Foudantion -NTU/2017-10-17-12.How can Machine Learn Better - Regularization/index.html","hash":"9d0ace4e6c40b6a1b155f5f1e122a488d6961f32","modified":1543933078780},{"_id":"public/2017/10/16/ReadNote-Machine Learning Foudantion -NTU/2017-10-16-11.How can Machine Learn Better - Overfitting and Solution/index.html","hash":"4d0fadc8d9c74da5507dea73c5f99aa07a630ee0","modified":1543933078780},{"_id":"public/2017/10/15/ReadNote-Machine Learning Foudantion -NTU/2017-10-15-10.How can Machine Learn - Nonlinear Transformation/index.html","hash":"8b610ddcb07f1e9afbe88fd29401d05c65800dfb","modified":1543933078781},{"_id":"public/2017/10/14/ReadNote-Machine Learning Foudantion -NTU/2017-10-14-9.How can Machine Learn - Linear Model for Classification/index.html","hash":"3c624e032c8df15d49edf959735e2670cc1fb581","modified":1543933078781},{"_id":"public/2017/10/13/ReadNote-Machine Learning Foudantion -NTU/2017-10-13-8.How can Machine Learn - Logistic Regression/index.html","hash":"f99c40492b7b8811aea2a05f943a659974974528","modified":1543933078781},{"_id":"public/2017/10/11/ReadNote-Machine Learning Foudantion -NTU/2017-10-11-7.How can Machine Learn - Linear Regression/index.html","hash":"206a6c3f0f76a698bcedc2fbef4f1ab25d92d3be","modified":1543933078781},{"_id":"public/2017/10/09/ReadNote-Machine Learning Foudantion -NTU/2017-10-09-6.How can Machine Learn - Noice and Error/index.html","hash":"6fc55e982237bd81780cfd03ad4592477ddfa65e","modified":1543933078781},{"_id":"public/2017/10/08/ReadNote-Machine Learning Foudantion -NTU/2017-10-08-5.Why Can Machine Learn/index.html","hash":"29d611a509aaed903480fc23ea35aebd357e78ca","modified":1543933078781},{"_id":"public/2017/10/06/ReadNote-Machine Learning Foudantion -NTU/2017-10-06-4.When can Machine Learn - Feasible of Learning/index.html","hash":"9d97b7fe3fe49e2e415b0a6128159887c66ead5f","modified":1543933078781},{"_id":"public/2017/10/04/ReadNote-Machine Learning Foudantion -NTU/2017-10-04-3.When can Machine Learn - Types of Learning/index.html","hash":"eaf48a08da55c399128ec7605ae48d33f766103e","modified":1543933078781},{"_id":"public/2017/10/02/ReadNote-Machine Learning Foudantion -NTU/2017-10-03-2.When can Machine Learn - Learning to Answer Yes or No/index.html","hash":"7b742027b421bbe6be2d9e385e04775e2d5b4f17","modified":1543933078781},{"_id":"public/2017/10/02/ReadNote-Machine Learning Foudantion -NTU/2017-10-02-1.When can Machine Learn - The Learning Problem/index.html","hash":"7ddba37c7551183433cbfcaf5b1fecb1d58fdb51","modified":1543933078781},{"_id":"public/2017/09/30/ReadNote-Machine Learning Foudantion -NTU/2017-10-01-0.Machine Learning Foundation - Table of Contents/index.html","hash":"e0d4fa30e77d4c2ec6ea21dc860a06fc16c2368d","modified":1543933078781},{"_id":"public/2017/09/15/2017-09-15-Why Keep Writing Blog/index.html","hash":"b812dc8bf28656a9c1188d1b38f1dd997a7440f4","modified":1543933078781},{"_id":"public/archives/index.html","hash":"ae64ca9984126924e11f153e3c02ce31f735928e","modified":1543933523587},{"_id":"public/archives/page/2/index.html","hash":"8f116b69dc92ca7e55f2b52d166b39e586253065","modified":1543933078782},{"_id":"public/archives/2017/index.html","hash":"d68f76ebcd7b8556b720e0e39149c503efd1aef7","modified":1543933523587},{"_id":"public/archives/2017/page/2/index.html","hash":"5ff87729f3eee35fe5c5676a3660f75c5a8baa3d","modified":1543933078782},{"_id":"public/archives/2017/09/index.html","hash":"d2499ab643058a5f1471a65132b29c53d4070a8d","modified":1543933078782},{"_id":"public/archives/2017/10/index.html","hash":"1bf7e2aa08cc1bb512b21ccccae415ca696dfa25","modified":1543933078782},{"_id":"public/archives/2017/11/index.html","hash":"39867f5a2dfbc826edf700e3e48c53fa1c3223bf","modified":1543933523587},{"_id":"public/archives/2017/12/index.html","hash":"91bc7e45394ad3aae4d8763b0d5f535d6d8f3427","modified":1543933078782},{"_id":"public/archives/2018/index.html","hash":"82cc57b822378778fe7899c02ed5399b7b86b170","modified":1543933078782},{"_id":"public/archives/2018/08/index.html","hash":"f42364b7cb523f8b0c07f2c2f8b3d4751452f854","modified":1543933078782},{"_id":"public/archives/2018/10/index.html","hash":"e46a7822afe44ed17ef20f61c42dc35486408d35","modified":1543933078782},{"_id":"public/categories/ReadNote/index.html","hash":"cabbbf7a5ce1bd6341bce9f5de5c30a6dd374519","modified":1543933078782},{"_id":"public/categories/MySQL/index.html","hash":"c27f377610060f606ff82332b3ca85a187de26fc","modified":1543933078782},{"_id":"public/categories/Latex/index.html","hash":"091d50baec70ebc3872e29a0daa5e0002bd6bf69","modified":1543933078782},{"_id":"public/categories/Machine-Learning-System-Tips/index.html","hash":"0503274ecbee65803a964fa19ae5afc95875920d","modified":1543933078783},{"_id":"public/categories/Machine-Learning-Mathematics/index.html","hash":"97f387db61ee216a3095a12e657e588c9466d23d","modified":1543933078783},{"_id":"public/categories/Visualization/index.html","hash":"c5bbf150b16a479de7166eed5c28d204d4f4cf24","modified":1543933078783},{"_id":"public/categories/Machine-Learning-Algorithm/index.html","hash":"060dd7ed5236d444419767d4045b63e2a47d3a8e","modified":1543933078783},{"_id":"public/categories/Git/index.html","hash":"4b8e51988ce39c610a8061ff9bedcebcd5c0deb2","modified":1543933078783},{"_id":"public/categories/Hexo/index.html","hash":"d8da0ba0ce4438088dda32a35a646b30a95b0b10","modified":1543933078783},{"_id":"public/categories/Markdown/index.html","hash":"79afc82c96bc0fadffb1aeb2a13d391b35ee784a","modified":1543933078783},{"_id":"public/index.html","hash":"0646251a2939f8ce4ab908f2d4284397c0cce730","modified":1543933078783},{"_id":"public/page/2/index.html","hash":"49a5f1b752225c69bdfeb666044ecbb5c8718c98","modified":1543933078783},{"_id":"public/tags/ReadNote-Machine-Learning-Foundation/index.html","hash":"b2d37df61ecbe1904912ae4af3ca87356ba7c836","modified":1543933078783},{"_id":"public/tags/MySQL/index.html","hash":"4d2f1f8242bff02b0418cfa6fb502faccaba7b62","modified":1543933078783},{"_id":"public/tags/Latex/index.html","hash":"f7e2b8f17479a1e16fb919368780288f028e3df4","modified":1543933078783},{"_id":"public/tags/Machine-Learning-System-Tips/index.html","hash":"8136f83da20c70182a354795da6fa1a5a3bae3d2","modified":1543933078783},{"_id":"public/tags/Machine-Learning/index.html","hash":"7b61fd65fe16d09d234c2640e4cf60710e7a7c11","modified":1543933078783},{"_id":"public/tags/Mathematics/index.html","hash":"77faadb3c334b5142fff7415aa248f644cf326b8","modified":1543933078784},{"_id":"public/tags/Machine-Learning-Mathematics/index.html","hash":"574719ed0136d067f69aa51f8f67b7ae50ea366f","modified":1543933078784},{"_id":"public/tags/Visualization/index.html","hash":"a761258921170d3ef351d84ccf36d226af6eee06","modified":1543933078784},{"_id":"public/tags/Machine-Learning-Algorithm/index.html","hash":"fb2a3780ce037d535a20f0048e64383757a736eb","modified":1543933078784},{"_id":"public/tags/Calculus/index.html","hash":"569d58a4498104be814c01f573f39376a3a982c8","modified":1543933078784},{"_id":"public/tags/Git/index.html","hash":"3291d58beb12d671ae1a7f23336d455720d60c8b","modified":1543933078784},{"_id":"public/tags/Hexo/index.html","hash":"0fa8abafa0ed25a4f851eb86379e0214eb9e9bad","modified":1543933078784},{"_id":"public/tags/Markdown/index.html","hash":"7ca08bb75893723c8706aa926abc0759a41086f4","modified":1543933078784},{"_id":"public/tags/Mathjax/index.html","hash":"02241319a947768c61678c07be0c1c3b2b1681ef","modified":1543933078784},{"_id":"public/README.md","hash":"d8f896188a38c25119b1bbbf897a64cefc264748","modified":1543933078792},{"_id":"public/CNAME","hash":"afc93543189a76690a2ad1b7546a202fb87ac2cf","modified":1543933078792},{"_id":"public/robots.txt","hash":"2c8806cd2dc92734728da893c73876ec3609df78","modified":1543933078792},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543933078792},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543933078792},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543933078792},{"_id":"public/images/android-chrome-192x192.png","hash":"1c4e77121a942fce2a122f56ad4c8120444f681b","modified":1543933078792},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543933078792},{"_id":"public/images/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1543933078792},{"_id":"public/images/apple-touch-icon.png","hash":"457f72c374756faeb4b375d4413b2c4eeb921093","modified":1543933078792},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543933078792},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543933078792},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543933078792},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543933078792},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543933078793},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543933078793},{"_id":"public/images/favicon-16x16.png","hash":"729e9550a1465cbeffdcbea5b70bb27883da981d","modified":1543933078793},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543933078793},{"_id":"public/images/favicon-32x32.png","hash":"b398dd3db0a29507602e6945c4e9606d188d523e","modified":1543933078793},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543933078793},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543933078793},{"_id":"public/images/favicon.ico","hash":"9c756e07b09d87bd03c30dc4315ac7818fd6c400","modified":1543933078793},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543933078793},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543933078793},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543933078793},{"_id":"public/images/mstile-150x150.png","hash":"3b50bc2c1c01c5dc42e4da0ecec5129201612581","modified":1543933078793},{"_id":"public/images/safari-pinned-tab.svg","hash":"e2ca3df89ab832d15933d3ea9b71226f662e168d","modified":1543933078793},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543933078793},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543933078793},{"_id":"public/images/site.webmanifest","hash":"13e5aa58eb2182d8ace63266856c8cc29c47c083","modified":1543933078793},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543933078793},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543933078793},{"_id":"public/css/main.css","hash":"7fd4b53e03717fb57bb6f5350580ea40603edfae","modified":1543933079310},{"_id":"public/images/wechatpay.jpg","hash":"652b5c1055cfa52ae6005cba00c751b1ec55b8f5","modified":1543933079310},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543933079313},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543933079313},{"_id":"public/resume_Columbia_University_Zhicheng_Ding.pdf","hash":"5fad12f5f6a769bc68ba08051512132ec8335bcf","modified":1543933079313},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1543933079321},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543933079321},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1543933079321},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1543933079321},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1543933079321},{"_id":"public/js/src/bootstrap.js","hash":"40de94fd18fcbd67a327d63b0d1e242a08aa5404","modified":1543933079321},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543933079322},{"_id":"public/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1543933079322},{"_id":"public/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1543933079322},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1543933079322},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1543933079322},{"_id":"public/js/src/utils.js","hash":"4284c67ea1435de2acd523f6d48c0d073fd1ad03","modified":1543933079322},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543933079322},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543933079322},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1543933079322},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543933079322},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543933079322},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543933079322},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543933079322},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543933079322},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543933079323},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543933079323},{"_id":"public/images/alipay.jpg","hash":"e34cd1e8fa17b157c0391bb897f3c10d80cd08f7","modified":1543933079324},{"_id":"public/images/android-chrome-512x512.png","hash":"668da720cbcb765a3baf9a026abc8b0a65d4d0cd","modified":1543933079328},{"_id":"public/images/avatar.png","hash":"29cd9d85ea4ba7e7eb1be1328b3f708b3b619624","modified":1543933079332}],"Category":[{"name":"ReadNote","_id":"cjp9tw08o0002e0owbxutgmyc"},{"name":"MySQL","_id":"cjp9tw0az000be0ow95to30rn"},{"name":"Latex","_id":"cjp9tw0b9000ge0owqcknzvvm"},{"name":"Machine-Learning-System-Tips","_id":"cjp9tw0bb000me0owcgjsm0pu"},{"name":"Machine-Learning-Mathematics","_id":"cjp9tw0bd000se0owzjytez8s"},{"name":"Visualization","_id":"cjp9tw0bw0020e0owbnbqvrzh"},{"name":"Machine-Learning-Algorithm","_id":"cjp9tw0du003ge0owwcuf7rf4"},{"name":"Git","_id":"cjp9tw0e7004ae0ow42i4bmuw"},{"name":"Hexo","_id":"cjp9tw0ec004qe0ow8gt3tql7"},{"name":"Markdown","_id":"cjp9tw0ed004we0ows9wrbegb"}],"Data":[],"Page":[{"title":"About","date":"2017-11-01T06:08:23.000Z","comments":0,"_content":"\n\n<p>\n<span class=\"hello\">\n  <em>Where</em>\n  <small>there is a will, there is a way! \n</span>\n</p>\n\n<blockquote>\n<p>\nThere is something inside, that they can't get to, that they can't touch. That's yours. --The Shawshank Redemption\n</p>\n</blockquote>\n\n\n<br>\n<p>\nThis is Zhicheng Ding, currrent a machine learning master student in University. This website aims to collect my blogs about life experience and technic understanding.\n</p>\n\n<p>\nI am interested in Natural Language Processing. My ultimate goal is to create a real-time high accuracy translator. I have this sense of idea for the reason that my father is afraid to travel aboard because of language problem.\n</p>\n\n<p>\nI support open source (@<a href=\"https://github.com/zhichengMLE\">zhichengMLE<i class=\"icon-github\"></i>)</a>. The most frequently language is Python and C++. \nI love fitness, tennis and hiking.\n</p>\n\n<p>\nI am fond of sharing knowledge. That's definitely the reason for my to keep writing blog. Meanwhile, I enjoy to overcome challenges. That's the why I choose to learn science. My dream is to be a professor in college since I could both sharing knowledge and overcomming challenges.\n</p>\n<p>\nFor more details about me, click here to access my <a href = \"http://www.linkedin.com/in/zhicheng-ding-a80595b3/\">linkedin<i class=\"icon-linkedin\"></i></a>.\n</p>","source":"about/index.md","raw":"---\ntitle: About\ndate: 2017-11-01 14:08:23\ncomments: false\n---\n\n\n<p>\n<span class=\"hello\">\n  <em>Where</em>\n  <small>there is a will, there is a way! \n</span>\n</p>\n\n<blockquote>\n<p>\nThere is something inside, that they can't get to, that they can't touch. That's yours. --The Shawshank Redemption\n</p>\n</blockquote>\n\n\n<br>\n<p>\nThis is Zhicheng Ding, currrent a machine learning master student in University. This website aims to collect my blogs about life experience and technic understanding.\n</p>\n\n<p>\nI am interested in Natural Language Processing. My ultimate goal is to create a real-time high accuracy translator. I have this sense of idea for the reason that my father is afraid to travel aboard because of language problem.\n</p>\n\n<p>\nI support open source (@<a href=\"https://github.com/zhichengMLE\">zhichengMLE<i class=\"icon-github\"></i>)</a>. The most frequently language is Python and C++. \nI love fitness, tennis and hiking.\n</p>\n\n<p>\nI am fond of sharing knowledge. That's definitely the reason for my to keep writing blog. Meanwhile, I enjoy to overcome challenges. That's the why I choose to learn science. My dream is to be a professor in college since I could both sharing knowledge and overcomming challenges.\n</p>\n<p>\nFor more details about me, click here to access my <a href = \"http://www.linkedin.com/in/zhicheng-ding-a80595b3/\">linkedin<i class=\"icon-linkedin\"></i></a>.\n</p>","updated":"2018-10-27T04:30:42.957Z","path":"about/index.html","layout":"page","_id":"cjp9tw08j0001e0owep9dak02","content":"<p>\n<span class=\"hello\">\n  <em>Where</em>\n  <small>there is a will, there is a way! \n</small></span>\n</p>\n\n<blockquote>\n<p>\nThere is something inside, that they can't get to, that they can't touch. That's yours. --The Shawshank Redemption\n</p>\n</blockquote>\n\n\n<p><br></p>\n<p>\nThis is Zhicheng Ding, currrent a machine learning master student in University. This website aims to collect my blogs about life experience and technic understanding.\n</p>\n\n<p>\nI am interested in Natural Language Processing. My ultimate goal is to create a real-time high accuracy translator. I have this sense of idea for the reason that my father is afraid to travel aboard because of language problem.\n</p>\n\n<p>\nI support open source (@<a href=\"https://github.com/zhichengMLE\" target=\"_blank\" rel=\"external\">zhichengMLE<i class=\"icon-github\"></i>)</a>. The most frequently language is Python and C++. \nI love fitness, tennis and hiking.\n</p>\n\n<p>\nI am fond of sharing knowledge. That's definitely the reason for my to keep writing blog. Meanwhile, I enjoy to overcome challenges. That's the why I choose to learn science. My dream is to be a professor in college since I could both sharing knowledge and overcomming challenges.\n</p>\n<p>\nFor more details about me, click here to access my <a href=\"http://www.linkedin.com/in/zhicheng-ding-a80595b3/\" target=\"_blank\" rel=\"external\">linkedin<i class=\"icon-linkedin\"></i></a>.\n</p>","site":{"data":{}},"excerpt":"","more":"<p>\n<span class=\"hello\">\n  <em>Where</em>\n  <small>there is a will, there is a way! \n</small></span>\n</p>\n\n<blockquote>\n<p>\nThere is something inside, that they can't get to, that they can't touch. That's yours. --The Shawshank Redemption\n</p>\n</blockquote>\n\n\n<p><br></p>\n<p>\nThis is Zhicheng Ding, currrent a machine learning master student in University. This website aims to collect my blogs about life experience and technic understanding.\n</p>\n\n<p>\nI am interested in Natural Language Processing. My ultimate goal is to create a real-time high accuracy translator. I have this sense of idea for the reason that my father is afraid to travel aboard because of language problem.\n</p>\n\n<p>\nI support open source (@<a href=\"https://github.com/zhichengMLE\" target=\"_blank\" rel=\"external\">zhichengMLE<i class=\"icon-github\"></i>)</a>. The most frequently language is Python and C++. \nI love fitness, tennis and hiking.\n</p>\n\n<p>\nI am fond of sharing knowledge. That's definitely the reason for my to keep writing blog. Meanwhile, I enjoy to overcome challenges. That's the why I choose to learn science. My dream is to be a professor in college since I could both sharing knowledge and overcomming challenges.\n</p>\n<p>\nFor more details about me, click here to access my <a href=\"http://www.linkedin.com/in/zhicheng-ding-a80595b3/\" target=\"_blank\" rel=\"external\">linkedin<i class=\"icon-linkedin\"></i></a>.\n</p>"},{"title":"Categories","date":"2017-11-01T06:59:40.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ndate: 2017-11-01 14:59:40\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-10-27T04:30:42.957Z","path":"categories/index.html","layout":"page","_id":"cjp9tw09j0006e0owvmibte4w","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","date":"2017-11-01T05:59:40.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2017-11-01 13:59:40\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-10-27T04:30:42.958Z","path":"tags/index.html","layout":"page","_id":"cjp9tw09k0007e0owwlgc5kwb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Projects","date":"2017-11-01T06:59:40.000Z","comments":0,"_content":"\n# Reinforcement Learning\n\n1. Maze - QLearning [[Demo]](https://youtu.be/dGsdZ1ID9_8)\n\n2. Mountain-Car - QLearning [[Demo]](https://youtu.be/m0FnRzyQ1Dw)\n\n3. Flappy Bird - Deep QLearning [[Demo]](https://youtu.be/2d4QtKOX014) [[Full-Training]](https://youtu.be/IgaaCkskzX4)\n\n\n# Computer Vision\n\n1. Probability Driven Multiple Object Tracking By Detection [[Demo]](https://motchallenge.net/tracker/TraByDetRT)\n    > - realtime (FPS: 21.4, 2.4GHz, 4Core, GeForce 850M)\n    > - online\n    > - Test Platform: MOT challenge\n\n2. The Online PDF Reader based on Gesture Movement [[Demo]](https://www.youtube.com/watch?v=IsIhWa0TZrA&feature=youtu.be)\n\n3. Background Style Tranferring [[Demo]](http://35.245.30.254:8080/#/)\n\n# Big Data Visualization\n\n1. relationship-between-commuter-flow-and-criminal-rate-in-Manhattan [[Demo]](http://35.231.39.145:8080)","source":"projects/index.md","raw":"---\ntitle: Projects\ndate: 2017-11-01 14:59:40\ncomments: false\n---\n\n# Reinforcement Learning\n\n1. Maze - QLearning [[Demo]](https://youtu.be/dGsdZ1ID9_8)\n\n2. Mountain-Car - QLearning [[Demo]](https://youtu.be/m0FnRzyQ1Dw)\n\n3. Flappy Bird - Deep QLearning [[Demo]](https://youtu.be/2d4QtKOX014) [[Full-Training]](https://youtu.be/IgaaCkskzX4)\n\n\n# Computer Vision\n\n1. Probability Driven Multiple Object Tracking By Detection [[Demo]](https://motchallenge.net/tracker/TraByDetRT)\n    > - realtime (FPS: 21.4, 2.4GHz, 4Core, GeForce 850M)\n    > - online\n    > - Test Platform: MOT challenge\n\n2. The Online PDF Reader based on Gesture Movement [[Demo]](https://www.youtube.com/watch?v=IsIhWa0TZrA&feature=youtu.be)\n\n3. Background Style Tranferring [[Demo]](http://35.245.30.254:8080/#/)\n\n# Big Data Visualization\n\n1. relationship-between-commuter-flow-and-criminal-rate-in-Manhattan [[Demo]](http://35.231.39.145:8080)","updated":"2018-12-04T14:25:15.557Z","path":"projects/index.html","_id":"cjp9tw09k0008e0owd3whbyek","layout":"page","content":"<h1 id=\"Reinforcement-Learning\"><a href=\"#Reinforcement-Learning\" class=\"headerlink\" title=\"Reinforcement Learning\"></a>Reinforcement Learning</h1><ol>\n<li><p>Maze - QLearning <a href=\"https://youtu.be/dGsdZ1ID9_8\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n<li><p>Mountain-Car - QLearning <a href=\"https://youtu.be/m0FnRzyQ1Dw\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n<li><p>Flappy Bird - Deep QLearning <a href=\"https://youtu.be/2d4QtKOX014\" target=\"_blank\" rel=\"external\">[Demo]</a> <a href=\"https://youtu.be/IgaaCkskzX4\" target=\"_blank\" rel=\"external\">[Full-Training]</a></p>\n</li>\n</ol>\n<h1 id=\"Computer-Vision\"><a href=\"#Computer-Vision\" class=\"headerlink\" title=\"Computer Vision\"></a>Computer Vision</h1><ol>\n<li><p>Probability Driven Multiple Object Tracking By Detection <a href=\"https://motchallenge.net/tracker/TraByDetRT\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n<blockquote>\n<ul>\n<li>realtime (FPS: 21.4, 2.4GHz, 4Core, GeForce 850M)</li>\n<li>online</li>\n<li>Test Platform: MOT challenge</li>\n</ul>\n</blockquote>\n</li>\n<li><p>The Online PDF Reader based on Gesture Movement <a href=\"https://www.youtube.com/watch?v=IsIhWa0TZrA&amp;feature=youtu.be\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n<li><p>Background Style Tranferring <a href=\"http://35.245.30.254:8080/#/\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n</ol>\n<h1 id=\"Big-Data-Visualization\"><a href=\"#Big-Data-Visualization\" class=\"headerlink\" title=\"Big Data Visualization\"></a>Big Data Visualization</h1><ol>\n<li>relationship-between-commuter-flow-and-criminal-rate-in-Manhattan <a href=\"http://35.231.39.145:8080\" target=\"_blank\" rel=\"external\">[Demo]</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Reinforcement-Learning\"><a href=\"#Reinforcement-Learning\" class=\"headerlink\" title=\"Reinforcement Learning\"></a>Reinforcement Learning</h1><ol>\n<li><p>Maze - QLearning <a href=\"https://youtu.be/dGsdZ1ID9_8\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n<li><p>Mountain-Car - QLearning <a href=\"https://youtu.be/m0FnRzyQ1Dw\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n<li><p>Flappy Bird - Deep QLearning <a href=\"https://youtu.be/2d4QtKOX014\" target=\"_blank\" rel=\"external\">[Demo]</a> <a href=\"https://youtu.be/IgaaCkskzX4\" target=\"_blank\" rel=\"external\">[Full-Training]</a></p>\n</li>\n</ol>\n<h1 id=\"Computer-Vision\"><a href=\"#Computer-Vision\" class=\"headerlink\" title=\"Computer Vision\"></a>Computer Vision</h1><ol>\n<li><p>Probability Driven Multiple Object Tracking By Detection <a href=\"https://motchallenge.net/tracker/TraByDetRT\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n<blockquote>\n<ul>\n<li>realtime (FPS: 21.4, 2.4GHz, 4Core, GeForce 850M)</li>\n<li>online</li>\n<li>Test Platform: MOT challenge</li>\n</ul>\n</blockquote>\n</li>\n<li><p>The Online PDF Reader based on Gesture Movement <a href=\"https://www.youtube.com/watch?v=IsIhWa0TZrA&amp;feature=youtu.be\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n<li><p>Background Style Tranferring <a href=\"http://35.245.30.254:8080/#/\" target=\"_blank\" rel=\"external\">[Demo]</a></p>\n</li>\n</ol>\n<h1 id=\"Big-Data-Visualization\"><a href=\"#Big-Data-Visualization\" class=\"headerlink\" title=\"Big Data Visualization\"></a>Big Data Visualization</h1><ol>\n<li>relationship-between-commuter-flow-and-criminal-rate-in-Manhattan <a href=\"http://35.231.39.145:8080\" target=\"_blank\" rel=\"external\">[Demo]</a></li>\n</ol>\n"}],"Post":[{"title":"Why Keep Writing Blog?","date":"2017-09-15T09:23:19.000Z","mathjax":false,"copyright":true,"top":200,"_content":"\n\n## 1. Personal Need\n\nBy writing blog, I could able to document my life experience. For so many time, I failed to recall expriences and what I have learned clearly.\n\nMemories are so fragile! Keeping a note is a good way to keep my life lively.\n\n## 2. Systematically Learn Kownledge\n\nWriting blog, especially technic blog is a good way to review theose knowledge systematically. When begin writing blog, I tried to build up the connection among the knowledge I have learned.\n\n## 3. Sharing is Happy\n\nSharing knowledge is a really a happy thing to me. My ultimate goal is to achieve something really pracitical for this world. Also, I like sharing and challenging difficulties. That's why I aims to become a professor in college. Start to write a blog is one of the great way to prepare for my goal.\n\n## 4. Knowledge Interaction\n\nWriting blog is also an another way to listen to people, for not only technic correction, but also life. As for technic blog, for sure I could not ensure all the things I write is 100% right. I will try my best to leave as least wrong idea as possible, but blog is a good way for reader to help me correct it. As for life experience, I would like to hear from different opinions. And I will try to best to do the best.\n\n\n\n\nFinally, hope everyone could find something useful in this blog. Good luck!\n\nThanks,\nZhichengMLE\n","source":"_posts/2017-09-15-Why Keep Writing Blog.md","raw":"---\ntitle: Why Keep Writing Blog?\ndate: 2017-09-15 17:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: false\ncopyright: true\ntop: 200\n---\n\n\n## 1. Personal Need\n\nBy writing blog, I could able to document my life experience. For so many time, I failed to recall expriences and what I have learned clearly.\n\nMemories are so fragile! Keeping a note is a good way to keep my life lively.\n\n## 2. Systematically Learn Kownledge\n\nWriting blog, especially technic blog is a good way to review theose knowledge systematically. When begin writing blog, I tried to build up the connection among the knowledge I have learned.\n\n## 3. Sharing is Happy\n\nSharing knowledge is a really a happy thing to me. My ultimate goal is to achieve something really pracitical for this world. Also, I like sharing and challenging difficulties. That's why I aims to become a professor in college. Start to write a blog is one of the great way to prepare for my goal.\n\n## 4. Knowledge Interaction\n\nWriting blog is also an another way to listen to people, for not only technic correction, but also life. As for technic blog, for sure I could not ensure all the things I write is 100% right. I will try my best to leave as least wrong idea as possible, but blog is a good way for reader to help me correct it. As for life experience, I would like to hear from different opinions. And I will try to best to do the best.\n\n\n\n\nFinally, hope everyone could find something useful in this blog. Good luck!\n\nThanks,\nZhichengMLE\n","slug":"2017-09-15-Why Keep Writing Blog","published":1,"updated":"2018-10-27T04:30:42.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw08f0000e0owujk2gwv5","content":"<h2 id=\"1-Personal-Need\"><a href=\"#1-Personal-Need\" class=\"headerlink\" title=\"1. Personal Need\"></a>1. Personal Need</h2><p>By writing blog, I could able to document my life experience. For so many time, I failed to recall expriences and what I have learned clearly.</p>\n<p>Memories are so fragile! Keeping a note is a good way to keep my life lively.</p>\n<h2 id=\"2-Systematically-Learn-Kownledge\"><a href=\"#2-Systematically-Learn-Kownledge\" class=\"headerlink\" title=\"2. Systematically Learn Kownledge\"></a>2. Systematically Learn Kownledge</h2><p>Writing blog, especially technic blog is a good way to review theose knowledge systematically. When begin writing blog, I tried to build up the connection among the knowledge I have learned.</p>\n<h2 id=\"3-Sharing-is-Happy\"><a href=\"#3-Sharing-is-Happy\" class=\"headerlink\" title=\"3. Sharing is Happy\"></a>3. Sharing is Happy</h2><p>Sharing knowledge is a really a happy thing to me. My ultimate goal is to achieve something really pracitical for this world. Also, I like sharing and challenging difficulties. That’s why I aims to become a professor in college. Start to write a blog is one of the great way to prepare for my goal.</p>\n<h2 id=\"4-Knowledge-Interaction\"><a href=\"#4-Knowledge-Interaction\" class=\"headerlink\" title=\"4. Knowledge Interaction\"></a>4. Knowledge Interaction</h2><p>Writing blog is also an another way to listen to people, for not only technic correction, but also life. As for technic blog, for sure I could not ensure all the things I write is 100% right. I will try my best to leave as least wrong idea as possible, but blog is a good way for reader to help me correct it. As for life experience, I would like to hear from different opinions. And I will try to best to do the best.</p>\n<p>Finally, hope everyone could find something useful in this blog. Good luck!</p>\n<p>Thanks,<br>ZhichengMLE</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Personal-Need\"><a href=\"#1-Personal-Need\" class=\"headerlink\" title=\"1. Personal Need\"></a>1. Personal Need</h2><p>By writing blog, I could able to document my life experience. For so many time, I failed to recall expriences and what I have learned clearly.</p>\n<p>Memories are so fragile! Keeping a note is a good way to keep my life lively.</p>\n<h2 id=\"2-Systematically-Learn-Kownledge\"><a href=\"#2-Systematically-Learn-Kownledge\" class=\"headerlink\" title=\"2. Systematically Learn Kownledge\"></a>2. Systematically Learn Kownledge</h2><p>Writing blog, especially technic blog is a good way to review theose knowledge systematically. When begin writing blog, I tried to build up the connection among the knowledge I have learned.</p>\n<h2 id=\"3-Sharing-is-Happy\"><a href=\"#3-Sharing-is-Happy\" class=\"headerlink\" title=\"3. Sharing is Happy\"></a>3. Sharing is Happy</h2><p>Sharing knowledge is a really a happy thing to me. My ultimate goal is to achieve something really pracitical for this world. Also, I like sharing and challenging difficulties. That’s why I aims to become a professor in college. Start to write a blog is one of the great way to prepare for my goal.</p>\n<h2 id=\"4-Knowledge-Interaction\"><a href=\"#4-Knowledge-Interaction\" class=\"headerlink\" title=\"4. Knowledge Interaction\"></a>4. Knowledge Interaction</h2><p>Writing blog is also an another way to listen to people, for not only technic correction, but also life. As for technic blog, for sure I could not ensure all the things I write is 100% right. I will try my best to leave as least wrong idea as possible, but blog is a good way for reader to help me correct it. As for life experience, I would like to hear from different opinions. And I will try to best to do the best.</p>\n<p>Finally, hope everyone could find something useful in this blog. Good luck!</p>\n<p>Thanks,<br>ZhichengMLE</p>\n"},{"title":"MySQL Connection (MACOS)","date":"2018-10-27T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# Problem: Trying to use nodejs (waterline) to connect MySQL locally, but got BAD CONNECTION error.\n\nSolution (MAC OS 10):\n\nMake sure MySQL works correctly.\n\nRef:\n- https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating\n- https://stackoverflow.com/questions/52372165/mysql-error-1064-42000-you-have-an-error-in-your-sql-syntax\n```\nbrew remove mysql\nbrew cleanup\nlaunchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\nrm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\nsudo rm -rf /usr/local/var/mysql\n\nbrew install mysql\nmysqld --initialize --explicit_defaults_for_timestamp\nmysql.server start # no sudo!\n```\n\nIf mysql.server work correctly, my sure you have the account and account is able to access using password.\n\nRun the following codes in shell\n\n```\nmysql -u root\n```\n\nThen run the following in MySQL shell.\n\n```\nCREATE USER 'root'@'%' IDENTIFIED BY 'password';\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%';\nalter user 'USER'@'localhost' identified with mysql_native_password by 'PASSWORD'\n```\n\nIt should be all set!\n\nEnv:\n- MACOS 10\n- Server version: 8.0.12 Homebrew (install via HomeBrew)\n\n","source":"_posts/MySQL/2018-10-27-MySQL_connection.md","raw":"---\ntitle: MySQL Connection (MACOS)\ndate: 2018-10-27 12:23:19\ncategories: [MySQL]\ntags: [MySQL]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# Problem: Trying to use nodejs (waterline) to connect MySQL locally, but got BAD CONNECTION error.\n\nSolution (MAC OS 10):\n\nMake sure MySQL works correctly.\n\nRef:\n- https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating\n- https://stackoverflow.com/questions/52372165/mysql-error-1064-42000-you-have-an-error-in-your-sql-syntax\n```\nbrew remove mysql\nbrew cleanup\nlaunchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\nrm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\nsudo rm -rf /usr/local/var/mysql\n\nbrew install mysql\nmysqld --initialize --explicit_defaults_for_timestamp\nmysql.server start # no sudo!\n```\n\nIf mysql.server work correctly, my sure you have the account and account is able to access using password.\n\nRun the following codes in shell\n\n```\nmysql -u root\n```\n\nThen run the following in MySQL shell.\n\n```\nCREATE USER 'root'@'%' IDENTIFIED BY 'password';\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%';\nalter user 'USER'@'localhost' identified with mysql_native_password by 'PASSWORD'\n```\n\nIt should be all set!\n\nEnv:\n- MACOS 10\n- Server version: 8.0.12 Homebrew (install via HomeBrew)\n\n","slug":"MySQL/2018-10-27-MySQL_connection","published":1,"updated":"2018-12-04T14:07:54.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0ax0009e0oww8m6xv71","content":"<h1 id=\"Problem-Trying-to-use-nodejs-waterline-to-connect-MySQL-locally-but-got-BAD-CONNECTION-error\"><a href=\"#Problem-Trying-to-use-nodejs-waterline-to-connect-MySQL-locally-but-got-BAD-CONNECTION-error\" class=\"headerlink\" title=\"Problem: Trying to use nodejs (waterline) to connect MySQL locally, but got BAD CONNECTION error.\"></a>Problem: Trying to use nodejs (waterline) to connect MySQL locally, but got BAD CONNECTION error.</h1><p>Solution (MAC OS 10):</p>\n<p>Make sure MySQL works correctly.</p>\n<p>Ref:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating</a></li>\n<li><a href=\"https://stackoverflow.com/questions/52372165/mysql-error-1064-42000-you-have-an-error-in-your-sql-syntax\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/52372165/mysql-error-1064-42000-you-have-an-error-in-your-sql-syntax</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew remove mysql</div><div class=\"line\">brew cleanup</div><div class=\"line\">launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</div><div class=\"line\">rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</div><div class=\"line\">sudo rm -rf /usr/local/var/mysql</div><div class=\"line\"></div><div class=\"line\">brew install mysql</div><div class=\"line\">mysqld --initialize --explicit_defaults_for_timestamp</div><div class=\"line\">mysql.server start # no sudo!</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>If mysql.server work correctly, my sure you have the account and account is able to access using password.</p>\n<p>Run the following codes in shell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mysql -u root</div></pre></td></tr></table></figure>\n<p>Then run the following in MySQL shell.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;;</div><div class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos;;</div><div class=\"line\">alter user &apos;USER&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;PASSWORD&apos;</div></pre></td></tr></table></figure>\n<p>It should be all set!</p>\n<p>Env:</p>\n<ul>\n<li>MACOS 10</li>\n<li>Server version: 8.0.12 Homebrew (install via HomeBrew)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Problem-Trying-to-use-nodejs-waterline-to-connect-MySQL-locally-but-got-BAD-CONNECTION-error\"><a href=\"#Problem-Trying-to-use-nodejs-waterline-to-connect-MySQL-locally-but-got-BAD-CONNECTION-error\" class=\"headerlink\" title=\"Problem: Trying to use nodejs (waterline) to connect MySQL locally, but got BAD CONNECTION error.\"></a>Problem: Trying to use nodejs (waterline) to connect MySQL locally, but got BAD CONNECTION error.</h1><p>Solution (MAC OS 10):</p>\n<p>Make sure MySQL works correctly.</p>\n<p>Ref:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating</a></li>\n<li><a href=\"https://stackoverflow.com/questions/52372165/mysql-error-1064-42000-you-have-an-error-in-your-sql-syntax\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/52372165/mysql-error-1064-42000-you-have-an-error-in-your-sql-syntax</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew remove mysql</div><div class=\"line\">brew cleanup</div><div class=\"line\">launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</div><div class=\"line\">rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</div><div class=\"line\">sudo rm -rf /usr/local/var/mysql</div><div class=\"line\"></div><div class=\"line\">brew install mysql</div><div class=\"line\">mysqld --initialize --explicit_defaults_for_timestamp</div><div class=\"line\">mysql.server start # no sudo!</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>If mysql.server work correctly, my sure you have the account and account is able to access using password.</p>\n<p>Run the following codes in shell</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mysql -u root</div></pre></td></tr></table></figure>\n<p>Then run the following in MySQL shell.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;;</div><div class=\"line\">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos;;</div><div class=\"line\">alter user &apos;USER&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;PASSWORD&apos;</div></pre></td></tr></table></figure>\n<p>It should be all set!</p>\n<p>Env:</p>\n<ul>\n<li>MACOS 10</li>\n<li>Server version: 8.0.12 Homebrew (install via HomeBrew)</li>\n</ul>\n"},{"title":"Latex 常见错误整理","date":"2017-12-05T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Latex 常见错误整理\n\n## 1. 求导\n\n```\n\\sideset{^*}{'}\\sum_{1\\le i\\le 100} A(i)\n\\qquad\n\\sum_{1\\le i\\le 100}\\vphantom{\\sum}^{'} A(i)\n\\qquad\n\\mathop{{\\sum}'}_{1\\le i\\le 100} A(i)\n```\n\n$$\n\\sideset{^*}{'}\\sum_{1\\le i\\le 100} A(i)\n\\qquad\n\\sum_{1\\le i\\le 100}\\vphantom{\\sum}^{'} A(i)\n$$\n\n## 2. 下标\n\n```\nC_{1} + {C_2} \\\\\nC_{m,n}\n```\n\n$$\nC_{1} + {C_2} \\\\\nC_{m,n}\n$$\n\n\n## 3. 前缀\n\n```\n{\\int_{0}^{\\frac{\\pi}{2}}} \\\\\n\\sum_{i=1}^{n}\\\\\n\\prod_\\epsilon\n```\n\n$$\n{\\int_{0}^{\\frac{\\pi}{2}}} \\\\\n\\sum_{i=1}^{n}\\\\\n\\prod_\\epsilon\n$$\n\n## 4. 占位符\n\n```\nC_{1} \\qquad {C_2} \\\\\nC_{1} \\quad {C_2} \\\\\nC_{1} \\ {C_2}\n```\n\n$$\nC_{1} \\qquad {C_2} \\\\\nC_{1} \\quad {C_2} \\\\\nC_{1} \\ {C_2}\n$$\n\n## 5. 公式对齐\n\n```\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}\n$$\n```\n\n\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}\n$$\n\n\n\n------------------------------------------\n<br>\n<br>","source":"_posts/Latex/2017-12-05-Latex常见错误整理.md","raw":"---\ntitle: Latex 常见错误整理\ndate: 2017-12-05 12:23:19\ncategories: [Latex]\ntags: [Latex]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Latex 常见错误整理\n\n## 1. 求导\n\n```\n\\sideset{^*}{'}\\sum_{1\\le i\\le 100} A(i)\n\\qquad\n\\sum_{1\\le i\\le 100}\\vphantom{\\sum}^{'} A(i)\n\\qquad\n\\mathop{{\\sum}'}_{1\\le i\\le 100} A(i)\n```\n\n$$\n\\sideset{^*}{'}\\sum_{1\\le i\\le 100} A(i)\n\\qquad\n\\sum_{1\\le i\\le 100}\\vphantom{\\sum}^{'} A(i)\n$$\n\n## 2. 下标\n\n```\nC_{1} + {C_2} \\\\\nC_{m,n}\n```\n\n$$\nC_{1} + {C_2} \\\\\nC_{m,n}\n$$\n\n\n## 3. 前缀\n\n```\n{\\int_{0}^{\\frac{\\pi}{2}}} \\\\\n\\sum_{i=1}^{n}\\\\\n\\prod_\\epsilon\n```\n\n$$\n{\\int_{0}^{\\frac{\\pi}{2}}} \\\\\n\\sum_{i=1}^{n}\\\\\n\\prod_\\epsilon\n$$\n\n## 4. 占位符\n\n```\nC_{1} \\qquad {C_2} \\\\\nC_{1} \\quad {C_2} \\\\\nC_{1} \\ {C_2}\n```\n\n$$\nC_{1} \\qquad {C_2} \\\\\nC_{1} \\quad {C_2} \\\\\nC_{1} \\ {C_2}\n$$\n\n## 5. 公式对齐\n\n```\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}\n$$\n```\n\n\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}\n$$\n\n\n\n------------------------------------------\n<br>\n<br>","slug":"Latex/2017-12-05-Latex常见错误整理","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0ay000ae0ow8dw3l8d0","content":"<h1 id=\"Latex-常见错误整理\"><a href=\"#Latex-常见错误整理\" class=\"headerlink\" title=\"Latex 常见错误整理\"></a>Latex 常见错误整理</h1><h2 id=\"1-求导\"><a href=\"#1-求导\" class=\"headerlink\" title=\"1. 求导\"></a>1. 求导</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\sideset&#123;^*&#125;&#123;&apos;&#125;\\sum_&#123;1\\le i\\le 100&#125; A(i)</div><div class=\"line\">\\qquad</div><div class=\"line\">\\sum_&#123;1\\le i\\le 100&#125;\\vphantom&#123;\\sum&#125;^&#123;&apos;&#125; A(i)</div><div class=\"line\">\\qquad</div><div class=\"line\">\\mathop&#123;&#123;\\sum&#125;&apos;&#125;_&#123;1\\le i\\le 100&#125; A(i)</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\n\\sideset{^*}{'}\\sum_{1\\le i\\le 100} A(i)\n\\qquad\n\\sum_{1\\le i\\le 100}\\vphantom{\\sum}^{'} A(i)</script><h2 id=\"2-下标\"><a href=\"#2-下标\" class=\"headerlink\" title=\"2. 下标\"></a>2. 下标</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">C_&#123;1&#125; + &#123;C_2&#125; \\\\</div><div class=\"line\">C_&#123;m,n&#125;</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\nC_{1} + {C_2} \\\\\nC_{m,n}</script><h2 id=\"3-前缀\"><a href=\"#3-前缀\" class=\"headerlink\" title=\"3. 前缀\"></a>3. 前缀</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;\\int_&#123;0&#125;^&#123;\\frac&#123;\\pi&#125;&#123;2&#125;&#125;&#125; \\\\</div><div class=\"line\">\\sum_&#123;i=1&#125;^&#123;n&#125;\\\\</div><div class=\"line\">\\prod_\\epsilon</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\n{\\int_{0}^{\\frac{\\pi}{2}}} \\\\\n\\sum_{i=1}^{n}\\\\\n\\prod_\\epsilon</script><h2 id=\"4-占位符\"><a href=\"#4-占位符\" class=\"headerlink\" title=\"4. 占位符\"></a>4. 占位符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">C_&#123;1&#125; \\qquad &#123;C_2&#125; \\\\</div><div class=\"line\">C_&#123;1&#125; \\quad &#123;C_2&#125; \\\\</div><div class=\"line\">C_&#123;1&#125; \\ &#123;C_2&#125;</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\nC_{1} \\qquad {C_2} \\\\\nC_{1} \\quad {C_2} \\\\\nC_{1} \\ {C_2}</script><h2 id=\"5-公式对齐\"><a href=\"#5-公式对齐\" class=\"headerlink\" title=\"5. 公式对齐\"></a>5. 公式对齐</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$$</div><div class=\"line\">\\begin&#123;align&#125;</div><div class=\"line\">\\lim\\limits_&#123;x \\rightarrow a&#125; f(x)</div><div class=\"line\">&amp;= \\frac&#123;f\\left( a \\right)&#125;&#123; 0 !&#125;\\left( x - a \\right) ^ 0 + \\frac&#123;f&apos;\\left( a \\right)&#125;&#123; 1 !&#125;\\left( x - a \\right) ^ 1 + \\frac&#123;f&apos;&apos;\\left( a \\right)&#125;&#123; 2 !&#125;\\left( x - a \\right) ^ 2  + \\cdots + \\frac&#123;f^&#123;(n)&#125;\\left( a \\right)&#125;&#123; n !&#125;\\left( x - a \\right) ^ n \\\\</div><div class=\"line\">&amp;= \\sum\\limits_&#123;n=0&#125;^&#123;\\infty&#125; \\frac&#123;f^&#123;(n)&#125;\\left( a \\right)&#125;&#123; n !&#125;\\left( x - a \\right) ^ n</div><div class=\"line\">\\end&#123;align&#125;</div><div class=\"line\">$$</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}</script><hr>\n<p><br><br><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Latex-常见错误整理\"><a href=\"#Latex-常见错误整理\" class=\"headerlink\" title=\"Latex 常见错误整理\"></a>Latex 常见错误整理</h1><h2 id=\"1-求导\"><a href=\"#1-求导\" class=\"headerlink\" title=\"1. 求导\"></a>1. 求导</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\sideset&#123;^*&#125;&#123;&apos;&#125;\\sum_&#123;1\\le i\\le 100&#125; A(i)</div><div class=\"line\">\\qquad</div><div class=\"line\">\\sum_&#123;1\\le i\\le 100&#125;\\vphantom&#123;\\sum&#125;^&#123;&apos;&#125; A(i)</div><div class=\"line\">\\qquad</div><div class=\"line\">\\mathop&#123;&#123;\\sum&#125;&apos;&#125;_&#123;1\\le i\\le 100&#125; A(i)</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\n\\sideset{^*}{'}\\sum_{1\\le i\\le 100} A(i)\n\\qquad\n\\sum_{1\\le i\\le 100}\\vphantom{\\sum}^{'} A(i)</script><h2 id=\"2-下标\"><a href=\"#2-下标\" class=\"headerlink\" title=\"2. 下标\"></a>2. 下标</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">C_&#123;1&#125; + &#123;C_2&#125; \\\\</div><div class=\"line\">C_&#123;m,n&#125;</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\nC_{1} + {C_2} \\\\\nC_{m,n}</script><h2 id=\"3-前缀\"><a href=\"#3-前缀\" class=\"headerlink\" title=\"3. 前缀\"></a>3. 前缀</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;\\int_&#123;0&#125;^&#123;\\frac&#123;\\pi&#125;&#123;2&#125;&#125;&#125; \\\\</div><div class=\"line\">\\sum_&#123;i=1&#125;^&#123;n&#125;\\\\</div><div class=\"line\">\\prod_\\epsilon</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\n{\\int_{0}^{\\frac{\\pi}{2}}} \\\\\n\\sum_{i=1}^{n}\\\\\n\\prod_\\epsilon</script><h2 id=\"4-占位符\"><a href=\"#4-占位符\" class=\"headerlink\" title=\"4. 占位符\"></a>4. 占位符</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">C_&#123;1&#125; \\qquad &#123;C_2&#125; \\\\</div><div class=\"line\">C_&#123;1&#125; \\quad &#123;C_2&#125; \\\\</div><div class=\"line\">C_&#123;1&#125; \\ &#123;C_2&#125;</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\nC_{1} \\qquad {C_2} \\\\\nC_{1} \\quad {C_2} \\\\\nC_{1} \\ {C_2}</script><h2 id=\"5-公式对齐\"><a href=\"#5-公式对齐\" class=\"headerlink\" title=\"5. 公式对齐\"></a>5. 公式对齐</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$$</div><div class=\"line\">\\begin&#123;align&#125;</div><div class=\"line\">\\lim\\limits_&#123;x \\rightarrow a&#125; f(x)</div><div class=\"line\">&amp;= \\frac&#123;f\\left( a \\right)&#125;&#123; 0 !&#125;\\left( x - a \\right) ^ 0 + \\frac&#123;f&apos;\\left( a \\right)&#125;&#123; 1 !&#125;\\left( x - a \\right) ^ 1 + \\frac&#123;f&apos;&apos;\\left( a \\right)&#125;&#123; 2 !&#125;\\left( x - a \\right) ^ 2  + \\cdots + \\frac&#123;f^&#123;(n)&#125;\\left( a \\right)&#125;&#123; n !&#125;\\left( x - a \\right) ^ n \\\\</div><div class=\"line\">&amp;= \\sum\\limits_&#123;n=0&#125;^&#123;\\infty&#125; \\frac&#123;f^&#123;(n)&#125;\\left( a \\right)&#125;&#123; n !&#125;\\left( x - a \\right) ^ n</div><div class=\"line\">\\end&#123;align&#125;</div><div class=\"line\">$$</div></pre></td></tr></table></figure>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}</script><hr>\n<p><br><br><br></p>\n"},{"title":"Get More Data","date":"2017-11-30T03:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n# Get More Data\n\n## 1. Why We Need More Data?\n\nIn many situations (low bias learning model), more data usually means better performance of the model.\n\n## 2. When We Need More Data?\n\nUsually, we should plot the learning curve by using part of the training data (1/10). If we have low bias curve, then we are safely increase the training data to get better machine learning model.\n\n## 3. How to Get More Data?\n\n- Artificial data synthesis (e.g., rotation, crop, change background, etc)\n- Collect and label the data manually\n- Hire other company to label (e.g., Amazon Mechanical Turk)\n\nUsually to make the original data 10 times larger won't take so much effort, but it will make the performance of the model much better.\n","source":"_posts/ML System Tips/2017-11-30-Get More Data.md","raw":"---\ntitle: Get More Data\ndate: 2017-11-30 11:23:19\ncategories: [Machine-Learning-System-Tips]\ntags: [Machine-Learning-System-Tips]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n# Get More Data\n\n## 1. Why We Need More Data?\n\nIn many situations (low bias learning model), more data usually means better performance of the model.\n\n## 2. When We Need More Data?\n\nUsually, we should plot the learning curve by using part of the training data (1/10). If we have low bias curve, then we are safely increase the training data to get better machine learning model.\n\n## 3. How to Get More Data?\n\n- Artificial data synthesis (e.g., rotation, crop, change background, etc)\n- Collect and label the data manually\n- Hire other company to label (e.g., Amazon Mechanical Turk)\n\nUsually to make the original data 10 times larger won't take so much effort, but it will make the performance of the model much better.\n","slug":"ML System Tips/2017-11-30-Get More Data","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0az000de0owzjxcnxqb","content":"<h1 id=\"Get-More-Data\"><a href=\"#Get-More-Data\" class=\"headerlink\" title=\"Get More Data\"></a>Get More Data</h1><h2 id=\"1-Why-We-Need-More-Data\"><a href=\"#1-Why-We-Need-More-Data\" class=\"headerlink\" title=\"1. Why We Need More Data?\"></a>1. Why We Need More Data?</h2><p>In many situations (low bias learning model), more data usually means better performance of the model.</p>\n<h2 id=\"2-When-We-Need-More-Data\"><a href=\"#2-When-We-Need-More-Data\" class=\"headerlink\" title=\"2. When We Need More Data?\"></a>2. When We Need More Data?</h2><p>Usually, we should plot the learning curve by using part of the training data (1/10). If we have low bias curve, then we are safely increase the training data to get better machine learning model.</p>\n<h2 id=\"3-How-to-Get-More-Data\"><a href=\"#3-How-to-Get-More-Data\" class=\"headerlink\" title=\"3. How to Get More Data?\"></a>3. How to Get More Data?</h2><ul>\n<li>Artificial data synthesis (e.g., rotation, crop, change background, etc)</li>\n<li>Collect and label the data manually</li>\n<li>Hire other company to label (e.g., Amazon Mechanical Turk)</li>\n</ul>\n<p>Usually to make the original data 10 times larger won’t take so much effort, but it will make the performance of the model much better.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Get-More-Data\"><a href=\"#Get-More-Data\" class=\"headerlink\" title=\"Get More Data\"></a>Get More Data</h1><h2 id=\"1-Why-We-Need-More-Data\"><a href=\"#1-Why-We-Need-More-Data\" class=\"headerlink\" title=\"1. Why We Need More Data?\"></a>1. Why We Need More Data?</h2><p>In many situations (low bias learning model), more data usually means better performance of the model.</p>\n<h2 id=\"2-When-We-Need-More-Data\"><a href=\"#2-When-We-Need-More-Data\" class=\"headerlink\" title=\"2. When We Need More Data?\"></a>2. When We Need More Data?</h2><p>Usually, we should plot the learning curve by using part of the training data (1/10). If we have low bias curve, then we are safely increase the training data to get better machine learning model.</p>\n<h2 id=\"3-How-to-Get-More-Data\"><a href=\"#3-How-to-Get-More-Data\" class=\"headerlink\" title=\"3. How to Get More Data?\"></a>3. How to Get More Data?</h2><ul>\n<li>Artificial data synthesis (e.g., rotation, crop, change background, etc)</li>\n<li>Collect and label the data manually</li>\n<li>Hire other company to label (e.g., Amazon Mechanical Turk)</li>\n</ul>\n<p>Usually to make the original data 10 times larger won’t take so much effort, but it will make the performance of the model much better.</p>\n"},{"title":"tanh Function","date":"2017-10-29T03:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# tanh Function\n\n\n## 1. Introduction\n> To limit all data within the range of -1 to 1. Comparing to Sigmoid Function which output range is [0,1]\n\n## 2. Formula\nThe formula and derivative of tanh is:\n$$\n\\begin{align}\nf(z)  &= tanh(z) = \\frac{e^z - e^{-z}}{e^z+e^{-z}} \\\\\nf'(z) &= 1 - (f(z))^2\n\\end{align}\n$$\nwhere as the sigmoid function is pretty close\n$$\n\\begin{align}\nf(z)  &= sigmoid(z) = \\frac{1}{1+e^{-z}} \\\\\nf'(z) &= 1 - f(z)\n\\end{align}\n$$\n\nSee the figure of tanh and sigmoid below.\n![tanh](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png)\n<center>tanh Function</center>\n\n\n![sigmoid](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2f13c175c89fc02793cef19d6cb2223d548479d3/__Blog/__Personal%20Understanding/Mathematics/images/sigmoid.png)\n<center>sigmoid Function</center>\n\n\n\n\n## 3. Implementation\n### 3.1 Octave\n```\n x = linspace(-10, 10 ,10000);\n y = zeros( size(x, 1), size(x, 2));\n\n for i = 1:length(x)\n   y(i) = 1/(1+e^(-x(i)));\n endfor\n\n figure();\n plot( x,y);\n grid on;\n xlabel(\"x\");\n ylabel(\"y=1/(1+e^-x)\");\n title(\"Sigmoid Function\");\n```\n\nOutput figure\n![tanh](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png)\n<center>tanh Function</center>\n\n\n\n# Relative\n[Sigmoid Function](https://zhichengmle.github.io/2017/10/30/Mathematics/2017-10-30-Sigmoid%20Function/)\n\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/2017-10-29-tanh Function.md","raw":"---\ntitle: tanh Function\ndate: 2017-10-29 11:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# tanh Function\n\n\n## 1. Introduction\n> To limit all data within the range of -1 to 1. Comparing to Sigmoid Function which output range is [0,1]\n\n## 2. Formula\nThe formula and derivative of tanh is:\n$$\n\\begin{align}\nf(z)  &= tanh(z) = \\frac{e^z - e^{-z}}{e^z+e^{-z}} \\\\\nf'(z) &= 1 - (f(z))^2\n\\end{align}\n$$\nwhere as the sigmoid function is pretty close\n$$\n\\begin{align}\nf(z)  &= sigmoid(z) = \\frac{1}{1+e^{-z}} \\\\\nf'(z) &= 1 - f(z)\n\\end{align}\n$$\n\nSee the figure of tanh and sigmoid below.\n![tanh](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png)\n<center>tanh Function</center>\n\n\n![sigmoid](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2f13c175c89fc02793cef19d6cb2223d548479d3/__Blog/__Personal%20Understanding/Mathematics/images/sigmoid.png)\n<center>sigmoid Function</center>\n\n\n\n\n## 3. Implementation\n### 3.1 Octave\n```\n x = linspace(-10, 10 ,10000);\n y = zeros( size(x, 1), size(x, 2));\n\n for i = 1:length(x)\n   y(i) = 1/(1+e^(-x(i)));\n endfor\n\n figure();\n plot( x,y);\n grid on;\n xlabel(\"x\");\n ylabel(\"y=1/(1+e^-x)\");\n title(\"Sigmoid Function\");\n```\n\nOutput figure\n![tanh](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png)\n<center>tanh Function</center>\n\n\n\n# Relative\n[Sigmoid Function](https://zhichengmle.github.io/2017/10/30/Mathematics/2017-10-30-Sigmoid%20Function/)\n\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/2017-10-29-tanh Function","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0b7000ee0owdqzebmjx","content":"<h1 id=\"tanh-Function\"><a href=\"#tanh-Function\" class=\"headerlink\" title=\"tanh Function\"></a>tanh Function</h1><h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h2><blockquote>\n<p>To limit all data within the range of -1 to 1. Comparing to Sigmoid Function which output range is [0,1]</p>\n</blockquote>\n<h2 id=\"2-Formula\"><a href=\"#2-Formula\" class=\"headerlink\" title=\"2. Formula\"></a>2. Formula</h2><p>The formula and derivative of tanh is:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf(z)  &= tanh(z) = \\frac{e^z - e^{-z}}{e^z+e^{-z}} \\\\\nf'(z) &= 1 - (f(z))^2\n\\end{align}</script><p>where as the sigmoid function is pretty close</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf(z)  &= sigmoid(z) = \\frac{1}{1+e^{-z}} \\\\\nf'(z) &= 1 - f(z)\n\\end{align}</script><p>See the figure of tanh and sigmoid below.<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png\" alt=\"tanh\"></p>\n<center>tanh Function</center>\n\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2f13c175c89fc02793cef19d6cb2223d548479d3/__Blog/__Personal%20Understanding/Mathematics/images/sigmoid.png\" alt=\"sigmoid\"></p>\n<center>sigmoid Function</center>\n\n\n\n\n<h2 id=\"3-Implementation\"><a href=\"#3-Implementation\" class=\"headerlink\" title=\"3. Implementation\"></a>3. Implementation</h2><h3 id=\"3-1-Octave\"><a href=\"#3-1-Octave\" class=\"headerlink\" title=\"3.1 Octave\"></a>3.1 Octave</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = linspace(-10, 10 ,10000);</div><div class=\"line\">y = zeros( size(x, 1), size(x, 2));</div><div class=\"line\"></div><div class=\"line\">for i = 1:length(x)</div><div class=\"line\">  y(i) = 1/(1+e^(-x(i)));</div><div class=\"line\">endfor</div><div class=\"line\"></div><div class=\"line\">figure();</div><div class=\"line\">plot( x,y);</div><div class=\"line\">grid on;</div><div class=\"line\">xlabel(&quot;x&quot;);</div><div class=\"line\">ylabel(&quot;y=1/(1+e^-x)&quot;);</div><div class=\"line\">title(&quot;Sigmoid Function&quot;);</div></pre></td></tr></table></figure>\n<p>Output figure<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png\" alt=\"tanh\"></p>\n<center>tanh Function</center>\n\n\n\n<h1 id=\"Relative\"><a href=\"#Relative\" class=\"headerlink\" title=\"Relative\"></a>Relative</h1><p><a href=\"https://zhichengmle.github.io/2017/10/30/Mathematics/2017-10-30-Sigmoid%20Function/\">Sigmoid Function</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"tanh-Function\"><a href=\"#tanh-Function\" class=\"headerlink\" title=\"tanh Function\"></a>tanh Function</h1><h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h2><blockquote>\n<p>To limit all data within the range of -1 to 1. Comparing to Sigmoid Function which output range is [0,1]</p>\n</blockquote>\n<h2 id=\"2-Formula\"><a href=\"#2-Formula\" class=\"headerlink\" title=\"2. Formula\"></a>2. Formula</h2><p>The formula and derivative of tanh is:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf(z)  &= tanh(z) = \\frac{e^z - e^{-z}}{e^z+e^{-z}} \\\\\nf'(z) &= 1 - (f(z))^2\n\\end{align}</script><p>where as the sigmoid function is pretty close</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf(z)  &= sigmoid(z) = \\frac{1}{1+e^{-z}} \\\\\nf'(z) &= 1 - f(z)\n\\end{align}</script><p>See the figure of tanh and sigmoid below.<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png\" alt=\"tanh\"></p>\n<center>tanh Function</center>\n\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2f13c175c89fc02793cef19d6cb2223d548479d3/__Blog/__Personal%20Understanding/Mathematics/images/sigmoid.png\" alt=\"sigmoid\"></p>\n<center>sigmoid Function</center>\n\n\n\n\n<h2 id=\"3-Implementation\"><a href=\"#3-Implementation\" class=\"headerlink\" title=\"3. Implementation\"></a>3. Implementation</h2><h3 id=\"3-1-Octave\"><a href=\"#3-1-Octave\" class=\"headerlink\" title=\"3.1 Octave\"></a>3.1 Octave</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = linspace(-10, 10 ,10000);</div><div class=\"line\">y = zeros( size(x, 1), size(x, 2));</div><div class=\"line\"></div><div class=\"line\">for i = 1:length(x)</div><div class=\"line\">  y(i) = 1/(1+e^(-x(i)));</div><div class=\"line\">endfor</div><div class=\"line\"></div><div class=\"line\">figure();</div><div class=\"line\">plot( x,y);</div><div class=\"line\">grid on;</div><div class=\"line\">xlabel(&quot;x&quot;);</div><div class=\"line\">ylabel(&quot;y=1/(1+e^-x)&quot;);</div><div class=\"line\">title(&quot;Sigmoid Function&quot;);</div></pre></td></tr></table></figure>\n<p>Output figure<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c0f683d49f1d3f2d5383d25566d4f490c552645d/__Blog/__Personal%20Understanding/Mathematics/images/tanh.png\" alt=\"tanh\"></p>\n<center>tanh Function</center>\n\n\n\n<h1 id=\"Relative\"><a href=\"#Relative\" class=\"headerlink\" title=\"Relative\"></a>Relative</h1><p><a href=\"https://zhichengmle.github.io/2017/10/30/Mathematics/2017-10-30-Sigmoid%20Function/\">Sigmoid Function</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Matrix and Vector Transformation","date":"2017-10-28T05:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n\n\n## 1. When to Transform?\n在一些神经网络的一些优化算法中，要求传入的是向量来进行优化。但是权值却是矩阵，所以需要进行转换，在处理之后再转回来。\n所以我们需要学习如何进行Matrix 和 Vector 的转换\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## 2. How to Transform?\n### 1) Octave Implement\n> 在Octave 中我们需要用的 \"[]\" 把矩阵转成向量；再通过 Reshape 函数把向量转换回数组\n\n1.分别使用 ones()函数产生2个等大的矩阵，作为输入层，隐藏层。\n```\ntheta1 = ones(3,4)\n\n> Output:\ntheta1 =\n\n  1   1   1   1\n  1   1   1   1\n  1   1   1   1\n\n\n\ntheta2 = 3*ones(3,4)\n\n> Output:\ntheta2 =\n  3   3   3   3\n  3   3   3   3\n  3   3   3   3\n```\n2. 同样使用ones()函数，产生输出层的theta\n\n```\ntheta3 = 4*ones(1,4)\n\n> Output:\ntheta3 =\n  4   4   4   4\n```\n\n3.通过 \"[]\" 来合成矩阵，注意括号里面要加上 : 符号代码把当前矩阵变成向量输出-->就可以得到我们需要的向量了\n\n```\nthetaVec = [theta1(:); theta2(:); theta3(:)]\n\n> Output:\nthetaVec =\n\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  4\n  4\n  4\n  4\n```\n\n4.再通过Reshape函数把向量转换回矩阵：要注意向量的index。\n\n```\nnewTheta1 = reshape(thetaVec(1:12),3,4)\n\n> Output:\nnewTheta1 =\n  1   1   1   1\n  1   1   1   1\n  1   1   1   1\n\n\n\n\nnewTheta2 = reshape(thetaVec(13:24),3,4)\n\n> Output:\nnewTheta2 =\n\n  3   3   3   3\n  3   3   3   3\n  3   3   3   3\n\n\n\nnewTheta3 = reshape(thetaVec(25:28),1,4)\n\n> Output:\nnewTheta3 =\n  4   4   4   4\n```\n\n\n\n### 2) Python Implement\n> @TODO\n\n<br>\n<br>\n------------------------------------------\n\n","source":"_posts/Mathematics/2017-10-28-MatrixToVector.md","raw":"---\ntitle: Matrix and Vector Transformation\ndate: 2017-10-28 13:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n\n\n## 1. When to Transform?\n在一些神经网络的一些优化算法中，要求传入的是向量来进行优化。但是权值却是矩阵，所以需要进行转换，在处理之后再转回来。\n所以我们需要学习如何进行Matrix 和 Vector 的转换\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## 2. How to Transform?\n### 1) Octave Implement\n> 在Octave 中我们需要用的 \"[]\" 把矩阵转成向量；再通过 Reshape 函数把向量转换回数组\n\n1.分别使用 ones()函数产生2个等大的矩阵，作为输入层，隐藏层。\n```\ntheta1 = ones(3,4)\n\n> Output:\ntheta1 =\n\n  1   1   1   1\n  1   1   1   1\n  1   1   1   1\n\n\n\ntheta2 = 3*ones(3,4)\n\n> Output:\ntheta2 =\n  3   3   3   3\n  3   3   3   3\n  3   3   3   3\n```\n2. 同样使用ones()函数，产生输出层的theta\n\n```\ntheta3 = 4*ones(1,4)\n\n> Output:\ntheta3 =\n  4   4   4   4\n```\n\n3.通过 \"[]\" 来合成矩阵，注意括号里面要加上 : 符号代码把当前矩阵变成向量输出-->就可以得到我们需要的向量了\n\n```\nthetaVec = [theta1(:); theta2(:); theta3(:)]\n\n> Output:\nthetaVec =\n\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  1\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  3\n  4\n  4\n  4\n  4\n```\n\n4.再通过Reshape函数把向量转换回矩阵：要注意向量的index。\n\n```\nnewTheta1 = reshape(thetaVec(1:12),3,4)\n\n> Output:\nnewTheta1 =\n  1   1   1   1\n  1   1   1   1\n  1   1   1   1\n\n\n\n\nnewTheta2 = reshape(thetaVec(13:24),3,4)\n\n> Output:\nnewTheta2 =\n\n  3   3   3   3\n  3   3   3   3\n  3   3   3   3\n\n\n\nnewTheta3 = reshape(thetaVec(25:28),1,4)\n\n> Output:\nnewTheta3 =\n  4   4   4   4\n```\n\n\n\n### 2) Python Implement\n> @TODO\n\n<br>\n<br>\n------------------------------------------\n\n","slug":"Mathematics/2017-10-28-MatrixToVector","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0b8000fe0owi3y1b9w9","content":"<h2 id=\"1-When-to-Transform\"><a href=\"#1-When-to-Transform\" class=\"headerlink\" title=\"1. When to Transform?\"></a>1. When to Transform?</h2><p>在一些神经网络的一些优化算法中，要求传入的是向量来进行优化。但是权值却是矩阵，所以需要进行转换，在处理之后再转回来。<br>所以我们需要学习如何进行Matrix 和 Vector 的转换</p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-How-to-Transform\"><a href=\"#2-How-to-Transform\" class=\"headerlink\" title=\"2. How to Transform?\"></a>2. How to Transform?</h2><h3 id=\"1-Octave-Implement\"><a href=\"#1-Octave-Implement\" class=\"headerlink\" title=\"1) Octave Implement\"></a>1) Octave Implement</h3><blockquote>\n<p>在Octave 中我们需要用的 “[]” 把矩阵转成向量；再通过 Reshape 函数把向量转换回数组</p>\n</blockquote>\n<p>1.分别使用 ones()函数产生2个等大的矩阵，作为输入层，隐藏层。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">theta1 = ones(3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">theta1 =</div><div class=\"line\"></div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">theta2 = 3*ones(3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">theta2 =</div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div></pre></td></tr></table></figure></p>\n<ol>\n<li>同样使用ones()函数，产生输出层的theta</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">theta3 = 4*ones(1,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">theta3 =</div><div class=\"line\">  4   4   4   4</div></pre></td></tr></table></figure>\n<p>3.通过 “[]” 来合成矩阵，注意括号里面要加上 : 符号代码把当前矩阵变成向量输出—&gt;就可以得到我们需要的向量了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">thetaVec = [theta1(:); theta2(:); theta3(:)]</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">thetaVec =</div><div class=\"line\"></div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  4</div><div class=\"line\">  4</div><div class=\"line\">  4</div><div class=\"line\">  4</div></pre></td></tr></table></figure>\n<p>4.再通过Reshape函数把向量转换回矩阵：要注意向量的index。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">newTheta1 = reshape(thetaVec(1:12),3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">newTheta1 =</div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">newTheta2 = reshape(thetaVec(13:24),3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">newTheta2 =</div><div class=\"line\"></div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">newTheta3 = reshape(thetaVec(25:28),1,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">newTheta3 =</div><div class=\"line\">  4   4   4   4</div></pre></td></tr></table></figure>\n<h3 id=\"2-Python-Implement\"><a href=\"#2-Python-Implement\" class=\"headerlink\" title=\"2) Python Implement\"></a>2) Python Implement</h3><blockquote>\n<p>@TODO</p>\n</blockquote>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-When-to-Transform\"><a href=\"#1-When-to-Transform\" class=\"headerlink\" title=\"1. When to Transform?\"></a>1. When to Transform?</h2><p>在一些神经网络的一些优化算法中，要求传入的是向量来进行优化。但是权值却是矩阵，所以需要进行转换，在处理之后再转回来。<br>所以我们需要学习如何进行Matrix 和 Vector 的转换</p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-How-to-Transform\"><a href=\"#2-How-to-Transform\" class=\"headerlink\" title=\"2. How to Transform?\"></a>2. How to Transform?</h2><h3 id=\"1-Octave-Implement\"><a href=\"#1-Octave-Implement\" class=\"headerlink\" title=\"1) Octave Implement\"></a>1) Octave Implement</h3><blockquote>\n<p>在Octave 中我们需要用的 “[]” 把矩阵转成向量；再通过 Reshape 函数把向量转换回数组</p>\n</blockquote>\n<p>1.分别使用 ones()函数产生2个等大的矩阵，作为输入层，隐藏层。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">theta1 = ones(3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">theta1 =</div><div class=\"line\"></div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">theta2 = 3*ones(3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">theta2 =</div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div></pre></td></tr></table></figure></p>\n<ol>\n<li>同样使用ones()函数，产生输出层的theta</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">theta3 = 4*ones(1,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">theta3 =</div><div class=\"line\">  4   4   4   4</div></pre></td></tr></table></figure>\n<p>3.通过 “[]” 来合成矩阵，注意括号里面要加上 : 符号代码把当前矩阵变成向量输出—&gt;就可以得到我们需要的向量了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">thetaVec = [theta1(:); theta2(:); theta3(:)]</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">thetaVec =</div><div class=\"line\"></div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  1</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  3</div><div class=\"line\">  4</div><div class=\"line\">  4</div><div class=\"line\">  4</div><div class=\"line\">  4</div></pre></td></tr></table></figure>\n<p>4.再通过Reshape函数把向量转换回矩阵：要注意向量的index。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">newTheta1 = reshape(thetaVec(1:12),3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">newTheta1 =</div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\">  1   1   1   1</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">newTheta2 = reshape(thetaVec(13:24),3,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">newTheta2 =</div><div class=\"line\"></div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div><div class=\"line\">  3   3   3   3</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">newTheta3 = reshape(thetaVec(25:28),1,4)</div><div class=\"line\"></div><div class=\"line\">&gt; Output:</div><div class=\"line\">newTheta3 =</div><div class=\"line\">  4   4   4   4</div></pre></td></tr></table></figure>\n<h3 id=\"2-Python-Implement\"><a href=\"#2-Python-Implement\" class=\"headerlink\" title=\"2) Python Implement\"></a>2) Python Implement</h3><blockquote>\n<p>@TODO</p>\n</blockquote>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"数据预处理-数据归一化和数据规范化","date":"2017-10-29T07:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# 1. 数据归一化\n### 1.1. 作用\n- 把数据映射到[0,1]的区间中\n- 把有量纲形式变成无量纲形式\n<br>\n<br>\n### 1.2. 算法\n\n#### 1.2.1. 最小-最大归一化\n$Y = \\frac{X - Xmin}{Xmax - Xmin}$\n> 把X的值映射到[0, 1] 的区域中，因为必有X &lt; Xmax，所以分子(X - Xmin) &lt; 分母(Xmax - Xmin)，所以Y在[0,1]之间\n\n<br>\n<br>\n#### 1.2.2. 对数函数归一化\n$Y = log10( X )$\n<br>\n<br>\n\n#### 1.2.3. 反余切函数归一化\n$Y = arctan(x- \\frac{2}{\\pi})$\n\n-----------------------------------\n\n<br>\n<br>\n<br>\n\n# 2. 数据规范化\n### 1.1. 作用\n> 使数据按照一定的比例进行缩放，通过缩放，使得数据映射到特定的空间里面。\n\n### 1.2. 算法\n\n#### 1.2.1. 最小-最大规范化\n$Y = \\frac{X-Xmin}{Xmax - Xmin} - (Xnewmax - Xnewmin) + Xnewmin$\n> 把X的值映射到[Xnewmin, Xnewmax] 的区域中。\n\n <br>\n<br>\n#### 1.2.2. Z分数(z-score)规范化（零均值规范化）\n${Y}=\\frac{X-\\mu }{\\sigma }$\n> 这种方法最大的优势在于，不需要知道数据集的最大值，最小值。离群点对结果影响较低。\n\n<br>\n<br>\n\n#### 1.2.3. Sigmoid函数\n${Y}=\\frac{1}{1+{e}^{-x}}$\n> Sigmoid函数是一个具有S形曲线的函数，当数据趋向于正无穷和负无穷的时候，映射出来的值就会无限趋向于1和0，\n\n<br>\n<br>\n\n#### 1.2.4. 小数定标规范化\n$Y = \\frac{X}{10^n} (n 为使得Ymax < 1 的最小整数)$\n> 通过移动小数点的位置，进行规范化\n\n<br>\n<br>\n\n#### 1.2.5. 模糊量化规范化\n$Y = \\frac{1}{2} + \\frac{1}{2} - sin[\\frac{\\pi}{Xmax - Xmin}-(X - \\frac{Xmax - Xmin}{2})]$\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/2017-10-29-数据预处理-数据归一化和数据规范化.md","raw":"---\ntitle: 数据预处理-数据归一化和数据规范化\ndate: 2017-10-29 15:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# 1. 数据归一化\n### 1.1. 作用\n- 把数据映射到[0,1]的区间中\n- 把有量纲形式变成无量纲形式\n<br>\n<br>\n### 1.2. 算法\n\n#### 1.2.1. 最小-最大归一化\n$Y = \\frac{X - Xmin}{Xmax - Xmin}$\n> 把X的值映射到[0, 1] 的区域中，因为必有X &lt; Xmax，所以分子(X - Xmin) &lt; 分母(Xmax - Xmin)，所以Y在[0,1]之间\n\n<br>\n<br>\n#### 1.2.2. 对数函数归一化\n$Y = log10( X )$\n<br>\n<br>\n\n#### 1.2.3. 反余切函数归一化\n$Y = arctan(x- \\frac{2}{\\pi})$\n\n-----------------------------------\n\n<br>\n<br>\n<br>\n\n# 2. 数据规范化\n### 1.1. 作用\n> 使数据按照一定的比例进行缩放，通过缩放，使得数据映射到特定的空间里面。\n\n### 1.2. 算法\n\n#### 1.2.1. 最小-最大规范化\n$Y = \\frac{X-Xmin}{Xmax - Xmin} - (Xnewmax - Xnewmin) + Xnewmin$\n> 把X的值映射到[Xnewmin, Xnewmax] 的区域中。\n\n <br>\n<br>\n#### 1.2.2. Z分数(z-score)规范化（零均值规范化）\n${Y}=\\frac{X-\\mu }{\\sigma }$\n> 这种方法最大的优势在于，不需要知道数据集的最大值，最小值。离群点对结果影响较低。\n\n<br>\n<br>\n\n#### 1.2.3. Sigmoid函数\n${Y}=\\frac{1}{1+{e}^{-x}}$\n> Sigmoid函数是一个具有S形曲线的函数，当数据趋向于正无穷和负无穷的时候，映射出来的值就会无限趋向于1和0，\n\n<br>\n<br>\n\n#### 1.2.4. 小数定标规范化\n$Y = \\frac{X}{10^n} (n 为使得Ymax < 1 的最小整数)$\n> 通过移动小数点的位置，进行规范化\n\n<br>\n<br>\n\n#### 1.2.5. 模糊量化规范化\n$Y = \\frac{1}{2} + \\frac{1}{2} - sin[\\frac{\\pi}{Xmax - Xmin}-(X - \\frac{Xmax - Xmin}{2})]$\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/2017-10-29-数据预处理-数据归一化和数据规范化","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0b9000je0owmdx6bmjs","content":"<h1 id=\"1-数据归一化\"><a href=\"#1-数据归一化\" class=\"headerlink\" title=\"1. 数据归一化\"></a>1. 数据归一化</h1><h3 id=\"1-1-作用\"><a href=\"#1-1-作用\" class=\"headerlink\" title=\"1.1. 作用\"></a>1.1. 作用</h3><ul>\n<li>把数据映射到[0,1]的区间中</li>\n<li>把有量纲形式变成无量纲形式<br><br><br><br><h3 id=\"1-2-算法\"><a href=\"#1-2-算法\" class=\"headerlink\" title=\"1.2. 算法\"></a>1.2. 算法</h3></li>\n</ul>\n<h4 id=\"1-2-1-最小-最大归一化\"><a href=\"#1-2-1-最小-最大归一化\" class=\"headerlink\" title=\"1.2.1. 最小-最大归一化\"></a>1.2.1. 最小-最大归一化</h4><p>$Y = \\frac{X - Xmin}{Xmax - Xmin}$</p>\n<blockquote>\n<p>把X的值映射到[0, 1] 的区域中，因为必有X &lt; Xmax，所以分子(X - Xmin) &lt; 分母(Xmax - Xmin)，所以Y在[0,1]之间</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-2-对数函数归一化\"><a href=\"#1-2-2-对数函数归一化\" class=\"headerlink\" title=\"1.2.2. 对数函数归一化\"></a>1.2.2. 对数函数归一化</h4><p>$Y = log10( X )$<br><br><br><br></p>\n<h4 id=\"1-2-3-反余切函数归一化\"><a href=\"#1-2-3-反余切函数归一化\" class=\"headerlink\" title=\"1.2.3. 反余切函数归一化\"></a>1.2.3. 反余切函数归一化</h4><p>$Y = arctan(x- \\frac{2}{\\pi})$</p>\n<hr>\n<p><br><br><br><br><br></p>\n<h1 id=\"2-数据规范化\"><a href=\"#2-数据规范化\" class=\"headerlink\" title=\"2. 数据规范化\"></a>2. 数据规范化</h1><h3 id=\"1-1-作用-1\"><a href=\"#1-1-作用-1\" class=\"headerlink\" title=\"1.1. 作用\"></a>1.1. 作用</h3><blockquote>\n<p>使数据按照一定的比例进行缩放，通过缩放，使得数据映射到特定的空间里面。</p>\n</blockquote>\n<h3 id=\"1-2-算法-1\"><a href=\"#1-2-算法-1\" class=\"headerlink\" title=\"1.2. 算法\"></a>1.2. 算法</h3><h4 id=\"1-2-1-最小-最大规范化\"><a href=\"#1-2-1-最小-最大规范化\" class=\"headerlink\" title=\"1.2.1. 最小-最大规范化\"></a>1.2.1. 最小-最大规范化</h4><p>$Y = \\frac{X-Xmin}{Xmax - Xmin} - (Xnewmax - Xnewmin) + Xnewmin$</p>\n<blockquote>\n<p>把X的值映射到[Xnewmin, Xnewmax] 的区域中。</p>\n</blockquote>\n<p> <br><br><br></p>\n<h4 id=\"1-2-2-Z分数-z-score-规范化（零均值规范化）\"><a href=\"#1-2-2-Z分数-z-score-规范化（零均值规范化）\" class=\"headerlink\" title=\"1.2.2. Z分数(z-score)规范化（零均值规范化）\"></a>1.2.2. Z分数(z-score)规范化（零均值规范化）</h4><p>${Y}=\\frac{X-\\mu }{\\sigma }$</p>\n<blockquote>\n<p>这种方法最大的优势在于，不需要知道数据集的最大值，最小值。离群点对结果影响较低。</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-3-Sigmoid函数\"><a href=\"#1-2-3-Sigmoid函数\" class=\"headerlink\" title=\"1.2.3. Sigmoid函数\"></a>1.2.3. Sigmoid函数</h4><p>${Y}=\\frac{1}{1+{e}^{-x}}$</p>\n<blockquote>\n<p>Sigmoid函数是一个具有S形曲线的函数，当数据趋向于正无穷和负无穷的时候，映射出来的值就会无限趋向于1和0，</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-4-小数定标规范化\"><a href=\"#1-2-4-小数定标规范化\" class=\"headerlink\" title=\"1.2.4. 小数定标规范化\"></a>1.2.4. 小数定标规范化</h4><p>$Y = \\frac{X}{10^n} (n 为使得Ymax &lt; 1 的最小整数)$</p>\n<blockquote>\n<p>通过移动小数点的位置，进行规范化</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-5-模糊量化规范化\"><a href=\"#1-2-5-模糊量化规范化\" class=\"headerlink\" title=\"1.2.5. 模糊量化规范化\"></a>1.2.5. 模糊量化规范化</h4><p>$Y = \\frac{1}{2} + \\frac{1}{2} - sin[\\frac{\\pi}{Xmax - Xmin}-(X - \\frac{Xmax - Xmin}{2})]$</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-数据归一化\"><a href=\"#1-数据归一化\" class=\"headerlink\" title=\"1. 数据归一化\"></a>1. 数据归一化</h1><h3 id=\"1-1-作用\"><a href=\"#1-1-作用\" class=\"headerlink\" title=\"1.1. 作用\"></a>1.1. 作用</h3><ul>\n<li>把数据映射到[0,1]的区间中</li>\n<li>把有量纲形式变成无量纲形式<br><br><br><br><h3 id=\"1-2-算法\"><a href=\"#1-2-算法\" class=\"headerlink\" title=\"1.2. 算法\"></a>1.2. 算法</h3></li>\n</ul>\n<h4 id=\"1-2-1-最小-最大归一化\"><a href=\"#1-2-1-最小-最大归一化\" class=\"headerlink\" title=\"1.2.1. 最小-最大归一化\"></a>1.2.1. 最小-最大归一化</h4><p>$Y = \\frac{X - Xmin}{Xmax - Xmin}$</p>\n<blockquote>\n<p>把X的值映射到[0, 1] 的区域中，因为必有X &lt; Xmax，所以分子(X - Xmin) &lt; 分母(Xmax - Xmin)，所以Y在[0,1]之间</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-2-对数函数归一化\"><a href=\"#1-2-2-对数函数归一化\" class=\"headerlink\" title=\"1.2.2. 对数函数归一化\"></a>1.2.2. 对数函数归一化</h4><p>$Y = log10( X )$<br><br><br><br></p>\n<h4 id=\"1-2-3-反余切函数归一化\"><a href=\"#1-2-3-反余切函数归一化\" class=\"headerlink\" title=\"1.2.3. 反余切函数归一化\"></a>1.2.3. 反余切函数归一化</h4><p>$Y = arctan(x- \\frac{2}{\\pi})$</p>\n<hr>\n<p><br><br><br><br><br></p>\n<h1 id=\"2-数据规范化\"><a href=\"#2-数据规范化\" class=\"headerlink\" title=\"2. 数据规范化\"></a>2. 数据规范化</h1><h3 id=\"1-1-作用-1\"><a href=\"#1-1-作用-1\" class=\"headerlink\" title=\"1.1. 作用\"></a>1.1. 作用</h3><blockquote>\n<p>使数据按照一定的比例进行缩放，通过缩放，使得数据映射到特定的空间里面。</p>\n</blockquote>\n<h3 id=\"1-2-算法-1\"><a href=\"#1-2-算法-1\" class=\"headerlink\" title=\"1.2. 算法\"></a>1.2. 算法</h3><h4 id=\"1-2-1-最小-最大规范化\"><a href=\"#1-2-1-最小-最大规范化\" class=\"headerlink\" title=\"1.2.1. 最小-最大规范化\"></a>1.2.1. 最小-最大规范化</h4><p>$Y = \\frac{X-Xmin}{Xmax - Xmin} - (Xnewmax - Xnewmin) + Xnewmin$</p>\n<blockquote>\n<p>把X的值映射到[Xnewmin, Xnewmax] 的区域中。</p>\n</blockquote>\n<p> <br><br><br></p>\n<h4 id=\"1-2-2-Z分数-z-score-规范化（零均值规范化）\"><a href=\"#1-2-2-Z分数-z-score-规范化（零均值规范化）\" class=\"headerlink\" title=\"1.2.2. Z分数(z-score)规范化（零均值规范化）\"></a>1.2.2. Z分数(z-score)规范化（零均值规范化）</h4><p>${Y}=\\frac{X-\\mu }{\\sigma }$</p>\n<blockquote>\n<p>这种方法最大的优势在于，不需要知道数据集的最大值，最小值。离群点对结果影响较低。</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-3-Sigmoid函数\"><a href=\"#1-2-3-Sigmoid函数\" class=\"headerlink\" title=\"1.2.3. Sigmoid函数\"></a>1.2.3. Sigmoid函数</h4><p>${Y}=\\frac{1}{1+{e}^{-x}}$</p>\n<blockquote>\n<p>Sigmoid函数是一个具有S形曲线的函数，当数据趋向于正无穷和负无穷的时候，映射出来的值就会无限趋向于1和0，</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-4-小数定标规范化\"><a href=\"#1-2-4-小数定标规范化\" class=\"headerlink\" title=\"1.2.4. 小数定标规范化\"></a>1.2.4. 小数定标规范化</h4><p>$Y = \\frac{X}{10^n} (n 为使得Ymax &lt; 1 的最小整数)$</p>\n<blockquote>\n<p>通过移动小数点的位置，进行规范化</p>\n</blockquote>\n<p><br><br><br></p>\n<h4 id=\"1-2-5-模糊量化规范化\"><a href=\"#1-2-5-模糊量化规范化\" class=\"headerlink\" title=\"1.2.5. 模糊量化规范化\"></a>1.2.5. 模糊量化规范化</h4><p>$Y = \\frac{1}{2} + \\frac{1}{2} - sin[\\frac{\\pi}{Xmax - Xmin}-(X - \\frac{Xmax - Xmin}{2})]$</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Sigmoid Function","date":"2017-10-30T07:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Sigmoid Function\n\n\n## 1. Introduction\n> To limit all data within the range of 0 to 1.\n\n## 2. Formula\n$$\ny = \\frac{1}{1+e^{-x}}\n$$\n\n## 3. Implementation\n### 3.1 Octave\n```\n x = linspace(-10, 10 ,10000);\n y = zeros( size(x, 1), size(x, 2));\n\n for i = 1:length(x)\n   y(i) = 1/(1+e^(-x(i)));\n endfor\n\n figure();\n plot( x,y);\n grid on;\n xlabel(\"x\");\n ylabel(\"y=1/(1+e^-x)\");\n title(\"Sigmoid Function\");\n```\n\nOutput figure\n![Sigmoid Function](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/fd188539ca35c6e4d8859d07bbde8f5439760bae/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/2.Logistic%20Regression%20Hypothesis.png)\n<center>Sigmoid Function</center>\n\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/2017-10-30-Sigmoid Function.md","raw":"---\ntitle: Sigmoid Function\ndate: 2017-10-30 15:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Sigmoid Function\n\n\n## 1. Introduction\n> To limit all data within the range of 0 to 1.\n\n## 2. Formula\n$$\ny = \\frac{1}{1+e^{-x}}\n$$\n\n## 3. Implementation\n### 3.1 Octave\n```\n x = linspace(-10, 10 ,10000);\n y = zeros( size(x, 1), size(x, 2));\n\n for i = 1:length(x)\n   y(i) = 1/(1+e^(-x(i)));\n endfor\n\n figure();\n plot( x,y);\n grid on;\n xlabel(\"x\");\n ylabel(\"y=1/(1+e^-x)\");\n title(\"Sigmoid Function\");\n```\n\nOutput figure\n![Sigmoid Function](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/fd188539ca35c6e4d8859d07bbde8f5439760bae/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/2.Logistic%20Regression%20Hypothesis.png)\n<center>Sigmoid Function</center>\n\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/2017-10-30-Sigmoid Function","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0ba000ke0owxftlzlhm","content":"<h1 id=\"Sigmoid-Function\"><a href=\"#Sigmoid-Function\" class=\"headerlink\" title=\"Sigmoid Function\"></a>Sigmoid Function</h1><h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h2><blockquote>\n<p>To limit all data within the range of 0 to 1.</p>\n</blockquote>\n<h2 id=\"2-Formula\"><a href=\"#2-Formula\" class=\"headerlink\" title=\"2. Formula\"></a>2. Formula</h2><script type=\"math/tex; mode=display\">\ny = \\frac{1}{1+e^{-x}}</script><h2 id=\"3-Implementation\"><a href=\"#3-Implementation\" class=\"headerlink\" title=\"3. Implementation\"></a>3. Implementation</h2><h3 id=\"3-1-Octave\"><a href=\"#3-1-Octave\" class=\"headerlink\" title=\"3.1 Octave\"></a>3.1 Octave</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = linspace(-10, 10 ,10000);</div><div class=\"line\">y = zeros( size(x, 1), size(x, 2));</div><div class=\"line\"></div><div class=\"line\">for i = 1:length(x)</div><div class=\"line\">  y(i) = 1/(1+e^(-x(i)));</div><div class=\"line\">endfor</div><div class=\"line\"></div><div class=\"line\">figure();</div><div class=\"line\">plot( x,y);</div><div class=\"line\">grid on;</div><div class=\"line\">xlabel(&quot;x&quot;);</div><div class=\"line\">ylabel(&quot;y=1/(1+e^-x)&quot;);</div><div class=\"line\">title(&quot;Sigmoid Function&quot;);</div></pre></td></tr></table></figure>\n<p>Output figure<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/fd188539ca35c6e4d8859d07bbde8f5439760bae/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/2.Logistic%20Regression%20Hypothesis.png\" alt=\"Sigmoid Function\"></p>\n<center>Sigmoid Function</center>\n\n\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Sigmoid-Function\"><a href=\"#Sigmoid-Function\" class=\"headerlink\" title=\"Sigmoid Function\"></a>Sigmoid Function</h1><h2 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1. Introduction\"></a>1. Introduction</h2><blockquote>\n<p>To limit all data within the range of 0 to 1.</p>\n</blockquote>\n<h2 id=\"2-Formula\"><a href=\"#2-Formula\" class=\"headerlink\" title=\"2. Formula\"></a>2. Formula</h2><script type=\"math/tex; mode=display\">\ny = \\frac{1}{1+e^{-x}}</script><h2 id=\"3-Implementation\"><a href=\"#3-Implementation\" class=\"headerlink\" title=\"3. Implementation\"></a>3. Implementation</h2><h3 id=\"3-1-Octave\"><a href=\"#3-1-Octave\" class=\"headerlink\" title=\"3.1 Octave\"></a>3.1 Octave</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = linspace(-10, 10 ,10000);</div><div class=\"line\">y = zeros( size(x, 1), size(x, 2));</div><div class=\"line\"></div><div class=\"line\">for i = 1:length(x)</div><div class=\"line\">  y(i) = 1/(1+e^(-x(i)));</div><div class=\"line\">endfor</div><div class=\"line\"></div><div class=\"line\">figure();</div><div class=\"line\">plot( x,y);</div><div class=\"line\">grid on;</div><div class=\"line\">xlabel(&quot;x&quot;);</div><div class=\"line\">ylabel(&quot;y=1/(1+e^-x)&quot;);</div><div class=\"line\">title(&quot;Sigmoid Function&quot;);</div></pre></td></tr></table></figure>\n<p>Output figure<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/fd188539ca35c6e4d8859d07bbde8f5439760bae/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/2.Logistic%20Regression%20Hypothesis.png\" alt=\"Sigmoid Function\"></p>\n<center>Sigmoid Function</center>\n\n\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Concave and Convex Function","date":"2017-11-30T13:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Concave and Convex Function\n\n## What is Concave Function?\nConcave function is a function where the line segement between any two points of the function lies below or on the graph.[1]\n\nMathematically, as for concave function, the derivative of the left side of the max point is > 0, whereas the right side of the max point is < 0. There is one and only one value to make the derivative of the function equal to 0.\n\nSee the example below.\n\n![Concave function](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Concave%20Function.jpg)\nConcave Function\n\n## What is Convex Function?\n\nOppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.[2]\n\nMathematically, as for concave function, the derivative of the left side of the max point is < 0, whereas the right side of the max point is > 0. There is one and only one value to make the derivative of the function equal to 0.\n\nSee the example below.\n\n![Convex function](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Convex%20Function.jpg)\nConvex Function\n\n## Neither Concave or Convex Function\n\nAs for other function which is neither concave or convex function, the number of the value to make the derivative of the function equal to 0 is multiple or none.\n\nSee the example below.\n\n![Neither](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Neither.jpg)\nNeither\n\n\n## How to Find the Max/Min of Concave/Convex Function?\n\nTo find the max/min of concave/convex function, we need to make the value converge to the max/min.\n\nSo to converge the value, as for concave function, we should plus the derivative of the function, whereas we should substract the derivative of the function.\n\n\n\nLet summary the attribute concave and convex function\n\nConcave| Convex |\n:-------:|:------:|\nConcave function is a function where the line segement between any two points of the function lies below or on the graph.|Oppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.|\nMathematically, as for concave function, the derivative of the left side of the max point is > 0, whereas the right side of the max point is < 0. There is one and only one value to make the derivative of the function equal to 0.|Mathematically, as for concave function, the derivative of the left side of the max point is < 0, whereas the right side of the max point is > 0. There is one and only one value to make the derivative of the function equal to 0.\nPlus the derivative of the function | Substract the derivative of the function|\n\n\nSee more detail below.\n\n![Converge](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Optimize.jpg)\nConverge\n\n\n# Reference\n[1] [Concave function - Wikipedia](https://en.wikipedia.org/wiki/Concave_function)\n\n[2] [Convex function - Wikipedia](https://en.wikipedia.org/wiki/Convex_function)\n","source":"_posts/Mathematics/2017-11-30-Concave and Convex Function.md","raw":"---\ntitle: Concave and Convex Function\ndate: 2017-11-30 21:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning-Mathematics]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Concave and Convex Function\n\n## What is Concave Function?\nConcave function is a function where the line segement between any two points of the function lies below or on the graph.[1]\n\nMathematically, as for concave function, the derivative of the left side of the max point is > 0, whereas the right side of the max point is < 0. There is one and only one value to make the derivative of the function equal to 0.\n\nSee the example below.\n\n![Concave function](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Concave%20Function.jpg)\nConcave Function\n\n## What is Convex Function?\n\nOppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.[2]\n\nMathematically, as for concave function, the derivative of the left side of the max point is < 0, whereas the right side of the max point is > 0. There is one and only one value to make the derivative of the function equal to 0.\n\nSee the example below.\n\n![Convex function](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Convex%20Function.jpg)\nConvex Function\n\n## Neither Concave or Convex Function\n\nAs for other function which is neither concave or convex function, the number of the value to make the derivative of the function equal to 0 is multiple or none.\n\nSee the example below.\n\n![Neither](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Neither.jpg)\nNeither\n\n\n## How to Find the Max/Min of Concave/Convex Function?\n\nTo find the max/min of concave/convex function, we need to make the value converge to the max/min.\n\nSo to converge the value, as for concave function, we should plus the derivative of the function, whereas we should substract the derivative of the function.\n\n\n\nLet summary the attribute concave and convex function\n\nConcave| Convex |\n:-------:|:------:|\nConcave function is a function where the line segement between any two points of the function lies below or on the graph.|Oppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.|\nMathematically, as for concave function, the derivative of the left side of the max point is > 0, whereas the right side of the max point is < 0. There is one and only one value to make the derivative of the function equal to 0.|Mathematically, as for concave function, the derivative of the left side of the max point is < 0, whereas the right side of the max point is > 0. There is one and only one value to make the derivative of the function equal to 0.\nPlus the derivative of the function | Substract the derivative of the function|\n\n\nSee more detail below.\n\n![Converge](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Optimize.jpg)\nConverge\n\n\n# Reference\n[1] [Concave function - Wikipedia](https://en.wikipedia.org/wiki/Concave_function)\n\n[2] [Convex function - Wikipedia](https://en.wikipedia.org/wiki/Convex_function)\n","slug":"Mathematics/2017-11-30-Concave and Convex Function","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bb000oe0owm1zv95rq","content":"<h1 id=\"Concave-and-Convex-Function\"><a href=\"#Concave-and-Convex-Function\" class=\"headerlink\" title=\"Concave and Convex Function\"></a>Concave and Convex Function</h1><h2 id=\"What-is-Concave-Function\"><a href=\"#What-is-Concave-Function\" class=\"headerlink\" title=\"What is Concave Function?\"></a>What is Concave Function?</h2><p>Concave function is a function where the line segement between any two points of the function lies below or on the graph.[1]</p>\n<p>Mathematically, as for concave function, the derivative of the left side of the max point is &gt; 0, whereas the right side of the max point is &lt; 0. There is one and only one value to make the derivative of the function equal to 0.</p>\n<p>See the example below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Concave%20Function.jpg\" alt=\"Concave function\"><br>Concave Function</p>\n<h2 id=\"What-is-Convex-Function\"><a href=\"#What-is-Convex-Function\" class=\"headerlink\" title=\"What is Convex Function?\"></a>What is Convex Function?</h2><p>Oppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.[2]</p>\n<p>Mathematically, as for concave function, the derivative of the left side of the max point is &lt; 0, whereas the right side of the max point is &gt; 0. There is one and only one value to make the derivative of the function equal to 0.</p>\n<p>See the example below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Convex%20Function.jpg\" alt=\"Convex function\"><br>Convex Function</p>\n<h2 id=\"Neither-Concave-or-Convex-Function\"><a href=\"#Neither-Concave-or-Convex-Function\" class=\"headerlink\" title=\"Neither Concave or Convex Function\"></a>Neither Concave or Convex Function</h2><p>As for other function which is neither concave or convex function, the number of the value to make the derivative of the function equal to 0 is multiple or none.</p>\n<p>See the example below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Neither.jpg\" alt=\"Neither\"><br>Neither</p>\n<h2 id=\"How-to-Find-the-Max-Min-of-Concave-Convex-Function\"><a href=\"#How-to-Find-the-Max-Min-of-Concave-Convex-Function\" class=\"headerlink\" title=\"How to Find the Max/Min of Concave/Convex Function?\"></a>How to Find the Max/Min of Concave/Convex Function?</h2><p>To find the max/min of concave/convex function, we need to make the value converge to the max/min.</p>\n<p>So to converge the value, as for concave function, we should plus the derivative of the function, whereas we should substract the derivative of the function.</p>\n<p>Let summary the attribute concave and convex function</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Concave</th>\n<th style=\"text-align:center\">Convex</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Concave function is a function where the line segement between any two points of the function lies below or on the graph.</td>\n<td style=\"text-align:center\">Oppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Mathematically, as for concave function, the derivative of the left side of the max point is &gt; 0, whereas the right side of the max point is &lt; 0. There is one and only one value to make the derivative of the function equal to 0.</td>\n<td style=\"text-align:center\">Mathematically, as for concave function, the derivative of the left side of the max point is &lt; 0, whereas the right side of the max point is &gt; 0. There is one and only one value to make the derivative of the function equal to 0.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Plus the derivative of the function</td>\n<td style=\"text-align:center\">Substract the derivative of the function</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>See more detail below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Optimize.jpg\" alt=\"Converge\"><br>Converge</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] <a href=\"https://en.wikipedia.org/wiki/Concave_function\" target=\"_blank\" rel=\"external\">Concave function - Wikipedia</a></p>\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/Convex_function\" target=\"_blank\" rel=\"external\">Convex function - Wikipedia</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Concave-and-Convex-Function\"><a href=\"#Concave-and-Convex-Function\" class=\"headerlink\" title=\"Concave and Convex Function\"></a>Concave and Convex Function</h1><h2 id=\"What-is-Concave-Function\"><a href=\"#What-is-Concave-Function\" class=\"headerlink\" title=\"What is Concave Function?\"></a>What is Concave Function?</h2><p>Concave function is a function where the line segement between any two points of the function lies below or on the graph.[1]</p>\n<p>Mathematically, as for concave function, the derivative of the left side of the max point is &gt; 0, whereas the right side of the max point is &lt; 0. There is one and only one value to make the derivative of the function equal to 0.</p>\n<p>See the example below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Concave%20Function.jpg\" alt=\"Concave function\"><br>Concave Function</p>\n<h2 id=\"What-is-Convex-Function\"><a href=\"#What-is-Convex-Function\" class=\"headerlink\" title=\"What is Convex Function?\"></a>What is Convex Function?</h2><p>Oppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.[2]</p>\n<p>Mathematically, as for concave function, the derivative of the left side of the max point is &lt; 0, whereas the right side of the max point is &gt; 0. There is one and only one value to make the derivative of the function equal to 0.</p>\n<p>See the example below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Convex%20Function.jpg\" alt=\"Convex function\"><br>Convex Function</p>\n<h2 id=\"Neither-Concave-or-Convex-Function\"><a href=\"#Neither-Concave-or-Convex-Function\" class=\"headerlink\" title=\"Neither Concave or Convex Function\"></a>Neither Concave or Convex Function</h2><p>As for other function which is neither concave or convex function, the number of the value to make the derivative of the function equal to 0 is multiple or none.</p>\n<p>See the example below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Neither.jpg\" alt=\"Neither\"><br>Neither</p>\n<h2 id=\"How-to-Find-the-Max-Min-of-Concave-Convex-Function\"><a href=\"#How-to-Find-the-Max-Min-of-Concave-Convex-Function\" class=\"headerlink\" title=\"How to Find the Max/Min of Concave/Convex Function?\"></a>How to Find the Max/Min of Concave/Convex Function?</h2><p>To find the max/min of concave/convex function, we need to make the value converge to the max/min.</p>\n<p>So to converge the value, as for concave function, we should plus the derivative of the function, whereas we should substract the derivative of the function.</p>\n<p>Let summary the attribute concave and convex function</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Concave</th>\n<th style=\"text-align:center\">Convex</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Concave function is a function where the line segement between any two points of the function lies below or on the graph.</td>\n<td style=\"text-align:center\">Oppose to concave function, convex function is a function where the line segement between any two points of the function lies above or on the graph.</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Mathematically, as for concave function, the derivative of the left side of the max point is &gt; 0, whereas the right side of the max point is &lt; 0. There is one and only one value to make the derivative of the function equal to 0.</td>\n<td style=\"text-align:center\">Mathematically, as for concave function, the derivative of the left side of the max point is &lt; 0, whereas the right side of the max point is &gt; 0. There is one and only one value to make the derivative of the function equal to 0.</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Plus the derivative of the function</td>\n<td style=\"text-align:center\">Substract the derivative of the function</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>See more detail below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/c4798307c21222a06dec48ee4e47e31f990da5e2/__Blog/__Personal%20Understanding/_archive/_images/Concave%20and%20Convex%20Function-Optimize.jpg\" alt=\"Converge\"><br>Converge</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] <a href=\"https://en.wikipedia.org/wiki/Concave_function\" target=\"_blank\" rel=\"external\">Concave function - Wikipedia</a></p>\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/Convex_function\" target=\"_blank\" rel=\"external\">Convex function - Wikipedia</a></p>\n"},{"title":"数据预处理-数据分割","date":"2017-10-31T04:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n\n# 1. 为什么是数据分割\n通过把数据集 (Dataset) 中的数据内容分割成训练集 (Train Set) 和测试集 (Test Set)，用训练集来训练模型，再通过测试集来测试模型的性能，如果测试通过，才会考虑投放在实际应用中。\n\n------------------\n\n\n\n# 2. 数据分割的注意事项\n## 2.1. 保证数据的随机性\n如果数据分割是按照一定的规律进行的话，那么训练出来的模型也会被“模式化”，一旦遇到特殊值，就会判断出错。\n\n## 2.2. 保证训练集的大小\n训练的数量越大，模型的准确率一般会更高。如果训练集太小，模型就“不稳定”，在测试中遇到特殊值，就容易得到错误的结果。\n\n------------------\n\n\n# 3. Python实现方法\n> Github代码：https://github.com/JasonDean-1/MachineLearningDemo/blob/master/DataPreprocessing/1.DataSplit.py\n## 3.1. 调用sklearn的包\n\n```\n# --- coding: utf-8 ---\n\n\"\"\"\nPackage Version(s):\n    sklearn: 0.18\n\"\"\"\n\nfrom sklearn.datasets import load_digits\n\n# load in datasets\ndatasets = load_digits()\n# Print out the datashape.\nprint \"The length of dataset is: \", datasets.data.shape\n# Ans = (1797L, 64L)\n\nfrom sklearn.cross_validation import train_test_split\n# Split the data\nx_train, x_test, y_train, y_test = train_test_split( datasets.data, datasets.target, test_size = 0.25, random_state = 42 )\n# Print out the datashape.\nprint \"The length of train set is: \", y_train.shape\n# Ans = (1347L,)\nprint \"The length of test set is: \", y_test.shape\n# Ans = (450L,)\n\n\n----------\nOutput:\n# The length of dataset is: (1797L, 64L)\n# The length of train set is: Ans = (1347L,)\n# The length of test set is: Ans = (450L,)\n```\n\n<br>\n<br>\n<br>\n\n\n## 3.2. 通过循环来分割数据\n\n```\n# --- coding: utf-8 ---\n\n\"\"\"\nPackage Version(s):\n    sklearn: 0.18\n\"\"\"\n\nfrom sklearn.datasets import load_digits\n\n# load in datasets\ndatasets = load_digits()\n# Print out the datashape.\nprint \"The length of dataset is: \", datasets.data.shape\n# Ans = (1797L, 64L)\nx_train = []\nx_test = []\ny_train = []\ny_test = []\n\n# Split the data\nx_test = [datasets.data[i] for i in range(len(datasets.data)) if i%4 == 0]\nx_train = [datasets.data[i] for i in range(len(datasets.data)) if i%4 != 0]\ny_test = [datasets.target[i] for i in range(len(datasets.data)) if i%4 == 0]\ny_train = [datasets.target[i] for i in range(len(datasets.data)) if i%4 != 0]\n\n# Print out the datashape.\nprint \"The length of train set is: \", len( y_train )\n# Ans = 1347\nprint \"The length of test set is: \", len( y_test )\n# Ans = 450\n\n\n----------\nOutput:\n# The length of dataset is: (1797L, 64L)\n# The length of train set is: Ans = 1347\n# The length of test set is: Ans = 450\n```\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/2017-10-31-数据分割.md","raw":"---\ntitle: 数据预处理-数据分割\ndate: 2017-10-31 12:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n\n# 1. 为什么是数据分割\n通过把数据集 (Dataset) 中的数据内容分割成训练集 (Train Set) 和测试集 (Test Set)，用训练集来训练模型，再通过测试集来测试模型的性能，如果测试通过，才会考虑投放在实际应用中。\n\n------------------\n\n\n\n# 2. 数据分割的注意事项\n## 2.1. 保证数据的随机性\n如果数据分割是按照一定的规律进行的话，那么训练出来的模型也会被“模式化”，一旦遇到特殊值，就会判断出错。\n\n## 2.2. 保证训练集的大小\n训练的数量越大，模型的准确率一般会更高。如果训练集太小，模型就“不稳定”，在测试中遇到特殊值，就容易得到错误的结果。\n\n------------------\n\n\n# 3. Python实现方法\n> Github代码：https://github.com/JasonDean-1/MachineLearningDemo/blob/master/DataPreprocessing/1.DataSplit.py\n## 3.1. 调用sklearn的包\n\n```\n# --- coding: utf-8 ---\n\n\"\"\"\nPackage Version(s):\n    sklearn: 0.18\n\"\"\"\n\nfrom sklearn.datasets import load_digits\n\n# load in datasets\ndatasets = load_digits()\n# Print out the datashape.\nprint \"The length of dataset is: \", datasets.data.shape\n# Ans = (1797L, 64L)\n\nfrom sklearn.cross_validation import train_test_split\n# Split the data\nx_train, x_test, y_train, y_test = train_test_split( datasets.data, datasets.target, test_size = 0.25, random_state = 42 )\n# Print out the datashape.\nprint \"The length of train set is: \", y_train.shape\n# Ans = (1347L,)\nprint \"The length of test set is: \", y_test.shape\n# Ans = (450L,)\n\n\n----------\nOutput:\n# The length of dataset is: (1797L, 64L)\n# The length of train set is: Ans = (1347L,)\n# The length of test set is: Ans = (450L,)\n```\n\n<br>\n<br>\n<br>\n\n\n## 3.2. 通过循环来分割数据\n\n```\n# --- coding: utf-8 ---\n\n\"\"\"\nPackage Version(s):\n    sklearn: 0.18\n\"\"\"\n\nfrom sklearn.datasets import load_digits\n\n# load in datasets\ndatasets = load_digits()\n# Print out the datashape.\nprint \"The length of dataset is: \", datasets.data.shape\n# Ans = (1797L, 64L)\nx_train = []\nx_test = []\ny_train = []\ny_test = []\n\n# Split the data\nx_test = [datasets.data[i] for i in range(len(datasets.data)) if i%4 == 0]\nx_train = [datasets.data[i] for i in range(len(datasets.data)) if i%4 != 0]\ny_test = [datasets.target[i] for i in range(len(datasets.data)) if i%4 == 0]\ny_train = [datasets.target[i] for i in range(len(datasets.data)) if i%4 != 0]\n\n# Print out the datashape.\nprint \"The length of train set is: \", len( y_train )\n# Ans = 1347\nprint \"The length of test set is: \", len( y_test )\n# Ans = 450\n\n\n----------\nOutput:\n# The length of dataset is: (1797L, 64L)\n# The length of train set is: Ans = 1347\n# The length of test set is: Ans = 450\n```\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/2017-10-31-数据分割","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bc000qe0own10xp805","content":"<h1 id=\"1-为什么是数据分割\"><a href=\"#1-为什么是数据分割\" class=\"headerlink\" title=\"1. 为什么是数据分割\"></a>1. 为什么是数据分割</h1><p>通过把数据集 (Dataset) 中的数据内容分割成训练集 (Train Set) 和测试集 (Test Set)，用训练集来训练模型，再通过测试集来测试模型的性能，如果测试通过，才会考虑投放在实际应用中。</p>\n<hr>\n<h1 id=\"2-数据分割的注意事项\"><a href=\"#2-数据分割的注意事项\" class=\"headerlink\" title=\"2. 数据分割的注意事项\"></a>2. 数据分割的注意事项</h1><h2 id=\"2-1-保证数据的随机性\"><a href=\"#2-1-保证数据的随机性\" class=\"headerlink\" title=\"2.1. 保证数据的随机性\"></a>2.1. 保证数据的随机性</h2><p>如果数据分割是按照一定的规律进行的话，那么训练出来的模型也会被“模式化”，一旦遇到特殊值，就会判断出错。</p>\n<h2 id=\"2-2-保证训练集的大小\"><a href=\"#2-2-保证训练集的大小\" class=\"headerlink\" title=\"2.2. 保证训练集的大小\"></a>2.2. 保证训练集的大小</h2><p>训练的数量越大，模型的准确率一般会更高。如果训练集太小，模型就“不稳定”，在测试中遇到特殊值，就容易得到错误的结果。</p>\n<hr>\n<h1 id=\"3-Python实现方法\"><a href=\"#3-Python实现方法\" class=\"headerlink\" title=\"3. Python实现方法\"></a>3. Python实现方法</h1><blockquote>\n<p>Github代码：<a href=\"https://github.com/JasonDean-1/MachineLearningDemo/blob/master/DataPreprocessing/1.DataSplit.py\" target=\"_blank\" rel=\"external\">https://github.com/JasonDean-1/MachineLearningDemo/blob/master/DataPreprocessing/1.DataSplit.py</a></p>\n<h2 id=\"3-1-调用sklearn的包\"><a href=\"#3-1-调用sklearn的包\" class=\"headerlink\" title=\"3.1. 调用sklearn的包\"></a>3.1. 调用sklearn的包</h2></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"># --- coding: utf-8 ---</div><div class=\"line\"></div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\">Package Version(s):</div><div class=\"line\">    sklearn: 0.18</div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">from sklearn.datasets import load_digits</div><div class=\"line\"></div><div class=\"line\"># load in datasets</div><div class=\"line\">datasets = load_digits()</div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of dataset is: &quot;, datasets.data.shape</div><div class=\"line\"># Ans = (1797L, 64L)</div><div class=\"line\"></div><div class=\"line\">from sklearn.cross_validation import train_test_split</div><div class=\"line\"># Split the data</div><div class=\"line\">x_train, x_test, y_train, y_test = train_test_split( datasets.data, datasets.target, test_size = 0.25, random_state = 42 )</div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of train set is: &quot;, y_train.shape</div><div class=\"line\"># Ans = (1347L,)</div><div class=\"line\">print &quot;The length of test set is: &quot;, y_test.shape</div><div class=\"line\"># Ans = (450L,)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">----------</div><div class=\"line\">Output:</div><div class=\"line\"># The length of dataset is: (1797L, 64L)</div><div class=\"line\"># The length of train set is: Ans = (1347L,)</div><div class=\"line\"># The length of test set is: Ans = (450L,)</div></pre></td></tr></table></figure>\n<p><br><br><br><br><br></p>\n<h2 id=\"3-2-通过循环来分割数据\"><a href=\"#3-2-通过循环来分割数据\" class=\"headerlink\" title=\"3.2. 通过循环来分割数据\"></a>3.2. 通过循环来分割数据</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"># --- coding: utf-8 ---</div><div class=\"line\"></div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\">Package Version(s):</div><div class=\"line\">    sklearn: 0.18</div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">from sklearn.datasets import load_digits</div><div class=\"line\"></div><div class=\"line\"># load in datasets</div><div class=\"line\">datasets = load_digits()</div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of dataset is: &quot;, datasets.data.shape</div><div class=\"line\"># Ans = (1797L, 64L)</div><div class=\"line\">x_train = []</div><div class=\"line\">x_test = []</div><div class=\"line\">y_train = []</div><div class=\"line\">y_test = []</div><div class=\"line\"></div><div class=\"line\"># Split the data</div><div class=\"line\">x_test = [datasets.data[i] for i in range(len(datasets.data)) if i%4 == 0]</div><div class=\"line\">x_train = [datasets.data[i] for i in range(len(datasets.data)) if i%4 != 0]</div><div class=\"line\">y_test = [datasets.target[i] for i in range(len(datasets.data)) if i%4 == 0]</div><div class=\"line\">y_train = [datasets.target[i] for i in range(len(datasets.data)) if i%4 != 0]</div><div class=\"line\"></div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of train set is: &quot;, len( y_train )</div><div class=\"line\"># Ans = 1347</div><div class=\"line\">print &quot;The length of test set is: &quot;, len( y_test )</div><div class=\"line\"># Ans = 450</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">----------</div><div class=\"line\">Output:</div><div class=\"line\"># The length of dataset is: (1797L, 64L)</div><div class=\"line\"># The length of train set is: Ans = 1347</div><div class=\"line\"># The length of test set is: Ans = 450</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-为什么是数据分割\"><a href=\"#1-为什么是数据分割\" class=\"headerlink\" title=\"1. 为什么是数据分割\"></a>1. 为什么是数据分割</h1><p>通过把数据集 (Dataset) 中的数据内容分割成训练集 (Train Set) 和测试集 (Test Set)，用训练集来训练模型，再通过测试集来测试模型的性能，如果测试通过，才会考虑投放在实际应用中。</p>\n<hr>\n<h1 id=\"2-数据分割的注意事项\"><a href=\"#2-数据分割的注意事项\" class=\"headerlink\" title=\"2. 数据分割的注意事项\"></a>2. 数据分割的注意事项</h1><h2 id=\"2-1-保证数据的随机性\"><a href=\"#2-1-保证数据的随机性\" class=\"headerlink\" title=\"2.1. 保证数据的随机性\"></a>2.1. 保证数据的随机性</h2><p>如果数据分割是按照一定的规律进行的话，那么训练出来的模型也会被“模式化”，一旦遇到特殊值，就会判断出错。</p>\n<h2 id=\"2-2-保证训练集的大小\"><a href=\"#2-2-保证训练集的大小\" class=\"headerlink\" title=\"2.2. 保证训练集的大小\"></a>2.2. 保证训练集的大小</h2><p>训练的数量越大，模型的准确率一般会更高。如果训练集太小，模型就“不稳定”，在测试中遇到特殊值，就容易得到错误的结果。</p>\n<hr>\n<h1 id=\"3-Python实现方法\"><a href=\"#3-Python实现方法\" class=\"headerlink\" title=\"3. Python实现方法\"></a>3. Python实现方法</h1><blockquote>\n<p>Github代码：<a href=\"https://github.com/JasonDean-1/MachineLearningDemo/blob/master/DataPreprocessing/1.DataSplit.py\" target=\"_blank\" rel=\"external\">https://github.com/JasonDean-1/MachineLearningDemo/blob/master/DataPreprocessing/1.DataSplit.py</a></p>\n<h2 id=\"3-1-调用sklearn的包\"><a href=\"#3-1-调用sklearn的包\" class=\"headerlink\" title=\"3.1. 调用sklearn的包\"></a>3.1. 调用sklearn的包</h2></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"># --- coding: utf-8 ---</div><div class=\"line\"></div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\">Package Version(s):</div><div class=\"line\">    sklearn: 0.18</div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">from sklearn.datasets import load_digits</div><div class=\"line\"></div><div class=\"line\"># load in datasets</div><div class=\"line\">datasets = load_digits()</div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of dataset is: &quot;, datasets.data.shape</div><div class=\"line\"># Ans = (1797L, 64L)</div><div class=\"line\"></div><div class=\"line\">from sklearn.cross_validation import train_test_split</div><div class=\"line\"># Split the data</div><div class=\"line\">x_train, x_test, y_train, y_test = train_test_split( datasets.data, datasets.target, test_size = 0.25, random_state = 42 )</div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of train set is: &quot;, y_train.shape</div><div class=\"line\"># Ans = (1347L,)</div><div class=\"line\">print &quot;The length of test set is: &quot;, y_test.shape</div><div class=\"line\"># Ans = (450L,)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">----------</div><div class=\"line\">Output:</div><div class=\"line\"># The length of dataset is: (1797L, 64L)</div><div class=\"line\"># The length of train set is: Ans = (1347L,)</div><div class=\"line\"># The length of test set is: Ans = (450L,)</div></pre></td></tr></table></figure>\n<p><br><br><br><br><br></p>\n<h2 id=\"3-2-通过循环来分割数据\"><a href=\"#3-2-通过循环来分割数据\" class=\"headerlink\" title=\"3.2. 通过循环来分割数据\"></a>3.2. 通过循环来分割数据</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"># --- coding: utf-8 ---</div><div class=\"line\"></div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\">Package Version(s):</div><div class=\"line\">    sklearn: 0.18</div><div class=\"line\">&quot;&quot;&quot;</div><div class=\"line\"></div><div class=\"line\">from sklearn.datasets import load_digits</div><div class=\"line\"></div><div class=\"line\"># load in datasets</div><div class=\"line\">datasets = load_digits()</div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of dataset is: &quot;, datasets.data.shape</div><div class=\"line\"># Ans = (1797L, 64L)</div><div class=\"line\">x_train = []</div><div class=\"line\">x_test = []</div><div class=\"line\">y_train = []</div><div class=\"line\">y_test = []</div><div class=\"line\"></div><div class=\"line\"># Split the data</div><div class=\"line\">x_test = [datasets.data[i] for i in range(len(datasets.data)) if i%4 == 0]</div><div class=\"line\">x_train = [datasets.data[i] for i in range(len(datasets.data)) if i%4 != 0]</div><div class=\"line\">y_test = [datasets.target[i] for i in range(len(datasets.data)) if i%4 == 0]</div><div class=\"line\">y_train = [datasets.target[i] for i in range(len(datasets.data)) if i%4 != 0]</div><div class=\"line\"></div><div class=\"line\"># Print out the datashape.</div><div class=\"line\">print &quot;The length of train set is: &quot;, len( y_train )</div><div class=\"line\"># Ans = 1347</div><div class=\"line\">print &quot;The length of test set is: &quot;, len( y_test )</div><div class=\"line\"># Ans = 450</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">----------</div><div class=\"line\">Output:</div><div class=\"line\"># The length of dataset is: (1797L, 64L)</div><div class=\"line\"># The length of train set is: Ans = 1347</div><div class=\"line\"># The length of test set is: Ans = 450</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"线性模型性能分析--混淆矩阵(Confusion Matrix)","date":"2017-11-01T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# 1.  什么是混淆矩阵\n>在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类像比较计算的<sup>[1]</sup>。\n\n通过分析混淆矩阵，我们可以得到:\n- TPR (True Positive Rate), FPR (False Positive Rate) 并画出ROC (Receiver Operating Characteristic)曲线和求出AUC (Area Under Curve)\n- 准确率(Accuracy), 精确率(Precision), 召回率(Recall), F1值(F1 Score)\n下面我们来分析混淆矩阵。\n\n-----------------------\n<br>\n<br>\n\n# 2. 混淆矩阵分析\n![Confusion Matrix](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/92bc9a9e0201360c0245f364051a9b2fadc77b54/MachineLearning/ConfusionMatrix.png)\n<center>Confusion Matrix<sup>[2]<sup></center>\n\n分析：\nTP：模型判定为P，实际上也是P，即判断正确\nFP：模型判定为N，实际上却是P，即判断错误\nFN：模型判定为P，实际上却是N，即判断错误\nTN：模型判定为N，实际上也是N，即判断正确\n\n-----------\n存在关系：\n$TPR = \\frac{TP}{TP+FP}$\n\n$FPR = \\frac{FP}{TN+FN}$\n\n$Accuracy = \\frac{TP+TN}{TP+FP+TN+FN}$\n\n$Precision = \\frac{TP}{TP+FP}$\n\n$Recall = \\frac{TP}{TP+FN}$\n\n$F1-Measure= \\cfrac{2}{\\cfrac{1}{Precision}+\\cfrac{1}{Recall}}$\n\n-----------------------\n<br>\n<br>\n\n#3. Accuracy, Precision, Recall，F1-Measure的分析\n> 举例：要对癌症患者分类：良性和恶性。现在有200个患者，刚好100个良性，100个恶性，训练之后的预测50个良性，150个恶性，即：预测50个良性正确，有50个良性被预测为恶性，100个恶性预测全部正确。\n> 此时：\n> TP: 50\n> FP: 50\n> FN: 0\n>TN: 100\n>TPR: 0.5\n>FPR: 0.5\n>Accuracy: 75%\n>Precision: 50%\n>Recall: 100%\n>F1-Measure: 66.7% 即($\\frac{2}{3}$)\n\n\n关于精确率和召回率，要根据具体情境去判断，那个高才好，参考知乎第一条回答[精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？](https://www.zhihu.com/question/30643044/answer/48955833)\n\n-----------------------\n<br>\n<br>\n\n#4. ROC，AUC的分析：\n\n##4.1. ROC分析\n关于ROC，先看下图，\n![ROC](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ff7b13d768029291632ed1196d4729e41f30d371/MachineLearning/ROC.jpg)\n\n根据刚刚上面对TPR，FPR的分析，容易发现:\n\n- 在（0,0）点，TP和FP都为0（FN和TN都为1），也就是说，对于所有值，预测模型都预测为Negative，即判断为Positive的阈值过高。\n- 在（1,1）点，TP和FP都为1（FN和TN都为0），也就是说，对于所有值，预测模型都预测为Positive，即判断为Positive的阈值过低。\n\n\n##4.2. AUC分析\nAUC（Area Under Curve），我觉得原名应为（Area Under roc Curve）更好，其定义为ROC曲线下的面积，面积的数值不会大于1。\nROC曲线一般都处于$y=x$这条直线的上方，没有人希望模型在$y=x$的线以下，所以AUC的取值范围在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，但对应一个数据来说，AUC往往越大越好。\n\n-----------------------\n<br>\n<br>\n\n# 参考\n[1]百度百科:https://baike.baidu.com/item/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/10087822?fr=aladdin&fromid=18082441&fromtitle=Confusion+Matrix\n[2]维基百科:https://en.wikipedia.org/wiki/Confusion_matrix\n[3]精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？https://www.zhihu.com/question/30643044/answer/48955833\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/2017-11-01-线性模型性能分析--混淆矩阵(Confusion Matrix).md","raw":"---\ntitle: 线性模型性能分析--混淆矩阵(Confusion Matrix)\ndate: 2017-11-01 12:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# 1.  什么是混淆矩阵\n>在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类像比较计算的<sup>[1]</sup>。\n\n通过分析混淆矩阵，我们可以得到:\n- TPR (True Positive Rate), FPR (False Positive Rate) 并画出ROC (Receiver Operating Characteristic)曲线和求出AUC (Area Under Curve)\n- 准确率(Accuracy), 精确率(Precision), 召回率(Recall), F1值(F1 Score)\n下面我们来分析混淆矩阵。\n\n-----------------------\n<br>\n<br>\n\n# 2. 混淆矩阵分析\n![Confusion Matrix](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/92bc9a9e0201360c0245f364051a9b2fadc77b54/MachineLearning/ConfusionMatrix.png)\n<center>Confusion Matrix<sup>[2]<sup></center>\n\n分析：\nTP：模型判定为P，实际上也是P，即判断正确\nFP：模型判定为N，实际上却是P，即判断错误\nFN：模型判定为P，实际上却是N，即判断错误\nTN：模型判定为N，实际上也是N，即判断正确\n\n-----------\n存在关系：\n$TPR = \\frac{TP}{TP+FP}$\n\n$FPR = \\frac{FP}{TN+FN}$\n\n$Accuracy = \\frac{TP+TN}{TP+FP+TN+FN}$\n\n$Precision = \\frac{TP}{TP+FP}$\n\n$Recall = \\frac{TP}{TP+FN}$\n\n$F1-Measure= \\cfrac{2}{\\cfrac{1}{Precision}+\\cfrac{1}{Recall}}$\n\n-----------------------\n<br>\n<br>\n\n#3. Accuracy, Precision, Recall，F1-Measure的分析\n> 举例：要对癌症患者分类：良性和恶性。现在有200个患者，刚好100个良性，100个恶性，训练之后的预测50个良性，150个恶性，即：预测50个良性正确，有50个良性被预测为恶性，100个恶性预测全部正确。\n> 此时：\n> TP: 50\n> FP: 50\n> FN: 0\n>TN: 100\n>TPR: 0.5\n>FPR: 0.5\n>Accuracy: 75%\n>Precision: 50%\n>Recall: 100%\n>F1-Measure: 66.7% 即($\\frac{2}{3}$)\n\n\n关于精确率和召回率，要根据具体情境去判断，那个高才好，参考知乎第一条回答[精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？](https://www.zhihu.com/question/30643044/answer/48955833)\n\n-----------------------\n<br>\n<br>\n\n#4. ROC，AUC的分析：\n\n##4.1. ROC分析\n关于ROC，先看下图，\n![ROC](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ff7b13d768029291632ed1196d4729e41f30d371/MachineLearning/ROC.jpg)\n\n根据刚刚上面对TPR，FPR的分析，容易发现:\n\n- 在（0,0）点，TP和FP都为0（FN和TN都为1），也就是说，对于所有值，预测模型都预测为Negative，即判断为Positive的阈值过高。\n- 在（1,1）点，TP和FP都为1（FN和TN都为0），也就是说，对于所有值，预测模型都预测为Positive，即判断为Positive的阈值过低。\n\n\n##4.2. AUC分析\nAUC（Area Under Curve），我觉得原名应为（Area Under roc Curve）更好，其定义为ROC曲线下的面积，面积的数值不会大于1。\nROC曲线一般都处于$y=x$这条直线的上方，没有人希望模型在$y=x$的线以下，所以AUC的取值范围在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，但对应一个数据来说，AUC往往越大越好。\n\n-----------------------\n<br>\n<br>\n\n# 参考\n[1]百度百科:https://baike.baidu.com/item/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/10087822?fr=aladdin&fromid=18082441&fromtitle=Confusion+Matrix\n[2]维基百科:https://en.wikipedia.org/wiki/Confusion_matrix\n[3]精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？https://www.zhihu.com/question/30643044/answer/48955833\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/2017-11-01-线性模型性能分析--混淆矩阵(Confusion Matrix)","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bd000ue0owbp2oz2e8","content":"<h1 id=\"1-什么是混淆矩阵\"><a href=\"#1-什么是混淆矩阵\" class=\"headerlink\" title=\"1.  什么是混淆矩阵\"></a>1.  什么是混淆矩阵</h1><blockquote>\n<p>在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类像比较计算的<sup>[1]</sup>。</p>\n</blockquote>\n<p>通过分析混淆矩阵，我们可以得到:</p>\n<ul>\n<li>TPR (True Positive Rate), FPR (False Positive Rate) 并画出ROC (Receiver Operating Characteristic)曲线和求出AUC (Area Under Curve)</li>\n<li>准确率(Accuracy), 精确率(Precision), 召回率(Recall), F1值(F1 Score)<br>下面我们来分析混淆矩阵。</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"2-混淆矩阵分析\"><a href=\"#2-混淆矩阵分析\" class=\"headerlink\" title=\"2. 混淆矩阵分析\"></a>2. 混淆矩阵分析</h1><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/92bc9a9e0201360c0245f364051a9b2fadc77b54/MachineLearning/ConfusionMatrix.png\" alt=\"Confusion Matrix\"></p>\n<center>Confusion Matrix<sup>[2]<sup></sup></sup></center>\n\n<p>分析：<br>TP：模型判定为P，实际上也是P，即判断正确<br>FP：模型判定为N，实际上却是P，即判断错误<br>FN：模型判定为P，实际上却是N，即判断错误<br>TN：模型判定为N，实际上也是N，即判断正确</p>\n<hr>\n<p>存在关系：<br>$TPR = \\frac{TP}{TP+FP}$</p>\n<p>$FPR = \\frac{FP}{TN+FN}$</p>\n<p>$Accuracy = \\frac{TP+TN}{TP+FP+TN+FN}$</p>\n<p>$Precision = \\frac{TP}{TP+FP}$</p>\n<p>$Recall = \\frac{TP}{TP+FN}$</p>\n<p>$F1-Measure= \\cfrac{2}{\\cfrac{1}{Precision}+\\cfrac{1}{Recall}}$</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"3-Accuracy-Precision-Recall，F1-Measure的分析\"><a href=\"#3-Accuracy-Precision-Recall，F1-Measure的分析\" class=\"headerlink\" title=\"3. Accuracy, Precision, Recall，F1-Measure的分析\"></a>3. Accuracy, Precision, Recall，F1-Measure的分析</h1><blockquote>\n<p>举例：要对癌症患者分类：良性和恶性。现在有200个患者，刚好100个良性，100个恶性，训练之后的预测50个良性，150个恶性，即：预测50个良性正确，有50个良性被预测为恶性，100个恶性预测全部正确。<br>此时：<br>TP: 50<br>FP: 50<br>FN: 0<br>TN: 100<br>TPR: 0.5<br>FPR: 0.5<br>Accuracy: 75%<br>Precision: 50%<br>Recall: 100%<br>F1-Measure: 66.7% 即($\\frac{2}{3}$)</p>\n</blockquote>\n<p>关于精确率和召回率，要根据具体情境去判断，那个高才好，参考知乎第一条回答<a href=\"https://www.zhihu.com/question/30643044/answer/48955833\" target=\"_blank\" rel=\"external\">精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？</a></p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"4-ROC，AUC的分析：\"><a href=\"#4-ROC，AUC的分析：\" class=\"headerlink\" title=\"4. ROC，AUC的分析：\"></a>4. ROC，AUC的分析：</h1><h2 id=\"4-1-ROC分析\"><a href=\"#4-1-ROC分析\" class=\"headerlink\" title=\"4.1. ROC分析\"></a>4.1. ROC分析</h2><p>关于ROC，先看下图，<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ff7b13d768029291632ed1196d4729e41f30d371/MachineLearning/ROC.jpg\" alt=\"ROC\"></p>\n<p>根据刚刚上面对TPR，FPR的分析，容易发现:</p>\n<ul>\n<li>在（0,0）点，TP和FP都为0（FN和TN都为1），也就是说，对于所有值，预测模型都预测为Negative，即判断为Positive的阈值过高。</li>\n<li>在（1,1）点，TP和FP都为1（FN和TN都为0），也就是说，对于所有值，预测模型都预测为Positive，即判断为Positive的阈值过低。</li>\n</ul>\n<h2 id=\"4-2-AUC分析\"><a href=\"#4-2-AUC分析\" class=\"headerlink\" title=\"4.2. AUC分析\"></a>4.2. AUC分析</h2><p>AUC（Area Under Curve），我觉得原名应为（Area Under roc Curve）更好，其定义为ROC曲线下的面积，面积的数值不会大于1。<br>ROC曲线一般都处于$y=x$这条直线的上方，没有人希望模型在$y=x$的线以下，所以AUC的取值范围在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，但对应一个数据来说，AUC往往越大越好。</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>[1]百度百科:<a href=\"https://baike.baidu.com/item/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/10087822?fr=aladdin&amp;fromid=18082441&amp;fromtitle=Confusion+Matrix\" target=\"_blank\" rel=\"external\">https://baike.baidu.com/item/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/10087822?fr=aladdin&amp;fromid=18082441&amp;fromtitle=Confusion+Matrix</a><br>[2]维基百科:<a href=\"https://en.wikipedia.org/wiki/Confusion_matrix\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Confusion_matrix</a><br>[3]精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？<a href=\"https://www.zhihu.com/question/30643044/answer/48955833\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/30643044/answer/48955833</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-什么是混淆矩阵\"><a href=\"#1-什么是混淆矩阵\" class=\"headerlink\" title=\"1.  什么是混淆矩阵\"></a>1.  什么是混淆矩阵</h1><blockquote>\n<p>在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类像比较计算的<sup>[1]</sup>。</p>\n</blockquote>\n<p>通过分析混淆矩阵，我们可以得到:</p>\n<ul>\n<li>TPR (True Positive Rate), FPR (False Positive Rate) 并画出ROC (Receiver Operating Characteristic)曲线和求出AUC (Area Under Curve)</li>\n<li>准确率(Accuracy), 精确率(Precision), 召回率(Recall), F1值(F1 Score)<br>下面我们来分析混淆矩阵。</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"2-混淆矩阵分析\"><a href=\"#2-混淆矩阵分析\" class=\"headerlink\" title=\"2. 混淆矩阵分析\"></a>2. 混淆矩阵分析</h1><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/92bc9a9e0201360c0245f364051a9b2fadc77b54/MachineLearning/ConfusionMatrix.png\" alt=\"Confusion Matrix\"></p>\n<center>Confusion Matrix<sup>[2]<sup></sup></sup></center>\n\n<p>分析：<br>TP：模型判定为P，实际上也是P，即判断正确<br>FP：模型判定为N，实际上却是P，即判断错误<br>FN：模型判定为P，实际上却是N，即判断错误<br>TN：模型判定为N，实际上也是N，即判断正确</p>\n<hr>\n<p>存在关系：<br>$TPR = \\frac{TP}{TP+FP}$</p>\n<p>$FPR = \\frac{FP}{TN+FN}$</p>\n<p>$Accuracy = \\frac{TP+TN}{TP+FP+TN+FN}$</p>\n<p>$Precision = \\frac{TP}{TP+FP}$</p>\n<p>$Recall = \\frac{TP}{TP+FN}$</p>\n<p>$F1-Measure= \\cfrac{2}{\\cfrac{1}{Precision}+\\cfrac{1}{Recall}}$</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"3-Accuracy-Precision-Recall，F1-Measure的分析\"><a href=\"#3-Accuracy-Precision-Recall，F1-Measure的分析\" class=\"headerlink\" title=\"3. Accuracy, Precision, Recall，F1-Measure的分析\"></a>3. Accuracy, Precision, Recall，F1-Measure的分析</h1><blockquote>\n<p>举例：要对癌症患者分类：良性和恶性。现在有200个患者，刚好100个良性，100个恶性，训练之后的预测50个良性，150个恶性，即：预测50个良性正确，有50个良性被预测为恶性，100个恶性预测全部正确。<br>此时：<br>TP: 50<br>FP: 50<br>FN: 0<br>TN: 100<br>TPR: 0.5<br>FPR: 0.5<br>Accuracy: 75%<br>Precision: 50%<br>Recall: 100%<br>F1-Measure: 66.7% 即($\\frac{2}{3}$)</p>\n</blockquote>\n<p>关于精确率和召回率，要根据具体情境去判断，那个高才好，参考知乎第一条回答<a href=\"https://www.zhihu.com/question/30643044/answer/48955833\" target=\"_blank\" rel=\"external\">精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？</a></p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"4-ROC，AUC的分析：\"><a href=\"#4-ROC，AUC的分析：\" class=\"headerlink\" title=\"4. ROC，AUC的分析：\"></a>4. ROC，AUC的分析：</h1><h2 id=\"4-1-ROC分析\"><a href=\"#4-1-ROC分析\" class=\"headerlink\" title=\"4.1. ROC分析\"></a>4.1. ROC分析</h2><p>关于ROC，先看下图，<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ff7b13d768029291632ed1196d4729e41f30d371/MachineLearning/ROC.jpg\" alt=\"ROC\"></p>\n<p>根据刚刚上面对TPR，FPR的分析，容易发现:</p>\n<ul>\n<li>在（0,0）点，TP和FP都为0（FN和TN都为1），也就是说，对于所有值，预测模型都预测为Negative，即判断为Positive的阈值过高。</li>\n<li>在（1,1）点，TP和FP都为1（FN和TN都为0），也就是说，对于所有值，预测模型都预测为Positive，即判断为Positive的阈值过低。</li>\n</ul>\n<h2 id=\"4-2-AUC分析\"><a href=\"#4-2-AUC分析\" class=\"headerlink\" title=\"4.2. AUC分析\"></a>4.2. AUC分析</h2><p>AUC（Area Under Curve），我觉得原名应为（Area Under roc Curve）更好，其定义为ROC曲线下的面积，面积的数值不会大于1。<br>ROC曲线一般都处于$y=x$这条直线的上方，没有人希望模型在$y=x$的线以下，所以AUC的取值范围在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，但对应一个数据来说，AUC往往越大越好。</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>[1]百度百科:<a href=\"https://baike.baidu.com/item/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/10087822?fr=aladdin&amp;fromid=18082441&amp;fromtitle=Confusion+Matrix\" target=\"_blank\" rel=\"external\">https://baike.baidu.com/item/%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5/10087822?fr=aladdin&amp;fromid=18082441&amp;fromtitle=Confusion+Matrix</a><br>[2]维基百科:<a href=\"https://en.wikipedia.org/wiki/Confusion_matrix\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Confusion_matrix</a><br>[3]精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？<a href=\"https://www.zhihu.com/question/30643044/answer/48955833\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/30643044/answer/48955833</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Helpful Visualization Tutorial","date":"2018-08-17T05:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n[Python Data Science Handbook by Jake VanderPlas](https://www.safaribooksonline.com/library/view/python-data-science/9781491912126/ch04.html)\n[Python可视化神器Seaborn入门系列(一)——kdeplot和distplot](https://zhuanlan.zhihu.com/p/34354510)","source":"_posts/Visualization/2018-08-17-helpful_visualization_tutorial.md","raw":"---\ntitle:  Helpful Visualization Tutorial\ndate: 2018-08-17 13:23:19\ncategories: [Visualization]\ntags: [Visualization]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n[Python Data Science Handbook by Jake VanderPlas](https://www.safaribooksonline.com/library/view/python-data-science/9781491912126/ch04.html)\n[Python可视化神器Seaborn入门系列(一)——kdeplot和distplot](https://zhuanlan.zhihu.com/p/34354510)","slug":"Visualization/2018-08-17-helpful_visualization_tutorial","published":1,"updated":"2018-10-27T04:30:42.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0be000we0ow7nusv3qv","content":"<p><a href=\"https://www.safaribooksonline.com/library/view/python-data-science/9781491912126/ch04.html\" target=\"_blank\" rel=\"external\">Python Data Science Handbook by Jake VanderPlas</a><br><a href=\"https://zhuanlan.zhihu.com/p/34354510\" target=\"_blank\" rel=\"external\">Python可视化神器Seaborn入门系列(一)——kdeplot和distplot</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.safaribooksonline.com/library/view/python-data-science/9781491912126/ch04.html\" target=\"_blank\" rel=\"external\">Python Data Science Handbook by Jake VanderPlas</a><br><a href=\"https://zhuanlan.zhihu.com/p/34354510\" target=\"_blank\" rel=\"external\">Python可视化神器Seaborn入门系列(一)——kdeplot和distplot</a></p>\n"},{"title":"0.Machine learning Foundation - Table of Contents","date":"2017-10-01T03:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n# 机器学习基石(Machine learning Foundation) - Table of Contents\n\n> 这系列博客是基于台湾大学的林轩田教授的机器学习基石，自己加以整理的学习笔记。\n\n## 为什么选这个教程?\n\n> 网上大部分人都是推荐Andrew Ng教授的机器学习，但是对比之后我觉得各有优劣，Ng的课程更适合没有任何基础的学生，算法没有讲的很深，相比之下，Hsuan-Tien Lin的教程遵循着：例子引入知识点，知识点基础简介，算法深入，讲解实例的方式。这种方法更适合我。\n\n来自林轩田教授的教学PPT的文件会在图片后加以说明\n\n# Roadmap of this course\n- When can machine learning? (illustrative + technical)\n- Why can machine learn? (theoretical + illustrative)\n- How can machine learn? (technical + practical)\n- How can machine learn better (practical + theoretical)\n\n\n# 各章节目录\n[1. 机器学习基石-When can Machine Learn? - The Learning Problem](https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/)\n\n[2. 机器学习基石-When can Machine Learn? - Learning to Answer Yes or No](https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/)\n\n[3. 机器学习基石-When can Machine Learn? - Types of Learning](https://zhichengmle.github.io/2017/10/04/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-04-3.When%20can%20Machine%20Learn%20-%20Types%20of%20Learning/)\n\n[4. 机器学习基石-When can Machine Learn? - Feasible of Learning](https://zhichengmle.github.io/2017/10/06/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-06-4.When%20can%20Machine%20Learn%20-%20Feasible%20of%20Learning/)\n\n[5. 机器学习基石-Why can Machine Learn?](https://zhichengmle.github.io/2017/10/08/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-08-5.Why%20Can%20Machine%20Learn/)\n\n[6. 机器学习基石-Why can Machine Learn? - Noice and Error](https://zhichengmle.github.io/2017/10/09/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-09-6.How%20can%20Machine%20Learn%20-%20Noice%20and%20Error/)\n\n[7. 机器学习基石-How can Machine Learn? - Linear Regression](https://zhichengmle.github.io/2017/10/11/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-11-7.How%20can%20Machine%20Learn%20-%20Linear%20Regression/)\n\n[8. 机器学习基石-How can Machine Learn? - Logistic Regression](https://zhichengmle.github.io/2017/10/13/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-13-8.How%20can%20Machine%20Learn%20-%20Logistic%20Regression/)\n\n[9. 机器学习基石-How can Machine Learn? - Linear Model for Classification](https://zhichengmle.github.io/2017/10/14/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-14-9.How%20can%20Machine%20Learn%20-%20Linear%20Model%20for%20Classification/)\n\n[10. 机器学习基石-How can Machine Learn? - Nonlinear Transformation](https://zhichengmle.github.io/2017/10/15/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-15-10.How%20can%20Machine%20Learn%20-%20Nonlinear%20Transformation/)\n\n[11. 机器学习基石-How can Machine Learn Better? - Overfitting and Solution](https://zhichengmle.github.io/2017/10/16/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-16-11.How%20can%20Machine%20Learn%20Better%20-%20Overfitting%20and%20Solution/)\n\n[12. 机器学习基石-How can Machine Learn Better? - Regularization](https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/)\n\n[13. 机器学习基石-How can Machine Learn Better? - Validation](https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/)\n\n[14. 机器学习基石-How can Machine Learn Better? - Three Learning Principles](https://zhichengmle.github.io/2017/10/21/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-21-14.How%20can%20Machine%20Learn%20Better%20-%20Three%20Learning%20Principles/)\n\n[15. 机器学习基石 - Summary - Power of Three](https://zhichengmle.github.io/2017/10/22/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-22-15.Summary%20-%20Power%20of%20Three/)\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-01-0.Machine Learning Foundation - Table of Contents.md","raw":"---\ntitle: 0.Machine learning Foundation - Table of Contents\ndate: 2017-10-01 11:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n# 机器学习基石(Machine learning Foundation) - Table of Contents\n\n> 这系列博客是基于台湾大学的林轩田教授的机器学习基石，自己加以整理的学习笔记。\n\n## 为什么选这个教程?\n\n> 网上大部分人都是推荐Andrew Ng教授的机器学习，但是对比之后我觉得各有优劣，Ng的课程更适合没有任何基础的学生，算法没有讲的很深，相比之下，Hsuan-Tien Lin的教程遵循着：例子引入知识点，知识点基础简介，算法深入，讲解实例的方式。这种方法更适合我。\n\n来自林轩田教授的教学PPT的文件会在图片后加以说明\n\n# Roadmap of this course\n- When can machine learning? (illustrative + technical)\n- Why can machine learn? (theoretical + illustrative)\n- How can machine learn? (technical + practical)\n- How can machine learn better (practical + theoretical)\n\n\n# 各章节目录\n[1. 机器学习基石-When can Machine Learn? - The Learning Problem](https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/)\n\n[2. 机器学习基石-When can Machine Learn? - Learning to Answer Yes or No](https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/)\n\n[3. 机器学习基石-When can Machine Learn? - Types of Learning](https://zhichengmle.github.io/2017/10/04/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-04-3.When%20can%20Machine%20Learn%20-%20Types%20of%20Learning/)\n\n[4. 机器学习基石-When can Machine Learn? - Feasible of Learning](https://zhichengmle.github.io/2017/10/06/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-06-4.When%20can%20Machine%20Learn%20-%20Feasible%20of%20Learning/)\n\n[5. 机器学习基石-Why can Machine Learn?](https://zhichengmle.github.io/2017/10/08/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-08-5.Why%20Can%20Machine%20Learn/)\n\n[6. 机器学习基石-Why can Machine Learn? - Noice and Error](https://zhichengmle.github.io/2017/10/09/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-09-6.How%20can%20Machine%20Learn%20-%20Noice%20and%20Error/)\n\n[7. 机器学习基石-How can Machine Learn? - Linear Regression](https://zhichengmle.github.io/2017/10/11/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-11-7.How%20can%20Machine%20Learn%20-%20Linear%20Regression/)\n\n[8. 机器学习基石-How can Machine Learn? - Logistic Regression](https://zhichengmle.github.io/2017/10/13/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-13-8.How%20can%20Machine%20Learn%20-%20Logistic%20Regression/)\n\n[9. 机器学习基石-How can Machine Learn? - Linear Model for Classification](https://zhichengmle.github.io/2017/10/14/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-14-9.How%20can%20Machine%20Learn%20-%20Linear%20Model%20for%20Classification/)\n\n[10. 机器学习基石-How can Machine Learn? - Nonlinear Transformation](https://zhichengmle.github.io/2017/10/15/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-15-10.How%20can%20Machine%20Learn%20-%20Nonlinear%20Transformation/)\n\n[11. 机器学习基石-How can Machine Learn Better? - Overfitting and Solution](https://zhichengmle.github.io/2017/10/16/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-16-11.How%20can%20Machine%20Learn%20Better%20-%20Overfitting%20and%20Solution/)\n\n[12. 机器学习基石-How can Machine Learn Better? - Regularization](https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/)\n\n[13. 机器学习基石-How can Machine Learn Better? - Validation](https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/)\n\n[14. 机器学习基石-How can Machine Learn Better? - Three Learning Principles](https://zhichengmle.github.io/2017/10/21/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-21-14.How%20can%20Machine%20Learn%20Better%20-%20Three%20Learning%20Principles/)\n\n[15. 机器学习基石 - Summary - Power of Three](https://zhichengmle.github.io/2017/10/22/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-22-15.Summary%20-%20Power%20of%20Three/)\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-01-0.Machine Learning Foundation - Table of Contents","published":1,"updated":"2018-10-27T04:30:42.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bf0010e0owye60ddf0","content":"<h1 id=\"机器学习基石-Machine-learning-Foundation-Table-of-Contents\"><a href=\"#机器学习基石-Machine-learning-Foundation-Table-of-Contents\" class=\"headerlink\" title=\"机器学习基石(Machine learning Foundation) - Table of Contents\"></a>机器学习基石(Machine learning Foundation) - Table of Contents</h1><blockquote>\n<p>这系列博客是基于台湾大学的林轩田教授的机器学习基石，自己加以整理的学习笔记。</p>\n</blockquote>\n<h2 id=\"为什么选这个教程\"><a href=\"#为什么选这个教程\" class=\"headerlink\" title=\"为什么选这个教程?\"></a>为什么选这个教程?</h2><blockquote>\n<p>网上大部分人都是推荐Andrew Ng教授的机器学习，但是对比之后我觉得各有优劣，Ng的课程更适合没有任何基础的学生，算法没有讲的很深，相比之下，Hsuan-Tien Lin的教程遵循着：例子引入知识点，知识点基础简介，算法深入，讲解实例的方式。这种方法更适合我。</p>\n</blockquote>\n<p>来自林轩田教授的教学PPT的文件会在图片后加以说明</p>\n<h1 id=\"Roadmap-of-this-course\"><a href=\"#Roadmap-of-this-course\" class=\"headerlink\" title=\"Roadmap of this course\"></a>Roadmap of this course</h1><ul>\n<li>When can machine learning? (illustrative + technical)</li>\n<li>Why can machine learn? (theoretical + illustrative)</li>\n<li>How can machine learn? (technical + practical)</li>\n<li>How can machine learn better (practical + theoretical)</li>\n</ul>\n<h1 id=\"各章节目录\"><a href=\"#各章节目录\" class=\"headerlink\" title=\"各章节目录\"></a>各章节目录</h1><p><a href=\"https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/\">1. 机器学习基石-When can Machine Learn? - The Learning Problem</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/\">2. 机器学习基石-When can Machine Learn? - Learning to Answer Yes or No</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/04/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-04-3.When%20can%20Machine%20Learn%20-%20Types%20of%20Learning/\">3. 机器学习基石-When can Machine Learn? - Types of Learning</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/06/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-06-4.When%20can%20Machine%20Learn%20-%20Feasible%20of%20Learning/\">4. 机器学习基石-When can Machine Learn? - Feasible of Learning</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/08/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-08-5.Why%20Can%20Machine%20Learn/\">5. 机器学习基石-Why can Machine Learn?</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/09/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-09-6.How%20can%20Machine%20Learn%20-%20Noice%20and%20Error/\">6. 机器学习基石-Why can Machine Learn? - Noice and Error</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/11/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-11-7.How%20can%20Machine%20Learn%20-%20Linear%20Regression/\">7. 机器学习基石-How can Machine Learn? - Linear Regression</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/13/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-13-8.How%20can%20Machine%20Learn%20-%20Logistic%20Regression/\">8. 机器学习基石-How can Machine Learn? - Logistic Regression</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/14/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-14-9.How%20can%20Machine%20Learn%20-%20Linear%20Model%20for%20Classification/\">9. 机器学习基石-How can Machine Learn? - Linear Model for Classification</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/15/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-15-10.How%20can%20Machine%20Learn%20-%20Nonlinear%20Transformation/\">10. 机器学习基石-How can Machine Learn? - Nonlinear Transformation</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/16/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-16-11.How%20can%20Machine%20Learn%20Better%20-%20Overfitting%20and%20Solution/\">11. 机器学习基石-How can Machine Learn Better? - Overfitting and Solution</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/\">12. 机器学习基石-How can Machine Learn Better? - Regularization</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/\">13. 机器学习基石-How can Machine Learn Better? - Validation</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/21/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-21-14.How%20can%20Machine%20Learn%20Better%20-%20Three%20Learning%20Principles/\">14. 机器学习基石-How can Machine Learn Better? - Three Learning Principles</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/22/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-22-15.Summary%20-%20Power%20of%20Three/\">15. 机器学习基石 - Summary - Power of Three</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"机器学习基石-Machine-learning-Foundation-Table-of-Contents\"><a href=\"#机器学习基石-Machine-learning-Foundation-Table-of-Contents\" class=\"headerlink\" title=\"机器学习基石(Machine learning Foundation) - Table of Contents\"></a>机器学习基石(Machine learning Foundation) - Table of Contents</h1><blockquote>\n<p>这系列博客是基于台湾大学的林轩田教授的机器学习基石，自己加以整理的学习笔记。</p>\n</blockquote>\n<h2 id=\"为什么选这个教程\"><a href=\"#为什么选这个教程\" class=\"headerlink\" title=\"为什么选这个教程?\"></a>为什么选这个教程?</h2><blockquote>\n<p>网上大部分人都是推荐Andrew Ng教授的机器学习，但是对比之后我觉得各有优劣，Ng的课程更适合没有任何基础的学生，算法没有讲的很深，相比之下，Hsuan-Tien Lin的教程遵循着：例子引入知识点，知识点基础简介，算法深入，讲解实例的方式。这种方法更适合我。</p>\n</blockquote>\n<p>来自林轩田教授的教学PPT的文件会在图片后加以说明</p>\n<h1 id=\"Roadmap-of-this-course\"><a href=\"#Roadmap-of-this-course\" class=\"headerlink\" title=\"Roadmap of this course\"></a>Roadmap of this course</h1><ul>\n<li>When can machine learning? (illustrative + technical)</li>\n<li>Why can machine learn? (theoretical + illustrative)</li>\n<li>How can machine learn? (technical + practical)</li>\n<li>How can machine learn better (practical + theoretical)</li>\n</ul>\n<h1 id=\"各章节目录\"><a href=\"#各章节目录\" class=\"headerlink\" title=\"各章节目录\"></a>各章节目录</h1><p><a href=\"https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/\">1. 机器学习基石-When can Machine Learn? - The Learning Problem</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/02/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-02-1.When%20can%20Machine%20Learn%20-%20The%20Learning%20Problem/\">2. 机器学习基石-When can Machine Learn? - Learning to Answer Yes or No</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/04/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-04-3.When%20can%20Machine%20Learn%20-%20Types%20of%20Learning/\">3. 机器学习基石-When can Machine Learn? - Types of Learning</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/06/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-06-4.When%20can%20Machine%20Learn%20-%20Feasible%20of%20Learning/\">4. 机器学习基石-When can Machine Learn? - Feasible of Learning</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/08/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-08-5.Why%20Can%20Machine%20Learn/\">5. 机器学习基石-Why can Machine Learn?</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/09/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-09-6.How%20can%20Machine%20Learn%20-%20Noice%20and%20Error/\">6. 机器学习基石-Why can Machine Learn? - Noice and Error</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/11/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-11-7.How%20can%20Machine%20Learn%20-%20Linear%20Regression/\">7. 机器学习基石-How can Machine Learn? - Linear Regression</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/13/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-13-8.How%20can%20Machine%20Learn%20-%20Logistic%20Regression/\">8. 机器学习基石-How can Machine Learn? - Logistic Regression</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/14/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-14-9.How%20can%20Machine%20Learn%20-%20Linear%20Model%20for%20Classification/\">9. 机器学习基石-How can Machine Learn? - Linear Model for Classification</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/15/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-15-10.How%20can%20Machine%20Learn%20-%20Nonlinear%20Transformation/\">10. 机器学习基石-How can Machine Learn? - Nonlinear Transformation</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/16/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-16-11.How%20can%20Machine%20Learn%20Better%20-%20Overfitting%20and%20Solution/\">11. 机器学习基石-How can Machine Learn Better? - Overfitting and Solution</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/\">12. 机器学习基石-How can Machine Learn Better? - Regularization</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/\">13. 机器学习基石-How can Machine Learn Better? - Validation</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/21/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-21-14.How%20can%20Machine%20Learn%20Better%20-%20Three%20Learning%20Principles/\">14. 机器学习基石-How can Machine Learn Better? - Three Learning Principles</a></p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/22/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-22-15.Summary%20-%20Power%20of%20Three/\">15. 机器学习基石 - Summary - Power of Three</a></p>\n"},{"title":"1.When can Machine Learn? - The Learning Problem","date":"2017-10-02T08:03:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# When can Machine Learn? - The Learning Problem\n\n## 1. The Learning Problem\nTo figure this out, we need to compare Human Learning and Machine Learning.\n\n### 1) Human Learning and Machine Learning\n\n#### ① Human Learning\nHuman learning means people learn from perception (E.g., observation, touching, hearing).\n\n#### ② Machine Learning\nLike human learning, machine learning means that machine learn things by collecting data, then computing the data to get skills.\n\n#### ③ Summary\n![Human Learning and Machine Learning](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a8ff8cec23221b4da00516a4de437336adfb1653/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-1%20When%20can%20machine%20learn-machine%20learning%20vs%20human%20learning-cropped.jpg)\n\n### 2) Human Learning V.S. Machine Learning\n既然人类和机器学习的过程一样，为什么我们还要耗费精力去让机器可以学习呢？\n- 一些数据或者信息，人类难以识别；\n- 学习的数据量特别大，人脑难以处理\n- 人脑处理问题的速度很慢，但是很多情况下要求系统能快速的给出答案\n\n<br>\n\n总结如下表：\n\n|      | Human Learning                                | Machine Learning                               |\n| ---- | --------------------------------------------- | ---------------------------------------------- |\n| Pros | Learn emotionally and skillfully              | Processing big data                            |\n| Cons | Cannot dealing with big data, cannot act fast | Cannot work with human programming, no emotion |\n\n### 3) Key to Machine Learning\n不是所以情况都可以使用机器学习，必须满足一下3个关键条件：\n- 存在一个模型，能让我们对它进行改进。（不需要改进，就不需要进行ML了）\n- 规则不容易找出。（如果太简单的话，用ML反而使得其反，耗费了人力物力）\n- 需要有数据的支持，且数据量理论上越大越好。（这给机器学习提供了保证，后面会介绍）\n\n------------------------------------------\n<br>\n<br>\n\n## 2. Application of Machine Learning\nMachine Learning actually can apply to everything.\n\nE.g.,\n\n- Daily need\n   - Food\n      - How does the food taste?\n      - How many chances that some specific people will like the food?\n      - ...\n   - Clothing\n      - The information of the clothing.\n      - Fashion recommendation\n      - ...\n   - Housing\n      - Energy load\n      - Sell price\n      - ...\n   - Transportation\n      - Driving automation\n      - Transportation times\n      - Traffic jam possibilities\n      - ...\n- Education\n   - Math tutoring system.\n   - Quiz generator\n   - ...\n- Entertaining\n   - Recommendation system\n   - Real view experiencing of traveling\n\n\n------------------------------------------\n<br>\n<br>\n\n## 3. Components of Machine Learning\n\n> 以银行是否应该对客户发放信用卡作为例子\n\n### 1) Basic Notation\n\n![Basic Notation](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b871ce6fb178e7433d1565e2b0a1791c11d8d39a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-2%20Basic%20Notation.png)\n<center>Basic Notation<sup>[1]</sup></center>\n\n\n\n\n1.输入(input)：$x∈X$（代表银行所掌握的用户信息）\n\n2.输出(output)：$y∈Y$ （是否会发信用卡给用户）\n\n3.未知的函数，即目标函数（target function）：$f：X→Y$（理想的信用卡发放公式）\n\n4.数据或者叫做资料（ data），即训练样本（ training examples）：$D = {（x_1, y_1）, (x_2, y_2), …, (x_n, y_n)}$（银行的历史记录）\n\n5.假设（hypothesis），根据训练样本得到的实际的函数：$g：X→Y$\n\n\n### 2) Practical Definition\n![Practical Definition](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c5e0095cd06f69646a45c981a77c9bcb8033535a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-3%20Practical%20Definition%20of%20Machine%20Learning.png)\n<center>Practical Definition<sup>[1]</sup></center>\n\n机器学习算法（learning algorithm）一般用$A$表示。还多出来一个新的项目，就是假设空间或者叫做假设集合（hypothesis set）一般用$H$表示，而这时$A$的作用就是从$H$集合中挑选出它认为最好的假设从而得到函数$g$。\n\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## 4. Machine Learning and Other Fields\n> Machine Learning VS Data Mining, Artificial Intelligence, Statistic\n\n### 1) Machine Learning V.S. Data Mining\n机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。\n- 两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。\n- 两者是互助的：ML需要大数据的支持才能保持能“学到东西”。\n- 数据挖掘更关注于从大量的数据中的计算问题。\n总的来时，两者密不可分。\n\n### 2) Machine Learning V.S. Artificial Intelligence\nAI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式\n\n### 3) Machine Learning V.S. Statistic\n统计是通过对已知数据的处理，从而推断出未知的事件的属性\n所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。\n\n\n------------------------------------------\n<br>\n<br>\n\n# Summary\n1. 机器学习类似于人类的学习\n2. 机器学习的应用很广，可以说应用领域是各行各业\n3. 机器学习包含：输入数据，输出结果，目标函数，假设函数 ，数据集\n4. 机器学习ML与AI，DM， Statistics有关系， ML∈AI, ML≈DM, ML使用Statistics\n\n总的来说，机器学习的任务是找出一个假设函数 $g(x)$ ，使得假设 $g(x)$ 和目标函数 $f(x)$ 很接近，即 $g(x) \\approx f(x)$, 用第四章的概念可以解释为在测试时的错误率接近零 $E_{out} \\approx 0$\n\n------------------------------------------\n<br>\n<br>\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\1\\1 - 4 - Components of Machine Learning (11-45)\n\n<br><br>\n--------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-02-1.When can Machine Learn - The Learning Problem.md","raw":"---\ntitle: 1.When can Machine Learn? - The Learning Problem\ndate: 2017-10-02 16:03:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# When can Machine Learn? - The Learning Problem\n\n## 1. The Learning Problem\nTo figure this out, we need to compare Human Learning and Machine Learning.\n\n### 1) Human Learning and Machine Learning\n\n#### ① Human Learning\nHuman learning means people learn from perception (E.g., observation, touching, hearing).\n\n#### ② Machine Learning\nLike human learning, machine learning means that machine learn things by collecting data, then computing the data to get skills.\n\n#### ③ Summary\n![Human Learning and Machine Learning](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a8ff8cec23221b4da00516a4de437336adfb1653/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-1%20When%20can%20machine%20learn-machine%20learning%20vs%20human%20learning-cropped.jpg)\n\n### 2) Human Learning V.S. Machine Learning\n既然人类和机器学习的过程一样，为什么我们还要耗费精力去让机器可以学习呢？\n- 一些数据或者信息，人类难以识别；\n- 学习的数据量特别大，人脑难以处理\n- 人脑处理问题的速度很慢，但是很多情况下要求系统能快速的给出答案\n\n<br>\n\n总结如下表：\n\n|      | Human Learning                                | Machine Learning                               |\n| ---- | --------------------------------------------- | ---------------------------------------------- |\n| Pros | Learn emotionally and skillfully              | Processing big data                            |\n| Cons | Cannot dealing with big data, cannot act fast | Cannot work with human programming, no emotion |\n\n### 3) Key to Machine Learning\n不是所以情况都可以使用机器学习，必须满足一下3个关键条件：\n- 存在一个模型，能让我们对它进行改进。（不需要改进，就不需要进行ML了）\n- 规则不容易找出。（如果太简单的话，用ML反而使得其反，耗费了人力物力）\n- 需要有数据的支持，且数据量理论上越大越好。（这给机器学习提供了保证，后面会介绍）\n\n------------------------------------------\n<br>\n<br>\n\n## 2. Application of Machine Learning\nMachine Learning actually can apply to everything.\n\nE.g.,\n\n- Daily need\n   - Food\n      - How does the food taste?\n      - How many chances that some specific people will like the food?\n      - ...\n   - Clothing\n      - The information of the clothing.\n      - Fashion recommendation\n      - ...\n   - Housing\n      - Energy load\n      - Sell price\n      - ...\n   - Transportation\n      - Driving automation\n      - Transportation times\n      - Traffic jam possibilities\n      - ...\n- Education\n   - Math tutoring system.\n   - Quiz generator\n   - ...\n- Entertaining\n   - Recommendation system\n   - Real view experiencing of traveling\n\n\n------------------------------------------\n<br>\n<br>\n\n## 3. Components of Machine Learning\n\n> 以银行是否应该对客户发放信用卡作为例子\n\n### 1) Basic Notation\n\n![Basic Notation](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b871ce6fb178e7433d1565e2b0a1791c11d8d39a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-2%20Basic%20Notation.png)\n<center>Basic Notation<sup>[1]</sup></center>\n\n\n\n\n1.输入(input)：$x∈X$（代表银行所掌握的用户信息）\n\n2.输出(output)：$y∈Y$ （是否会发信用卡给用户）\n\n3.未知的函数，即目标函数（target function）：$f：X→Y$（理想的信用卡发放公式）\n\n4.数据或者叫做资料（ data），即训练样本（ training examples）：$D = {（x_1, y_1）, (x_2, y_2), …, (x_n, y_n)}$（银行的历史记录）\n\n5.假设（hypothesis），根据训练样本得到的实际的函数：$g：X→Y$\n\n\n### 2) Practical Definition\n![Practical Definition](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c5e0095cd06f69646a45c981a77c9bcb8033535a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-3%20Practical%20Definition%20of%20Machine%20Learning.png)\n<center>Practical Definition<sup>[1]</sup></center>\n\n机器学习算法（learning algorithm）一般用$A$表示。还多出来一个新的项目，就是假设空间或者叫做假设集合（hypothesis set）一般用$H$表示，而这时$A$的作用就是从$H$集合中挑选出它认为最好的假设从而得到函数$g$。\n\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## 4. Machine Learning and Other Fields\n> Machine Learning VS Data Mining, Artificial Intelligence, Statistic\n\n### 1) Machine Learning V.S. Data Mining\n机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。\n- 两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。\n- 两者是互助的：ML需要大数据的支持才能保持能“学到东西”。\n- 数据挖掘更关注于从大量的数据中的计算问题。\n总的来时，两者密不可分。\n\n### 2) Machine Learning V.S. Artificial Intelligence\nAI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式\n\n### 3) Machine Learning V.S. Statistic\n统计是通过对已知数据的处理，从而推断出未知的事件的属性\n所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。\n\n\n------------------------------------------\n<br>\n<br>\n\n# Summary\n1. 机器学习类似于人类的学习\n2. 机器学习的应用很广，可以说应用领域是各行各业\n3. 机器学习包含：输入数据，输出结果，目标函数，假设函数 ，数据集\n4. 机器学习ML与AI，DM， Statistics有关系， ML∈AI, ML≈DM, ML使用Statistics\n\n总的来说，机器学习的任务是找出一个假设函数 $g(x)$ ，使得假设 $g(x)$ 和目标函数 $f(x)$ 很接近，即 $g(x) \\approx f(x)$, 用第四章的概念可以解释为在测试时的错误率接近零 $E_{out} \\approx 0$\n\n------------------------------------------\n<br>\n<br>\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\1\\1 - 4 - Components of Machine Learning (11-45)\n\n<br><br>\n--------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-02-1.When can Machine Learn - The Learning Problem","published":1,"updated":"2018-10-27T04:30:42.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bh0011e0owplnwkpkg","content":"<h1 id=\"When-can-Machine-Learn-The-Learning-Problem\"><a href=\"#When-can-Machine-Learn-The-Learning-Problem\" class=\"headerlink\" title=\"When can Machine Learn? - The Learning Problem\"></a>When can Machine Learn? - The Learning Problem</h1><h2 id=\"1-The-Learning-Problem\"><a href=\"#1-The-Learning-Problem\" class=\"headerlink\" title=\"1. The Learning Problem\"></a>1. The Learning Problem</h2><p>To figure this out, we need to compare Human Learning and Machine Learning.</p>\n<h3 id=\"1-Human-Learning-and-Machine-Learning\"><a href=\"#1-Human-Learning-and-Machine-Learning\" class=\"headerlink\" title=\"1) Human Learning and Machine Learning\"></a>1) Human Learning and Machine Learning</h3><h4 id=\"①-Human-Learning\"><a href=\"#①-Human-Learning\" class=\"headerlink\" title=\"① Human Learning\"></a>① Human Learning</h4><p>Human learning means people learn from perception (E.g., observation, touching, hearing).</p>\n<h4 id=\"②-Machine-Learning\"><a href=\"#②-Machine-Learning\" class=\"headerlink\" title=\"② Machine Learning\"></a>② Machine Learning</h4><p>Like human learning, machine learning means that machine learn things by collecting data, then computing the data to get skills.</p>\n<h4 id=\"③-Summary\"><a href=\"#③-Summary\" class=\"headerlink\" title=\"③ Summary\"></a>③ Summary</h4><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a8ff8cec23221b4da00516a4de437336adfb1653/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-1%20When%20can%20machine%20learn-machine%20learning%20vs%20human%20learning-cropped.jpg\" alt=\"Human Learning and Machine Learning\"></p>\n<h3 id=\"2-Human-Learning-V-S-Machine-Learning\"><a href=\"#2-Human-Learning-V-S-Machine-Learning\" class=\"headerlink\" title=\"2) Human Learning V.S. Machine Learning\"></a>2) Human Learning V.S. Machine Learning</h3><p>既然人类和机器学习的过程一样，为什么我们还要耗费精力去让机器可以学习呢？</p>\n<ul>\n<li>一些数据或者信息，人类难以识别；</li>\n<li>学习的数据量特别大，人脑难以处理</li>\n<li>人脑处理问题的速度很慢，但是很多情况下要求系统能快速的给出答案</li>\n</ul>\n<p><br></p>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Human Learning</th>\n<th>Machine Learning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pros</td>\n<td>Learn emotionally and skillfully</td>\n<td>Processing big data</td>\n</tr>\n<tr>\n<td>Cons</td>\n<td>Cannot dealing with big data, cannot act fast</td>\n<td>Cannot work with human programming, no emotion</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-Key-to-Machine-Learning\"><a href=\"#3-Key-to-Machine-Learning\" class=\"headerlink\" title=\"3) Key to Machine Learning\"></a>3) Key to Machine Learning</h3><p>不是所以情况都可以使用机器学习，必须满足一下3个关键条件：</p>\n<ul>\n<li>存在一个模型，能让我们对它进行改进。（不需要改进，就不需要进行ML了）</li>\n<li>规则不容易找出。（如果太简单的话，用ML反而使得其反，耗费了人力物力）</li>\n<li>需要有数据的支持，且数据量理论上越大越好。（这给机器学习提供了保证，后面会介绍）</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-Application-of-Machine-Learning\"><a href=\"#2-Application-of-Machine-Learning\" class=\"headerlink\" title=\"2. Application of Machine Learning\"></a>2. Application of Machine Learning</h2><p>Machine Learning actually can apply to everything.</p>\n<p>E.g.,</p>\n<ul>\n<li>Daily need<ul>\n<li>Food<ul>\n<li>How does the food taste?</li>\n<li>How many chances that some specific people will like the food?</li>\n<li>…</li>\n</ul>\n</li>\n<li>Clothing<ul>\n<li>The information of the clothing.</li>\n<li>Fashion recommendation</li>\n<li>…</li>\n</ul>\n</li>\n<li>Housing<ul>\n<li>Energy load</li>\n<li>Sell price</li>\n<li>…</li>\n</ul>\n</li>\n<li>Transportation<ul>\n<li>Driving automation</li>\n<li>Transportation times</li>\n<li>Traffic jam possibilities</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Education<ul>\n<li>Math tutoring system.</li>\n<li>Quiz generator</li>\n<li>…</li>\n</ul>\n</li>\n<li>Entertaining<ul>\n<li>Recommendation system</li>\n<li>Real view experiencing of traveling</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"3-Components-of-Machine-Learning\"><a href=\"#3-Components-of-Machine-Learning\" class=\"headerlink\" title=\"3. Components of Machine Learning\"></a>3. Components of Machine Learning</h2><blockquote>\n<p>以银行是否应该对客户发放信用卡作为例子</p>\n</blockquote>\n<h3 id=\"1-Basic-Notation\"><a href=\"#1-Basic-Notation\" class=\"headerlink\" title=\"1) Basic Notation\"></a>1) Basic Notation</h3><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b871ce6fb178e7433d1565e2b0a1791c11d8d39a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-2%20Basic%20Notation.png\" alt=\"Basic Notation\"></p>\n<center>Basic Notation<sup>[1]</sup></center>\n\n\n\n\n<p>1.输入(input)：$x∈X$（代表银行所掌握的用户信息）</p>\n<p>2.输出(output)：$y∈Y$ （是否会发信用卡给用户）</p>\n<p>3.未知的函数，即目标函数（target function）：$f：X→Y$（理想的信用卡发放公式）</p>\n<p>4.数据或者叫做资料（ data），即训练样本（ training examples）：$D = {（x_1, y_1）, (x_2, y_2), …, (x_n, y_n)}$（银行的历史记录）</p>\n<p>5.假设（hypothesis），根据训练样本得到的实际的函数：$g：X→Y$</p>\n<h3 id=\"2-Practical-Definition\"><a href=\"#2-Practical-Definition\" class=\"headerlink\" title=\"2) Practical Definition\"></a>2) Practical Definition</h3><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c5e0095cd06f69646a45c981a77c9bcb8033535a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-3%20Practical%20Definition%20of%20Machine%20Learning.png\" alt=\"Practical Definition\"></p>\n<center>Practical Definition<sup>[1]</sup></center>\n\n<p>机器学习算法（learning algorithm）一般用$A$表示。还多出来一个新的项目，就是假设空间或者叫做假设集合（hypothesis set）一般用$H$表示，而这时$A$的作用就是从$H$集合中挑选出它认为最好的假设从而得到函数$g$。</p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"4-Machine-Learning-and-Other-Fields\"><a href=\"#4-Machine-Learning-and-Other-Fields\" class=\"headerlink\" title=\"4. Machine Learning and Other Fields\"></a>4. Machine Learning and Other Fields</h2><blockquote>\n<p>Machine Learning VS Data Mining, Artificial Intelligence, Statistic</p>\n</blockquote>\n<h3 id=\"1-Machine-Learning-V-S-Data-Mining\"><a href=\"#1-Machine-Learning-V-S-Data-Mining\" class=\"headerlink\" title=\"1) Machine Learning V.S. Data Mining\"></a>1) Machine Learning V.S. Data Mining</h3><p>机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。</p>\n<ul>\n<li>两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。</li>\n<li>两者是互助的：ML需要大数据的支持才能保持能“学到东西”。</li>\n<li>数据挖掘更关注于从大量的数据中的计算问题。<br>总的来时，两者密不可分。</li>\n</ul>\n<h3 id=\"2-Machine-Learning-V-S-Artificial-Intelligence\"><a href=\"#2-Machine-Learning-V-S-Artificial-Intelligence\" class=\"headerlink\" title=\"2) Machine Learning V.S. Artificial Intelligence\"></a>2) Machine Learning V.S. Artificial Intelligence</h3><p>AI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式</p>\n<h3 id=\"3-Machine-Learning-V-S-Statistic\"><a href=\"#3-Machine-Learning-V-S-Statistic\" class=\"headerlink\" title=\"3) Machine Learning V.S. Statistic\"></a>3) Machine Learning V.S. Statistic</h3><p>统计是通过对已知数据的处理，从而推断出未知的事件的属性<br>所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>机器学习类似于人类的学习</li>\n<li>机器学习的应用很广，可以说应用领域是各行各业</li>\n<li>机器学习包含：输入数据，输出结果，目标函数，假设函数 ，数据集</li>\n<li>机器学习ML与AI，DM， Statistics有关系， ML∈AI, ML≈DM, ML使用Statistics</li>\n</ol>\n<p>总的来说，机器学习的任务是找出一个假设函数 $g(x)$ ，使得假设 $g(x)$ 和目标函数 $f(x)$ 很接近，即 $g(x) \\approx f(x)$, 用第四章的概念可以解释为在测试时的错误率接近零 $E_{out} \\approx 0$</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\1\\1 - 4 - Components of Machine Learning (11-45)</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"When-can-Machine-Learn-The-Learning-Problem\"><a href=\"#When-can-Machine-Learn-The-Learning-Problem\" class=\"headerlink\" title=\"When can Machine Learn? - The Learning Problem\"></a>When can Machine Learn? - The Learning Problem</h1><h2 id=\"1-The-Learning-Problem\"><a href=\"#1-The-Learning-Problem\" class=\"headerlink\" title=\"1. The Learning Problem\"></a>1. The Learning Problem</h2><p>To figure this out, we need to compare Human Learning and Machine Learning.</p>\n<h3 id=\"1-Human-Learning-and-Machine-Learning\"><a href=\"#1-Human-Learning-and-Machine-Learning\" class=\"headerlink\" title=\"1) Human Learning and Machine Learning\"></a>1) Human Learning and Machine Learning</h3><h4 id=\"①-Human-Learning\"><a href=\"#①-Human-Learning\" class=\"headerlink\" title=\"① Human Learning\"></a>① Human Learning</h4><p>Human learning means people learn from perception (E.g., observation, touching, hearing).</p>\n<h4 id=\"②-Machine-Learning\"><a href=\"#②-Machine-Learning\" class=\"headerlink\" title=\"② Machine Learning\"></a>② Machine Learning</h4><p>Like human learning, machine learning means that machine learn things by collecting data, then computing the data to get skills.</p>\n<h4 id=\"③-Summary\"><a href=\"#③-Summary\" class=\"headerlink\" title=\"③ Summary\"></a>③ Summary</h4><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a8ff8cec23221b4da00516a4de437336adfb1653/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-1%20When%20can%20machine%20learn-machine%20learning%20vs%20human%20learning-cropped.jpg\" alt=\"Human Learning and Machine Learning\"></p>\n<h3 id=\"2-Human-Learning-V-S-Machine-Learning\"><a href=\"#2-Human-Learning-V-S-Machine-Learning\" class=\"headerlink\" title=\"2) Human Learning V.S. Machine Learning\"></a>2) Human Learning V.S. Machine Learning</h3><p>既然人类和机器学习的过程一样，为什么我们还要耗费精力去让机器可以学习呢？</p>\n<ul>\n<li>一些数据或者信息，人类难以识别；</li>\n<li>学习的数据量特别大，人脑难以处理</li>\n<li>人脑处理问题的速度很慢，但是很多情况下要求系统能快速的给出答案</li>\n</ul>\n<p><br></p>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Human Learning</th>\n<th>Machine Learning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Pros</td>\n<td>Learn emotionally and skillfully</td>\n<td>Processing big data</td>\n</tr>\n<tr>\n<td>Cons</td>\n<td>Cannot dealing with big data, cannot act fast</td>\n<td>Cannot work with human programming, no emotion</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-Key-to-Machine-Learning\"><a href=\"#3-Key-to-Machine-Learning\" class=\"headerlink\" title=\"3) Key to Machine Learning\"></a>3) Key to Machine Learning</h3><p>不是所以情况都可以使用机器学习，必须满足一下3个关键条件：</p>\n<ul>\n<li>存在一个模型，能让我们对它进行改进。（不需要改进，就不需要进行ML了）</li>\n<li>规则不容易找出。（如果太简单的话，用ML反而使得其反，耗费了人力物力）</li>\n<li>需要有数据的支持，且数据量理论上越大越好。（这给机器学习提供了保证，后面会介绍）</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-Application-of-Machine-Learning\"><a href=\"#2-Application-of-Machine-Learning\" class=\"headerlink\" title=\"2. Application of Machine Learning\"></a>2. Application of Machine Learning</h2><p>Machine Learning actually can apply to everything.</p>\n<p>E.g.,</p>\n<ul>\n<li>Daily need<ul>\n<li>Food<ul>\n<li>How does the food taste?</li>\n<li>How many chances that some specific people will like the food?</li>\n<li>…</li>\n</ul>\n</li>\n<li>Clothing<ul>\n<li>The information of the clothing.</li>\n<li>Fashion recommendation</li>\n<li>…</li>\n</ul>\n</li>\n<li>Housing<ul>\n<li>Energy load</li>\n<li>Sell price</li>\n<li>…</li>\n</ul>\n</li>\n<li>Transportation<ul>\n<li>Driving automation</li>\n<li>Transportation times</li>\n<li>Traffic jam possibilities</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Education<ul>\n<li>Math tutoring system.</li>\n<li>Quiz generator</li>\n<li>…</li>\n</ul>\n</li>\n<li>Entertaining<ul>\n<li>Recommendation system</li>\n<li>Real view experiencing of traveling</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"3-Components-of-Machine-Learning\"><a href=\"#3-Components-of-Machine-Learning\" class=\"headerlink\" title=\"3. Components of Machine Learning\"></a>3. Components of Machine Learning</h2><blockquote>\n<p>以银行是否应该对客户发放信用卡作为例子</p>\n</blockquote>\n<h3 id=\"1-Basic-Notation\"><a href=\"#1-Basic-Notation\" class=\"headerlink\" title=\"1) Basic Notation\"></a>1) Basic Notation</h3><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b871ce6fb178e7433d1565e2b0a1791c11d8d39a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-2%20Basic%20Notation.png\" alt=\"Basic Notation\"></p>\n<center>Basic Notation<sup>[1]</sup></center>\n\n\n\n\n<p>1.输入(input)：$x∈X$（代表银行所掌握的用户信息）</p>\n<p>2.输出(output)：$y∈Y$ （是否会发信用卡给用户）</p>\n<p>3.未知的函数，即目标函数（target function）：$f：X→Y$（理想的信用卡发放公式）</p>\n<p>4.数据或者叫做资料（ data），即训练样本（ training examples）：$D = {（x_1, y_1）, (x_2, y_2), …, (x_n, y_n)}$（银行的历史记录）</p>\n<p>5.假设（hypothesis），根据训练样本得到的实际的函数：$g：X→Y$</p>\n<h3 id=\"2-Practical-Definition\"><a href=\"#2-Practical-Definition\" class=\"headerlink\" title=\"2) Practical Definition\"></a>2) Practical Definition</h3><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c5e0095cd06f69646a45c981a77c9bcb8033535a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter1-3%20Practical%20Definition%20of%20Machine%20Learning.png\" alt=\"Practical Definition\"></p>\n<center>Practical Definition<sup>[1]</sup></center>\n\n<p>机器学习算法（learning algorithm）一般用$A$表示。还多出来一个新的项目，就是假设空间或者叫做假设集合（hypothesis set）一般用$H$表示，而这时$A$的作用就是从$H$集合中挑选出它认为最好的假设从而得到函数$g$。</p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"4-Machine-Learning-and-Other-Fields\"><a href=\"#4-Machine-Learning-and-Other-Fields\" class=\"headerlink\" title=\"4. Machine Learning and Other Fields\"></a>4. Machine Learning and Other Fields</h2><blockquote>\n<p>Machine Learning VS Data Mining, Artificial Intelligence, Statistic</p>\n</blockquote>\n<h3 id=\"1-Machine-Learning-V-S-Data-Mining\"><a href=\"#1-Machine-Learning-V-S-Data-Mining\" class=\"headerlink\" title=\"1) Machine Learning V.S. Data Mining\"></a>1) Machine Learning V.S. Data Mining</h3><p>机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。</p>\n<ul>\n<li>两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。</li>\n<li>两者是互助的：ML需要大数据的支持才能保持能“学到东西”。</li>\n<li>数据挖掘更关注于从大量的数据中的计算问题。<br>总的来时，两者密不可分。</li>\n</ul>\n<h3 id=\"2-Machine-Learning-V-S-Artificial-Intelligence\"><a href=\"#2-Machine-Learning-V-S-Artificial-Intelligence\" class=\"headerlink\" title=\"2) Machine Learning V.S. Artificial Intelligence\"></a>2) Machine Learning V.S. Artificial Intelligence</h3><p>AI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式</p>\n<h3 id=\"3-Machine-Learning-V-S-Statistic\"><a href=\"#3-Machine-Learning-V-S-Statistic\" class=\"headerlink\" title=\"3) Machine Learning V.S. Statistic\"></a>3) Machine Learning V.S. Statistic</h3><p>统计是通过对已知数据的处理，从而推断出未知的事件的属性<br>所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>机器学习类似于人类的学习</li>\n<li>机器学习的应用很广，可以说应用领域是各行各业</li>\n<li>机器学习包含：输入数据，输出结果，目标函数，假设函数 ，数据集</li>\n<li>机器学习ML与AI，DM， Statistics有关系， ML∈AI, ML≈DM, ML使用Statistics</li>\n</ol>\n<p>总的来说，机器学习的任务是找出一个假设函数 $g(x)$ ，使得假设 $g(x)$ 和目标函数 $f(x)$ 很接近，即 $g(x) \\approx f(x)$, 用第四章的概念可以解释为在测试时的错误率接近零 $E_{out} \\approx 0$</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\1\\1 - 4 - Components of Machine Learning (11-45)</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"2.When can Machine Learn? - Learning to Answer Yes or No","date":"2017-10-02T23:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# When can Machine Learn? - Learning to Answer Yes or No\n\n## 1. Perceptron Hypothesis Set\n\n> 举例银行发信用卡进行解释\n\n### 1) Perceptron Hypothesis Set\n假设空间Hypothesis Set可以用感知器（Perceptron）表示。这种假设空间的思想就类似考试给的成绩，对每一题给一个特定的分数，即加权值(权重);\n然后再设计一个及格线，即所谓的阈值或门槛值（threshold），如果加权求和的值大于这个阈值就叫符合条件了，即输出1，小于对应的输出-1。\n表示为公式（1）\n\n$$\n\\begin{align}\n&h(x)∈H\n\\\\\n&h(x) = sign(\\sum_{i=1}^d w_ix_i)\n\\end{align}\n\\tag{$1$}\n$$\n\n其中 sign函数表示为取符号，即 sign(正数) = 1， sign（负数） = -1，如公式（2）所示。\n\n$$ sign(x)=\\left\\{\n\\begin{align}\n& +1 \\quad x>0 \\\\\n&-1 \\quad x<0\n\\end{align}\n\\right.\n\\tag{$2$}\n$$\n\n最后将$h(x)$ 与阈值作比较，得到公式（3）。\n$$\nh(x) = sign(\\sum_{i=1}^d w_ix_i - threshold)\n\\tag{$3$}\n$$\n\n### 2) Perceptron Hypothesis Set公式化简\n为了表达方便，可以对$h(x)$做数学上的讲话，如公式（4）所示。\n$$\n\\begin{align}\nh(x) &= sign(\\sum_{i=1}^d w_ix_i - threshold) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - threshold - 1) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - w_0-x_0) \\\\\n&=sign(\\sum_{i=0}^d w_ix_i) \\\\\n&=sign(w^T\\cdot  x)\n\\end{align}\n\\tag{$4$}\n$$\n> 如上所示，将负阈值表示为权值向量中的一项($w_0$)，而对应输入分量则被默认为1，用$x_0$ 最终将公式简化为两个向量内积的形式，其中T表示转置。\n\n\n------------------------------------------\n<br>\n<br>\n\n## 2. Peceptron Learning Algorithm(PLA)\n### 1) Introduction\n#### ① Question\nHypothesis Set $H$包含所有可能的Perceptron，那么具体选用哪一组Perceptron来组合成$g(x)$ 呢?\n\n#### ② Analyze\n- $g(x)$ 和目标函数f越接近越好，但问题是我们不知道f（如果知道了就不需要学习了）\n- 但是我们知道的是样本输入$x$在$f(x)$ 作用下得到的标记$y$。\n\n所以如果我们能使得$g(x)$ 在所有的样本输入中都能够得到跟函数$f(x)$ 作用过输入得到的输出一样的话，我们认为这时的$g(x)$ 是不错的。（在后面的章节还会在这种思想的基础上更深入的讨论这一问题）\n\n#### ③ Solution\n我们想到一个简单的方式，就是一步一步的修正错误的分类，在二维平面中可以想象成一条初始的直线，在经过不断的纠正它的错误（就是旋转平移之类的）使得最终的结果可以达到希望的效果。\n\n还要在重复上一节中已经得到的一个结论，在感知器模型中，每一个假设函数$g(x)$ 都对应一个权值向量。因此我们要做的就是不断修正这个权值向量使得最接近目标函数$f(x)$ 。即PLA算法\n\n------------------------------------------\n<br>\n<br>\n\n### 2) PLA\n#### ① PLA步骤\n首先我们在设置初始$w_0$（注意此处是向量不是向量的分量！），比如设置为0向量，然后使用训练样本来将权值向量修正的更接近目标函数$f(x)$。\n\n通过公式（5）来判断什么时候需要进行修正:\n$$\nsign( w_t^T \\cdot x_{n(t)} \\neq y_{(n)})\n\\tag{$5$}\n$$\n通过公式（6）来进行修正：\n$$\nw_{t+1} = w_t + y_{n(t)} \\cdot x_{n(t)}\n\\tag{$6$}\n$$\n\n#### ② 图示说明\n\n![PLA](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a335a9177d37b3ced5d4763a53f61f3f5b01e0e8/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-1%20PLA.png)\n\n<center>图一 PLA<sup>[1]</sup></center>\n\n>在本身标记为+1时，权值向量和输入向量的内积为负数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。\n\n>在本身标记为-1时，权值向量和输入向量的内积为正数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。\n\n重复查找错误样本和修改加权向量，直到再也找不到可以使公式(5)成立的样本为止，此时得到的加权向量，即为我们想要的最终$g(x)$\n\n具体流程如下图：\n\n![PLA](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/48df8c85a8eb4fd2af3331147cd25401dc2f728a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-2%20PLA%20procedure.jpg)\n\n<center>图二 PLA Procedure<sup>[1]</sup></center>\n\n\n\n> 疑问:如何查找错误样本点，如何确定没有错误的点了?\n\n一个简单的方式就是将训练样本编号，从1到n，以按从1到n的顺序不断查找错误点，如果没有错就自动的用下一个样本点继续查找，当从1到n这n个样本点都没有产生错误时，算法即结束得到$g(x)$ 。将这种方式的算法叫做Cyclic PLA。\n\n>新的疑问:\n>\n> 1.这个算法一定会找到一个能使所有的样本都不符合的情况吗(即是否会停下来)？\n>\n> 2.算法找到的真的是最好的g(x)吗？\n>\n> 3.应用到测试集中，结果还会一样吗？\n>\n> 详见 ③ PLA的理论保证\n\n#### ③ PLA的理论保证\n##### i) 前提条件\n首先很明显，要用一条直线做Binary Classification必须要求数据线性可分，否则不可以分开（想象一刀切）\n如图三：\n\n![Linear Separable](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/45e061db302ad3b6622daa8ecc48f802b861874c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-3%20linear%20seperable.png)\n\n<center>图三 Linear Seperable <sup>[1]</sup></center>\n\n##### ii) 理论推导\n首先PLA的核心是每次修正都让权值的向量$W^T$（T代表在第T次停下）更接近于理想的权值向量$W_f$,如何衡量两个向量的相似程度呢？内积，即对向量$W^T$和$W_f$做内积。\n> 内积的大小与2个向量的方向与大小都有关，所以如果我们直接做内积的话，会受到向量长度的影响，所以要做归一化处理，如公式7\n\n$$\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}}\n\\tag{$7$}\n$$\n\n公式用于衡量两个向量的方向的差别程度，但是怎么处理这个公式呢？\n\n先看分子,有之前的公式（6）我们可以得到公式（8）:\n$$\n{w_f^T \\cdot w_T} \\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)})\n\\tag{$8$}\n$$\n\n如果PLA都会让权值越来越接近理想值，那么由之前的公式（5），我们其实可以推出公式（9）<--(因为$w_f$是最理想的值，那时候应该所有的预测值都和实际相等）和公式（10）<--(因为只有再犯错误的时候才改变，所以$W_t^T$与实际值会不一样):\n$$\ny_{n(t)} w_f^T x_{n(t)} \\geq \\min \\limits_n\\ y_n w_f^T x_n > 0\n\\tag{$9$}\n$$\n$$\ny_{n(t)} w_f^T x_{n(t)} \\leq 0\n\\tag{$10$}\n$$\n\n所以由公式（9），我们可以对公式（8）进一步限制他的范围：\n\n$$\n\\begin{align}\n{w_f^T \\cdot w_T} &\\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-1} + \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-2} + 2 - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  & ... \\\\\n                  &\\geq {w_f^T} w_{0} + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n(w_0 = 0) \\quad   &\\geq 0 + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot  x_{n(T-1)}) \\\\\n                  &\\geq T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\\\\n(\\min \\limits_n\\ y_n w_f^T x_n > 0) \\quad  & > 0\n\\end{align}\n\\tag{$11$}\n$$\n\n公式（10）中，我们关键是要得到\n$$\n{w_f^T \\cdot w_T} > T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)}\n$$\n\n接着，我们来研究分母:除了$w_T$不容易确定之外，$w_T$的L1范式也不容易得出,但是我们可以转换一下，结合公式（8）(10)来进行处理，即公式（12）。\n$$\n\\begin{align}\n{\\lvert \\lvert w_T\\rvert \\rvert} ^ 2 &= {\\lvert \\lvert w_{T-1} + y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2   \\\\\n                                     &= {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 2y_{n(T-1)} w_{T-1} x_{n(T-1)}  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 0  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-2} \\rvert \\rvert} ^ 2 + 2 - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & ... \\\\\n                                     & \\leq {\\lvert \\lvert w_{0} \\rvert \\rvert} ^ 2 + T - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & = T \\cdot \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2\n\\end{align}\n\\tag{$12$}\n$$\n\n到此为止，我们已经把分子的下限和分母的上限都找到了，这时候总体的值就应该大于等于某个值。有公式（11）（12），我们可以推论到公式（13）。\n$$\n\\begin{align}\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}  \\\\\n         & = \\sqrt{T} \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }} \\\\\n         & = \\sqrt(T) \\cdot C\n         \\quad \\quad \\quad(其中 C = \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }})\n\\end{align}\n\\tag{$13$}\n$$\n\n再有归一化之后的内积不可以大于1，所以公式（13）可以加以限制为公式（14)\n\n$$\n\\begin{align}\n1 \\geq\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}\n\\end{align}\n\\tag{$14$}\n$$\n\n求解公式（14）可以得到公式（15）\n\n$$\n\\begin{align}\nT &\\leq \\frac{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 } {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}  \\\\\n  & = \\frac{R^2}{ρ^2}\\\\\n &（其中：R^2 = \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2, \\quad\n                         ρ^2 = {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}\n\\end{align}\n\\tag{$15$}\n$$\n\n>从公式（15）可以看出，T是有上限的，所以可以说明在线性可分的情况下PLA算法最终会停止于T点，找到一个最接近目标函数的target function $g(x)$\n\n\n\n------------------------------------------\n<br>\n<br>\n\n## 3. Non-Separable Data\n### 1) PLA的缺陷\n上面提到的PLA算法是基于线性可分的数据集的，这种算法不实用，有2个原因。\n1. 在机器学习的时候，我们是不知道数据是否可分的，如果不可分，那样PLA不停止怎么办？\n2. 还是与PLA不停止有关，这个时候如果数据集真的线性可分，但是因为数据量太大，跑了很久都没有跑完，怎么办？我们不知道究竟是数据问题，还是数据量太大还没跑完的问题。\n\n所以这时候要求我们改进PLA算法。\n\n\n### 2）实际应用中线性可分多还是线性不可分的数据多？\n线性不可分的数据多：因为实际应用中存在很多噪音（Noise）。而出现噪音的原因有很多种，如：\n- 录入数据的时候出错\n- 采集数据的设备存在误差\n- ...\n\n所以存在噪音的时候，数据集会变成图四那样。\n\n![Noise](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d29c4fbd29627be6829f26874e8d23c2a246be6b/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-4%20Noise.png)\n\n图四 Noise\n\n\n因为噪音占的比例不会很大，所以最终我们还是可以找到犯错率最少的权值向量$w_g$，如公式（16）所示。\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{equation}\n  w_g = \\mathop{\\argmin}_{w}{\\sum_{n=1}^N sign(w^T \\cdot x_n) \\neq y_n}\n\\end{equation}\n\\tag{$16$}\n$$\n\n> 但是这个公式在数学上是NP难问题，我们无法直接求解，于是我们需要找出一种近似的算法来求解这个问题：pocket 算法。\n\n### 3) Pocket 算法\n#### ① Pocket算法原理\n> Pocket 算法属于贪心算法，即如果找到原来的权值更好的权值，才去做修改，否则停止。\n\n流程如下：\n1. 也是随机的初始化一个权值向量\n2. 随机的使用n个点中的一个点去发现是否有错误（此处与cyclic PLA使用的循环方式有所不同，不是按顺序一个一个的查看是否符合条件，而是在n个点中随机的抽取，这种方式可以增加其寻找最优解的速度）\n3. 和PLA一样使用公式2-5进行修正.\n4. 如果有了修正，则计算出刚刚修正过的权值向量和上一个权值向量到底谁犯的错误比较少，将少的保留重复第2步到第4步的动作。\n5. 假如很长时间都没有新的权值向量比当前的权值向量犯错更少，则返回该向量作为函数g。\n\n流程图如下：\n\n![Pocket Algorithm Procedure](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/73b88a89d3618c606f70bb3a6c915acb8686d351/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-5%20Pocket%20Algorithm%20procedure.jpg)\n\n<center> 图五 Pocket Algorithm Procedure </center>\n\n\n#### ②优缺点分析\n优点：Pocket算法不需要考虑数据集是否线性可分，都可以进行\n\n缺点：每有一个错误点，都要遍历整个数据集来获得该店的错误率$e$，所以计算量会很大\n\n\n------------------------------------------\n<br>\n<br>\n\n# Summary\n1. 首先介绍了Binary Classification中最简单的PLA算法\n2. 然后讨论了PLA算法能在某一步之后停下来。\n3. 最后讨论了PLA算法有缺陷：数据必须线性可分。所以根据这个缺点，引用了Pocket算法\n\n------------------------------------------\n<br>\n<br>\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\2\\2 - 2 - Perceptron Learning Algorithm (PLA) (19-46)\n\n\n<br>\n<br>\n------------------------------------------\n\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-03-2.When can Machine Learn - Learning to Answer Yes or No.md","raw":"---\ntitle:  2.When can Machine Learn? - Learning to Answer Yes or No\ndate: 2017-10-03 07:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# When can Machine Learn? - Learning to Answer Yes or No\n\n## 1. Perceptron Hypothesis Set\n\n> 举例银行发信用卡进行解释\n\n### 1) Perceptron Hypothesis Set\n假设空间Hypothesis Set可以用感知器（Perceptron）表示。这种假设空间的思想就类似考试给的成绩，对每一题给一个特定的分数，即加权值(权重);\n然后再设计一个及格线，即所谓的阈值或门槛值（threshold），如果加权求和的值大于这个阈值就叫符合条件了，即输出1，小于对应的输出-1。\n表示为公式（1）\n\n$$\n\\begin{align}\n&h(x)∈H\n\\\\\n&h(x) = sign(\\sum_{i=1}^d w_ix_i)\n\\end{align}\n\\tag{$1$}\n$$\n\n其中 sign函数表示为取符号，即 sign(正数) = 1， sign（负数） = -1，如公式（2）所示。\n\n$$ sign(x)=\\left\\{\n\\begin{align}\n& +1 \\quad x>0 \\\\\n&-1 \\quad x<0\n\\end{align}\n\\right.\n\\tag{$2$}\n$$\n\n最后将$h(x)$ 与阈值作比较，得到公式（3）。\n$$\nh(x) = sign(\\sum_{i=1}^d w_ix_i - threshold)\n\\tag{$3$}\n$$\n\n### 2) Perceptron Hypothesis Set公式化简\n为了表达方便，可以对$h(x)$做数学上的讲话，如公式（4）所示。\n$$\n\\begin{align}\nh(x) &= sign(\\sum_{i=1}^d w_ix_i - threshold) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - threshold - 1) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - w_0-x_0) \\\\\n&=sign(\\sum_{i=0}^d w_ix_i) \\\\\n&=sign(w^T\\cdot  x)\n\\end{align}\n\\tag{$4$}\n$$\n> 如上所示，将负阈值表示为权值向量中的一项($w_0$)，而对应输入分量则被默认为1，用$x_0$ 最终将公式简化为两个向量内积的形式，其中T表示转置。\n\n\n------------------------------------------\n<br>\n<br>\n\n## 2. Peceptron Learning Algorithm(PLA)\n### 1) Introduction\n#### ① Question\nHypothesis Set $H$包含所有可能的Perceptron，那么具体选用哪一组Perceptron来组合成$g(x)$ 呢?\n\n#### ② Analyze\n- $g(x)$ 和目标函数f越接近越好，但问题是我们不知道f（如果知道了就不需要学习了）\n- 但是我们知道的是样本输入$x$在$f(x)$ 作用下得到的标记$y$。\n\n所以如果我们能使得$g(x)$ 在所有的样本输入中都能够得到跟函数$f(x)$ 作用过输入得到的输出一样的话，我们认为这时的$g(x)$ 是不错的。（在后面的章节还会在这种思想的基础上更深入的讨论这一问题）\n\n#### ③ Solution\n我们想到一个简单的方式，就是一步一步的修正错误的分类，在二维平面中可以想象成一条初始的直线，在经过不断的纠正它的错误（就是旋转平移之类的）使得最终的结果可以达到希望的效果。\n\n还要在重复上一节中已经得到的一个结论，在感知器模型中，每一个假设函数$g(x)$ 都对应一个权值向量。因此我们要做的就是不断修正这个权值向量使得最接近目标函数$f(x)$ 。即PLA算法\n\n------------------------------------------\n<br>\n<br>\n\n### 2) PLA\n#### ① PLA步骤\n首先我们在设置初始$w_0$（注意此处是向量不是向量的分量！），比如设置为0向量，然后使用训练样本来将权值向量修正的更接近目标函数$f(x)$。\n\n通过公式（5）来判断什么时候需要进行修正:\n$$\nsign( w_t^T \\cdot x_{n(t)} \\neq y_{(n)})\n\\tag{$5$}\n$$\n通过公式（6）来进行修正：\n$$\nw_{t+1} = w_t + y_{n(t)} \\cdot x_{n(t)}\n\\tag{$6$}\n$$\n\n#### ② 图示说明\n\n![PLA](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a335a9177d37b3ced5d4763a53f61f3f5b01e0e8/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-1%20PLA.png)\n\n<center>图一 PLA<sup>[1]</sup></center>\n\n>在本身标记为+1时，权值向量和输入向量的内积为负数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。\n\n>在本身标记为-1时，权值向量和输入向量的内积为正数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。\n\n重复查找错误样本和修改加权向量，直到再也找不到可以使公式(5)成立的样本为止，此时得到的加权向量，即为我们想要的最终$g(x)$\n\n具体流程如下图：\n\n![PLA](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/48df8c85a8eb4fd2af3331147cd25401dc2f728a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-2%20PLA%20procedure.jpg)\n\n<center>图二 PLA Procedure<sup>[1]</sup></center>\n\n\n\n> 疑问:如何查找错误样本点，如何确定没有错误的点了?\n\n一个简单的方式就是将训练样本编号，从1到n，以按从1到n的顺序不断查找错误点，如果没有错就自动的用下一个样本点继续查找，当从1到n这n个样本点都没有产生错误时，算法即结束得到$g(x)$ 。将这种方式的算法叫做Cyclic PLA。\n\n>新的疑问:\n>\n> 1.这个算法一定会找到一个能使所有的样本都不符合的情况吗(即是否会停下来)？\n>\n> 2.算法找到的真的是最好的g(x)吗？\n>\n> 3.应用到测试集中，结果还会一样吗？\n>\n> 详见 ③ PLA的理论保证\n\n#### ③ PLA的理论保证\n##### i) 前提条件\n首先很明显，要用一条直线做Binary Classification必须要求数据线性可分，否则不可以分开（想象一刀切）\n如图三：\n\n![Linear Separable](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/45e061db302ad3b6622daa8ecc48f802b861874c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-3%20linear%20seperable.png)\n\n<center>图三 Linear Seperable <sup>[1]</sup></center>\n\n##### ii) 理论推导\n首先PLA的核心是每次修正都让权值的向量$W^T$（T代表在第T次停下）更接近于理想的权值向量$W_f$,如何衡量两个向量的相似程度呢？内积，即对向量$W^T$和$W_f$做内积。\n> 内积的大小与2个向量的方向与大小都有关，所以如果我们直接做内积的话，会受到向量长度的影响，所以要做归一化处理，如公式7\n\n$$\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}}\n\\tag{$7$}\n$$\n\n公式用于衡量两个向量的方向的差别程度，但是怎么处理这个公式呢？\n\n先看分子,有之前的公式（6）我们可以得到公式（8）:\n$$\n{w_f^T \\cdot w_T} \\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)})\n\\tag{$8$}\n$$\n\n如果PLA都会让权值越来越接近理想值，那么由之前的公式（5），我们其实可以推出公式（9）<--(因为$w_f$是最理想的值，那时候应该所有的预测值都和实际相等）和公式（10）<--(因为只有再犯错误的时候才改变，所以$W_t^T$与实际值会不一样):\n$$\ny_{n(t)} w_f^T x_{n(t)} \\geq \\min \\limits_n\\ y_n w_f^T x_n > 0\n\\tag{$9$}\n$$\n$$\ny_{n(t)} w_f^T x_{n(t)} \\leq 0\n\\tag{$10$}\n$$\n\n所以由公式（9），我们可以对公式（8）进一步限制他的范围：\n\n$$\n\\begin{align}\n{w_f^T \\cdot w_T} &\\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-1} + \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-2} + 2 - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  & ... \\\\\n                  &\\geq {w_f^T} w_{0} + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n(w_0 = 0) \\quad   &\\geq 0 + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot  x_{n(T-1)}) \\\\\n                  &\\geq T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\\\\n(\\min \\limits_n\\ y_n w_f^T x_n > 0) \\quad  & > 0\n\\end{align}\n\\tag{$11$}\n$$\n\n公式（10）中，我们关键是要得到\n$$\n{w_f^T \\cdot w_T} > T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)}\n$$\n\n接着，我们来研究分母:除了$w_T$不容易确定之外，$w_T$的L1范式也不容易得出,但是我们可以转换一下，结合公式（8）(10)来进行处理，即公式（12）。\n$$\n\\begin{align}\n{\\lvert \\lvert w_T\\rvert \\rvert} ^ 2 &= {\\lvert \\lvert w_{T-1} + y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2   \\\\\n                                     &= {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 2y_{n(T-1)} w_{T-1} x_{n(T-1)}  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 0  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-2} \\rvert \\rvert} ^ 2 + 2 - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & ... \\\\\n                                     & \\leq {\\lvert \\lvert w_{0} \\rvert \\rvert} ^ 2 + T - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & = T \\cdot \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2\n\\end{align}\n\\tag{$12$}\n$$\n\n到此为止，我们已经把分子的下限和分母的上限都找到了，这时候总体的值就应该大于等于某个值。有公式（11）（12），我们可以推论到公式（13）。\n$$\n\\begin{align}\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}  \\\\\n         & = \\sqrt{T} \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }} \\\\\n         & = \\sqrt(T) \\cdot C\n         \\quad \\quad \\quad(其中 C = \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }})\n\\end{align}\n\\tag{$13$}\n$$\n\n再有归一化之后的内积不可以大于1，所以公式（13）可以加以限制为公式（14)\n\n$$\n\\begin{align}\n1 \\geq\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}\n\\end{align}\n\\tag{$14$}\n$$\n\n求解公式（14）可以得到公式（15）\n\n$$\n\\begin{align}\nT &\\leq \\frac{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 } {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}  \\\\\n  & = \\frac{R^2}{ρ^2}\\\\\n &（其中：R^2 = \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2, \\quad\n                         ρ^2 = {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}\n\\end{align}\n\\tag{$15$}\n$$\n\n>从公式（15）可以看出，T是有上限的，所以可以说明在线性可分的情况下PLA算法最终会停止于T点，找到一个最接近目标函数的target function $g(x)$\n\n\n\n------------------------------------------\n<br>\n<br>\n\n## 3. Non-Separable Data\n### 1) PLA的缺陷\n上面提到的PLA算法是基于线性可分的数据集的，这种算法不实用，有2个原因。\n1. 在机器学习的时候，我们是不知道数据是否可分的，如果不可分，那样PLA不停止怎么办？\n2. 还是与PLA不停止有关，这个时候如果数据集真的线性可分，但是因为数据量太大，跑了很久都没有跑完，怎么办？我们不知道究竟是数据问题，还是数据量太大还没跑完的问题。\n\n所以这时候要求我们改进PLA算法。\n\n\n### 2）实际应用中线性可分多还是线性不可分的数据多？\n线性不可分的数据多：因为实际应用中存在很多噪音（Noise）。而出现噪音的原因有很多种，如：\n- 录入数据的时候出错\n- 采集数据的设备存在误差\n- ...\n\n所以存在噪音的时候，数据集会变成图四那样。\n\n![Noise](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d29c4fbd29627be6829f26874e8d23c2a246be6b/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-4%20Noise.png)\n\n图四 Noise\n\n\n因为噪音占的比例不会很大，所以最终我们还是可以找到犯错率最少的权值向量$w_g$，如公式（16）所示。\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{equation}\n  w_g = \\mathop{\\argmin}_{w}{\\sum_{n=1}^N sign(w^T \\cdot x_n) \\neq y_n}\n\\end{equation}\n\\tag{$16$}\n$$\n\n> 但是这个公式在数学上是NP难问题，我们无法直接求解，于是我们需要找出一种近似的算法来求解这个问题：pocket 算法。\n\n### 3) Pocket 算法\n#### ① Pocket算法原理\n> Pocket 算法属于贪心算法，即如果找到原来的权值更好的权值，才去做修改，否则停止。\n\n流程如下：\n1. 也是随机的初始化一个权值向量\n2. 随机的使用n个点中的一个点去发现是否有错误（此处与cyclic PLA使用的循环方式有所不同，不是按顺序一个一个的查看是否符合条件，而是在n个点中随机的抽取，这种方式可以增加其寻找最优解的速度）\n3. 和PLA一样使用公式2-5进行修正.\n4. 如果有了修正，则计算出刚刚修正过的权值向量和上一个权值向量到底谁犯的错误比较少，将少的保留重复第2步到第4步的动作。\n5. 假如很长时间都没有新的权值向量比当前的权值向量犯错更少，则返回该向量作为函数g。\n\n流程图如下：\n\n![Pocket Algorithm Procedure](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/73b88a89d3618c606f70bb3a6c915acb8686d351/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-5%20Pocket%20Algorithm%20procedure.jpg)\n\n<center> 图五 Pocket Algorithm Procedure </center>\n\n\n#### ②优缺点分析\n优点：Pocket算法不需要考虑数据集是否线性可分，都可以进行\n\n缺点：每有一个错误点，都要遍历整个数据集来获得该店的错误率$e$，所以计算量会很大\n\n\n------------------------------------------\n<br>\n<br>\n\n# Summary\n1. 首先介绍了Binary Classification中最简单的PLA算法\n2. 然后讨论了PLA算法能在某一步之后停下来。\n3. 最后讨论了PLA算法有缺陷：数据必须线性可分。所以根据这个缺点，引用了Pocket算法\n\n------------------------------------------\n<br>\n<br>\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\2\\2 - 2 - Perceptron Learning Algorithm (PLA) (19-46)\n\n\n<br>\n<br>\n------------------------------------------\n\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-03-2.When can Machine Learn - Learning to Answer Yes or No","published":1,"updated":"2018-10-27T04:30:42.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bi0015e0owy1wg923m","content":"<h1 id=\"When-can-Machine-Learn-Learning-to-Answer-Yes-or-No\"><a href=\"#When-can-Machine-Learn-Learning-to-Answer-Yes-or-No\" class=\"headerlink\" title=\"When can Machine Learn? - Learning to Answer Yes or No\"></a>When can Machine Learn? - Learning to Answer Yes or No</h1><h2 id=\"1-Perceptron-Hypothesis-Set\"><a href=\"#1-Perceptron-Hypothesis-Set\" class=\"headerlink\" title=\"1. Perceptron Hypothesis Set\"></a>1. Perceptron Hypothesis Set</h2><blockquote>\n<p>举例银行发信用卡进行解释</p>\n</blockquote>\n<h3 id=\"1-Perceptron-Hypothesis-Set-1\"><a href=\"#1-Perceptron-Hypothesis-Set-1\" class=\"headerlink\" title=\"1) Perceptron Hypothesis Set\"></a>1) Perceptron Hypothesis Set</h3><p>假设空间Hypothesis Set可以用感知器（Perceptron）表示。这种假设空间的思想就类似考试给的成绩，对每一题给一个特定的分数，即加权值(权重);<br>然后再设计一个及格线，即所谓的阈值或门槛值（threshold），如果加权求和的值大于这个阈值就叫符合条件了，即输出1，小于对应的输出-1。<br>表示为公式（1）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n&h(x)∈H\n\\\\\n&h(x) = sign(\\sum_{i=1}^d w_ix_i)\n\\end{align}\n\\tag{$1$}</script><p>其中 sign函数表示为取符号，即 sign(正数) = 1， sign（负数） = -1，如公式（2）所示。</p>\n<script type=\"math/tex; mode=display\">sign(x)=\\left\\{\n\\begin{align}\n& +1 \\quad x>0 \\\\\n&-1 \\quad x<0\n\\end{align}\n\\right.\n\\tag{$2$}</script><p>最后将$h(x)$ 与阈值作比较，得到公式（3）。</p>\n<script type=\"math/tex; mode=display\">\nh(x) = sign(\\sum_{i=1}^d w_ix_i - threshold)\n\\tag{$3$}</script><h3 id=\"2-Perceptron-Hypothesis-Set公式化简\"><a href=\"#2-Perceptron-Hypothesis-Set公式化简\" class=\"headerlink\" title=\"2) Perceptron Hypothesis Set公式化简\"></a>2) Perceptron Hypothesis Set公式化简</h3><p>为了表达方便，可以对$h(x)$做数学上的讲话，如公式（4）所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh(x) &= sign(\\sum_{i=1}^d w_ix_i - threshold) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - threshold - 1) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - w_0-x_0) \\\\\n&=sign(\\sum_{i=0}^d w_ix_i) \\\\\n&=sign(w^T\\cdot  x)\n\\end{align}\n\\tag{$4$}</script><blockquote>\n<p>如上所示，将负阈值表示为权值向量中的一项($w_0$)，而对应输入分量则被默认为1，用$x_0$ 最终将公式简化为两个向量内积的形式，其中T表示转置。</p>\n</blockquote>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-Peceptron-Learning-Algorithm-PLA\"><a href=\"#2-Peceptron-Learning-Algorithm-PLA\" class=\"headerlink\" title=\"2. Peceptron Learning Algorithm(PLA)\"></a>2. Peceptron Learning Algorithm(PLA)</h2><h3 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1) Introduction\"></a>1) Introduction</h3><h4 id=\"①-Question\"><a href=\"#①-Question\" class=\"headerlink\" title=\"① Question\"></a>① Question</h4><p>Hypothesis Set $H$包含所有可能的Perceptron，那么具体选用哪一组Perceptron来组合成$g(x)$ 呢?</p>\n<h4 id=\"②-Analyze\"><a href=\"#②-Analyze\" class=\"headerlink\" title=\"② Analyze\"></a>② Analyze</h4><ul>\n<li>$g(x)$ 和目标函数f越接近越好，但问题是我们不知道f（如果知道了就不需要学习了）</li>\n<li>但是我们知道的是样本输入$x$在$f(x)$ 作用下得到的标记$y$。</li>\n</ul>\n<p>所以如果我们能使得$g(x)$ 在所有的样本输入中都能够得到跟函数$f(x)$ 作用过输入得到的输出一样的话，我们认为这时的$g(x)$ 是不错的。（在后面的章节还会在这种思想的基础上更深入的讨论这一问题）</p>\n<h4 id=\"③-Solution\"><a href=\"#③-Solution\" class=\"headerlink\" title=\"③ Solution\"></a>③ Solution</h4><p>我们想到一个简单的方式，就是一步一步的修正错误的分类，在二维平面中可以想象成一条初始的直线，在经过不断的纠正它的错误（就是旋转平移之类的）使得最终的结果可以达到希望的效果。</p>\n<p>还要在重复上一节中已经得到的一个结论，在感知器模型中，每一个假设函数$g(x)$ 都对应一个权值向量。因此我们要做的就是不断修正这个权值向量使得最接近目标函数$f(x)$ 。即PLA算法</p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"2-PLA\"><a href=\"#2-PLA\" class=\"headerlink\" title=\"2) PLA\"></a>2) PLA</h3><h4 id=\"①-PLA步骤\"><a href=\"#①-PLA步骤\" class=\"headerlink\" title=\"① PLA步骤\"></a>① PLA步骤</h4><p>首先我们在设置初始$w_0$（注意此处是向量不是向量的分量！），比如设置为0向量，然后使用训练样本来将权值向量修正的更接近目标函数$f(x)$。</p>\n<p>通过公式（5）来判断什么时候需要进行修正:</p>\n<script type=\"math/tex; mode=display\">\nsign( w_t^T \\cdot x_{n(t)} \\neq y_{(n)})\n\\tag{$5$}</script><p>通过公式（6）来进行修正：</p>\n<script type=\"math/tex; mode=display\">\nw_{t+1} = w_t + y_{n(t)} \\cdot x_{n(t)}\n\\tag{$6$}</script><h4 id=\"②-图示说明\"><a href=\"#②-图示说明\" class=\"headerlink\" title=\"② 图示说明\"></a>② 图示说明</h4><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a335a9177d37b3ced5d4763a53f61f3f5b01e0e8/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-1%20PLA.png\" alt=\"PLA\"></p>\n<center>图一 PLA<sup>[1]</sup></center>\n\n<blockquote>\n<p>在本身标记为+1时，权值向量和输入向量的内积为负数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。</p>\n<p>在本身标记为-1时，权值向量和输入向量的内积为正数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。</p>\n</blockquote>\n<p>重复查找错误样本和修改加权向量，直到再也找不到可以使公式(5)成立的样本为止，此时得到的加权向量，即为我们想要的最终$g(x)$</p>\n<p>具体流程如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/48df8c85a8eb4fd2af3331147cd25401dc2f728a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-2%20PLA%20procedure.jpg\" alt=\"PLA\"></p>\n<center>图二 PLA Procedure<sup>[1]</sup></center>\n\n\n\n<blockquote>\n<p>疑问:如何查找错误样本点，如何确定没有错误的点了?</p>\n</blockquote>\n<p>一个简单的方式就是将训练样本编号，从1到n，以按从1到n的顺序不断查找错误点，如果没有错就自动的用下一个样本点继续查找，当从1到n这n个样本点都没有产生错误时，算法即结束得到$g(x)$ 。将这种方式的算法叫做Cyclic PLA。</p>\n<blockquote>\n<p>新的疑问:</p>\n<p>1.这个算法一定会找到一个能使所有的样本都不符合的情况吗(即是否会停下来)？</p>\n<p>2.算法找到的真的是最好的g(x)吗？</p>\n<p>3.应用到测试集中，结果还会一样吗？</p>\n<p>详见 ③ PLA的理论保证</p>\n</blockquote>\n<h4 id=\"③-PLA的理论保证\"><a href=\"#③-PLA的理论保证\" class=\"headerlink\" title=\"③ PLA的理论保证\"></a>③ PLA的理论保证</h4><h5 id=\"i-前提条件\"><a href=\"#i-前提条件\" class=\"headerlink\" title=\"i) 前提条件\"></a>i) 前提条件</h5><p>首先很明显，要用一条直线做Binary Classification必须要求数据线性可分，否则不可以分开（想象一刀切）<br>如图三：</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/45e061db302ad3b6622daa8ecc48f802b861874c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-3%20linear%20seperable.png\" alt=\"Linear Separable\"></p>\n<center>图三 Linear Seperable <sup>[1]</sup></center>\n\n<h5 id=\"ii-理论推导\"><a href=\"#ii-理论推导\" class=\"headerlink\" title=\"ii) 理论推导\"></a>ii) 理论推导</h5><p>首先PLA的核心是每次修正都让权值的向量$W^T$（T代表在第T次停下）更接近于理想的权值向量$W_f$,如何衡量两个向量的相似程度呢？内积，即对向量$W^T$和$W_f$做内积。</p>\n<blockquote>\n<p>内积的大小与2个向量的方向与大小都有关，所以如果我们直接做内积的话，会受到向量长度的影响，所以要做归一化处理，如公式7</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}}\n\\tag{$7$}</script><p>公式用于衡量两个向量的方向的差别程度，但是怎么处理这个公式呢？</p>\n<p>先看分子,有之前的公式（6）我们可以得到公式（8）:</p>\n<script type=\"math/tex; mode=display\">\n{w_f^T \\cdot w_T} \\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)})\n\\tag{$8$}</script><p>如果PLA都会让权值越来越接近理想值，那么由之前的公式（5），我们其实可以推出公式（9）&lt;—(因为$w_f$是最理想的值，那时候应该所有的预测值都和实际相等）和公式（10）&lt;—(因为只有再犯错误的时候才改变，所以$W_t^T$与实际值会不一样):</p>\n<script type=\"math/tex; mode=display\">\ny_{n(t)} w_f^T x_{n(t)} \\geq \\min \\limits_n\\ y_n w_f^T x_n > 0\n\\tag{$9$}</script><script type=\"math/tex; mode=display\">\ny_{n(t)} w_f^T x_{n(t)} \\leq 0\n\\tag{$10$}</script><p>所以由公式（9），我们可以对公式（8）进一步限制他的范围：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n{w_f^T \\cdot w_T} &\\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-1} + \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-2} + 2 - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  & ... \\\\\n                  &\\geq {w_f^T} w_{0} + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n(w_0 = 0) \\quad   &\\geq 0 + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot  x_{n(T-1)}) \\\\\n                  &\\geq T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\\\\n(\\min \\limits_n\\ y_n w_f^T x_n > 0) \\quad  & > 0\n\\end{align}\n\\tag{$11$}</script><p>公式（10）中，我们关键是要得到</p>\n<script type=\"math/tex; mode=display\">\n{w_f^T \\cdot w_T} > T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)}</script><p>接着，我们来研究分母:除了$w_T$不容易确定之外，$w_T$的L1范式也不容易得出,但是我们可以转换一下，结合公式（8）(10)来进行处理，即公式（12）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n{\\lvert \\lvert w_T\\rvert \\rvert} ^ 2 &= {\\lvert \\lvert w_{T-1} + y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2   \\\\\n                                     &= {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 2y_{n(T-1)} w_{T-1} x_{n(T-1)}  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 0  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-2} \\rvert \\rvert} ^ 2 + 2 - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & ... \\\\\n                                     & \\leq {\\lvert \\lvert w_{0} \\rvert \\rvert} ^ 2 + T - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & = T \\cdot \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2\n\\end{align}\n\\tag{$12$}</script><p>到此为止，我们已经把分子的下限和分母的上限都找到了，这时候总体的值就应该大于等于某个值。有公式（11）（12），我们可以推论到公式（13）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}  \\\\\n         & = \\sqrt{T} \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }} \\\\\n         & = \\sqrt(T) \\cdot C\n         \\quad \\quad \\quad(其中 C = \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }})\n\\end{align}\n\\tag{$13$}</script><p>再有归一化之后的内积不可以大于1，所以公式（13）可以加以限制为公式（14)</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n1 \\geq\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}\n\\end{align}\n\\tag{$14$}</script><p>求解公式（14）可以得到公式（15）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nT &\\leq \\frac{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 } {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}  \\\\\n  & = \\frac{R^2}{ρ^2}\\\\\n &（其中：R^2 = \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2, \\quad\n                         ρ^2 = {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}\n\\end{align}\n\\tag{$15$}</script><blockquote>\n<p>从公式（15）可以看出，T是有上限的，所以可以说明在线性可分的情况下PLA算法最终会停止于T点，找到一个最接近目标函数的target function $g(x)$</p>\n</blockquote>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"3-Non-Separable-Data\"><a href=\"#3-Non-Separable-Data\" class=\"headerlink\" title=\"3. Non-Separable Data\"></a>3. Non-Separable Data</h2><h3 id=\"1-PLA的缺陷\"><a href=\"#1-PLA的缺陷\" class=\"headerlink\" title=\"1) PLA的缺陷\"></a>1) PLA的缺陷</h3><p>上面提到的PLA算法是基于线性可分的数据集的，这种算法不实用，有2个原因。</p>\n<ol>\n<li>在机器学习的时候，我们是不知道数据是否可分的，如果不可分，那样PLA不停止怎么办？</li>\n<li>还是与PLA不停止有关，这个时候如果数据集真的线性可分，但是因为数据量太大，跑了很久都没有跑完，怎么办？我们不知道究竟是数据问题，还是数据量太大还没跑完的问题。</li>\n</ol>\n<p>所以这时候要求我们改进PLA算法。</p>\n<h3 id=\"2）实际应用中线性可分多还是线性不可分的数据多？\"><a href=\"#2）实际应用中线性可分多还是线性不可分的数据多？\" class=\"headerlink\" title=\"2）实际应用中线性可分多还是线性不可分的数据多？\"></a>2）实际应用中线性可分多还是线性不可分的数据多？</h3><p>线性不可分的数据多：因为实际应用中存在很多噪音（Noise）。而出现噪音的原因有很多种，如：</p>\n<ul>\n<li>录入数据的时候出错</li>\n<li>采集数据的设备存在误差</li>\n<li>…</li>\n</ul>\n<p>所以存在噪音的时候，数据集会变成图四那样。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d29c4fbd29627be6829f26874e8d23c2a246be6b/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-4%20Noise.png\" alt=\"Noise\"></p>\n<p>图四 Noise</p>\n<p>因为噪音占的比例不会很大，所以最终我们还是可以找到犯错率最少的权值向量$w_g$，如公式（16）所示。</p>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{equation}\n  w_g = \\mathop{\\argmin}_{w}{\\sum_{n=1}^N sign(w^T \\cdot x_n) \\neq y_n}\n\\end{equation}\n\\tag{$16$}</script><blockquote>\n<p>但是这个公式在数学上是NP难问题，我们无法直接求解，于是我们需要找出一种近似的算法来求解这个问题：pocket 算法。</p>\n</blockquote>\n<h3 id=\"3-Pocket-算法\"><a href=\"#3-Pocket-算法\" class=\"headerlink\" title=\"3) Pocket 算法\"></a>3) Pocket 算法</h3><h4 id=\"①-Pocket算法原理\"><a href=\"#①-Pocket算法原理\" class=\"headerlink\" title=\"① Pocket算法原理\"></a>① Pocket算法原理</h4><blockquote>\n<p>Pocket 算法属于贪心算法，即如果找到原来的权值更好的权值，才去做修改，否则停止。</p>\n</blockquote>\n<p>流程如下：</p>\n<ol>\n<li>也是随机的初始化一个权值向量</li>\n<li>随机的使用n个点中的一个点去发现是否有错误（此处与cyclic PLA使用的循环方式有所不同，不是按顺序一个一个的查看是否符合条件，而是在n个点中随机的抽取，这种方式可以增加其寻找最优解的速度）</li>\n<li>和PLA一样使用公式2-5进行修正.</li>\n<li>如果有了修正，则计算出刚刚修正过的权值向量和上一个权值向量到底谁犯的错误比较少，将少的保留重复第2步到第4步的动作。</li>\n<li>假如很长时间都没有新的权值向量比当前的权值向量犯错更少，则返回该向量作为函数g。</li>\n</ol>\n<p>流程图如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/73b88a89d3618c606f70bb3a6c915acb8686d351/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-5%20Pocket%20Algorithm%20procedure.jpg\" alt=\"Pocket Algorithm Procedure\"></p>\n<center> 图五 Pocket Algorithm Procedure </center>\n\n\n<h4 id=\"②优缺点分析\"><a href=\"#②优缺点分析\" class=\"headerlink\" title=\"②优缺点分析\"></a>②优缺点分析</h4><p>优点：Pocket算法不需要考虑数据集是否线性可分，都可以进行</p>\n<p>缺点：每有一个错误点，都要遍历整个数据集来获得该店的错误率$e$，所以计算量会很大</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Binary Classification中最简单的PLA算法</li>\n<li>然后讨论了PLA算法能在某一步之后停下来。</li>\n<li>最后讨论了PLA算法有缺陷：数据必须线性可分。所以根据这个缺点，引用了Pocket算法</li>\n</ol>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\2\\2 - 2 - Perceptron Learning Algorithm (PLA) (19-46)</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"When-can-Machine-Learn-Learning-to-Answer-Yes-or-No\"><a href=\"#When-can-Machine-Learn-Learning-to-Answer-Yes-or-No\" class=\"headerlink\" title=\"When can Machine Learn? - Learning to Answer Yes or No\"></a>When can Machine Learn? - Learning to Answer Yes or No</h1><h2 id=\"1-Perceptron-Hypothesis-Set\"><a href=\"#1-Perceptron-Hypothesis-Set\" class=\"headerlink\" title=\"1. Perceptron Hypothesis Set\"></a>1. Perceptron Hypothesis Set</h2><blockquote>\n<p>举例银行发信用卡进行解释</p>\n</blockquote>\n<h3 id=\"1-Perceptron-Hypothesis-Set-1\"><a href=\"#1-Perceptron-Hypothesis-Set-1\" class=\"headerlink\" title=\"1) Perceptron Hypothesis Set\"></a>1) Perceptron Hypothesis Set</h3><p>假设空间Hypothesis Set可以用感知器（Perceptron）表示。这种假设空间的思想就类似考试给的成绩，对每一题给一个特定的分数，即加权值(权重);<br>然后再设计一个及格线，即所谓的阈值或门槛值（threshold），如果加权求和的值大于这个阈值就叫符合条件了，即输出1，小于对应的输出-1。<br>表示为公式（1）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n&h(x)∈H\n\\\\\n&h(x) = sign(\\sum_{i=1}^d w_ix_i)\n\\end{align}\n\\tag{$1$}</script><p>其中 sign函数表示为取符号，即 sign(正数) = 1， sign（负数） = -1，如公式（2）所示。</p>\n<script type=\"math/tex; mode=display\">sign(x)=\\left\\{\n\\begin{align}\n& +1 \\quad x>0 \\\\\n&-1 \\quad x<0\n\\end{align}\n\\right.\n\\tag{$2$}</script><p>最后将$h(x)$ 与阈值作比较，得到公式（3）。</p>\n<script type=\"math/tex; mode=display\">\nh(x) = sign(\\sum_{i=1}^d w_ix_i - threshold)\n\\tag{$3$}</script><h3 id=\"2-Perceptron-Hypothesis-Set公式化简\"><a href=\"#2-Perceptron-Hypothesis-Set公式化简\" class=\"headerlink\" title=\"2) Perceptron Hypothesis Set公式化简\"></a>2) Perceptron Hypothesis Set公式化简</h3><p>为了表达方便，可以对$h(x)$做数学上的讲话，如公式（4）所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh(x) &= sign(\\sum_{i=1}^d w_ix_i - threshold) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - threshold - 1) \\\\\n&=sign(\\sum_{i=1}^d w_ix_i - w_0-x_0) \\\\\n&=sign(\\sum_{i=0}^d w_ix_i) \\\\\n&=sign(w^T\\cdot  x)\n\\end{align}\n\\tag{$4$}</script><blockquote>\n<p>如上所示，将负阈值表示为权值向量中的一项($w_0$)，而对应输入分量则被默认为1，用$x_0$ 最终将公式简化为两个向量内积的形式，其中T表示转置。</p>\n</blockquote>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-Peceptron-Learning-Algorithm-PLA\"><a href=\"#2-Peceptron-Learning-Algorithm-PLA\" class=\"headerlink\" title=\"2. Peceptron Learning Algorithm(PLA)\"></a>2. Peceptron Learning Algorithm(PLA)</h2><h3 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1) Introduction\"></a>1) Introduction</h3><h4 id=\"①-Question\"><a href=\"#①-Question\" class=\"headerlink\" title=\"① Question\"></a>① Question</h4><p>Hypothesis Set $H$包含所有可能的Perceptron，那么具体选用哪一组Perceptron来组合成$g(x)$ 呢?</p>\n<h4 id=\"②-Analyze\"><a href=\"#②-Analyze\" class=\"headerlink\" title=\"② Analyze\"></a>② Analyze</h4><ul>\n<li>$g(x)$ 和目标函数f越接近越好，但问题是我们不知道f（如果知道了就不需要学习了）</li>\n<li>但是我们知道的是样本输入$x$在$f(x)$ 作用下得到的标记$y$。</li>\n</ul>\n<p>所以如果我们能使得$g(x)$ 在所有的样本输入中都能够得到跟函数$f(x)$ 作用过输入得到的输出一样的话，我们认为这时的$g(x)$ 是不错的。（在后面的章节还会在这种思想的基础上更深入的讨论这一问题）</p>\n<h4 id=\"③-Solution\"><a href=\"#③-Solution\" class=\"headerlink\" title=\"③ Solution\"></a>③ Solution</h4><p>我们想到一个简单的方式，就是一步一步的修正错误的分类，在二维平面中可以想象成一条初始的直线，在经过不断的纠正它的错误（就是旋转平移之类的）使得最终的结果可以达到希望的效果。</p>\n<p>还要在重复上一节中已经得到的一个结论，在感知器模型中，每一个假设函数$g(x)$ 都对应一个权值向量。因此我们要做的就是不断修正这个权值向量使得最接近目标函数$f(x)$ 。即PLA算法</p>\n<hr>\n<p><br><br><br></p>\n<h3 id=\"2-PLA\"><a href=\"#2-PLA\" class=\"headerlink\" title=\"2) PLA\"></a>2) PLA</h3><h4 id=\"①-PLA步骤\"><a href=\"#①-PLA步骤\" class=\"headerlink\" title=\"① PLA步骤\"></a>① PLA步骤</h4><p>首先我们在设置初始$w_0$（注意此处是向量不是向量的分量！），比如设置为0向量，然后使用训练样本来将权值向量修正的更接近目标函数$f(x)$。</p>\n<p>通过公式（5）来判断什么时候需要进行修正:</p>\n<script type=\"math/tex; mode=display\">\nsign( w_t^T \\cdot x_{n(t)} \\neq y_{(n)})\n\\tag{$5$}</script><p>通过公式（6）来进行修正：</p>\n<script type=\"math/tex; mode=display\">\nw_{t+1} = w_t + y_{n(t)} \\cdot x_{n(t)}\n\\tag{$6$}</script><h4 id=\"②-图示说明\"><a href=\"#②-图示说明\" class=\"headerlink\" title=\"② 图示说明\"></a>② 图示说明</h4><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a335a9177d37b3ced5d4763a53f61f3f5b01e0e8/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-1%20PLA.png\" alt=\"PLA\"></p>\n<center>图一 PLA<sup>[1]</sup></center>\n\n<blockquote>\n<p>在本身标记为+1时，权值向量和输入向量的内积为负数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。</p>\n<p>在本身标记为-1时，权值向量和输入向量的内积为正数，对权值向量略作修改，加上一个标记y和输入向量的乘积，得到一个新的权值向量，可以看出新的权值向量和输入向量的相乘之后符合了标记的要求。</p>\n</blockquote>\n<p>重复查找错误样本和修改加权向量，直到再也找不到可以使公式(5)成立的样本为止，此时得到的加权向量，即为我们想要的最终$g(x)$</p>\n<p>具体流程如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/48df8c85a8eb4fd2af3331147cd25401dc2f728a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-2%20PLA%20procedure.jpg\" alt=\"PLA\"></p>\n<center>图二 PLA Procedure<sup>[1]</sup></center>\n\n\n\n<blockquote>\n<p>疑问:如何查找错误样本点，如何确定没有错误的点了?</p>\n</blockquote>\n<p>一个简单的方式就是将训练样本编号，从1到n，以按从1到n的顺序不断查找错误点，如果没有错就自动的用下一个样本点继续查找，当从1到n这n个样本点都没有产生错误时，算法即结束得到$g(x)$ 。将这种方式的算法叫做Cyclic PLA。</p>\n<blockquote>\n<p>新的疑问:</p>\n<p>1.这个算法一定会找到一个能使所有的样本都不符合的情况吗(即是否会停下来)？</p>\n<p>2.算法找到的真的是最好的g(x)吗？</p>\n<p>3.应用到测试集中，结果还会一样吗？</p>\n<p>详见 ③ PLA的理论保证</p>\n</blockquote>\n<h4 id=\"③-PLA的理论保证\"><a href=\"#③-PLA的理论保证\" class=\"headerlink\" title=\"③ PLA的理论保证\"></a>③ PLA的理论保证</h4><h5 id=\"i-前提条件\"><a href=\"#i-前提条件\" class=\"headerlink\" title=\"i) 前提条件\"></a>i) 前提条件</h5><p>首先很明显，要用一条直线做Binary Classification必须要求数据线性可分，否则不可以分开（想象一刀切）<br>如图三：</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/45e061db302ad3b6622daa8ecc48f802b861874c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-3%20linear%20seperable.png\" alt=\"Linear Separable\"></p>\n<center>图三 Linear Seperable <sup>[1]</sup></center>\n\n<h5 id=\"ii-理论推导\"><a href=\"#ii-理论推导\" class=\"headerlink\" title=\"ii) 理论推导\"></a>ii) 理论推导</h5><p>首先PLA的核心是每次修正都让权值的向量$W^T$（T代表在第T次停下）更接近于理想的权值向量$W_f$,如何衡量两个向量的相似程度呢？内积，即对向量$W^T$和$W_f$做内积。</p>\n<blockquote>\n<p>内积的大小与2个向量的方向与大小都有关，所以如果我们直接做内积的话，会受到向量长度的影响，所以要做归一化处理，如公式7</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}}\n\\tag{$7$}</script><p>公式用于衡量两个向量的方向的差别程度，但是怎么处理这个公式呢？</p>\n<p>先看分子,有之前的公式（6）我们可以得到公式（8）:</p>\n<script type=\"math/tex; mode=display\">\n{w_f^T \\cdot w_T} \\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)})\n\\tag{$8$}</script><p>如果PLA都会让权值越来越接近理想值，那么由之前的公式（5），我们其实可以推出公式（9）&lt;—(因为$w_f$是最理想的值，那时候应该所有的预测值都和实际相等）和公式（10）&lt;—(因为只有再犯错误的时候才改变，所以$W_t^T$与实际值会不一样):</p>\n<script type=\"math/tex; mode=display\">\ny_{n(t)} w_f^T x_{n(t)} \\geq \\min \\limits_n\\ y_n w_f^T x_n > 0\n\\tag{$9$}</script><script type=\"math/tex; mode=display\">\ny_{n(t)} w_f^T x_{n(t)} \\leq 0\n\\tag{$10$}</script><p>所以由公式（9），我们可以对公式（8）进一步限制他的范围：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n{w_f^T \\cdot w_T} &\\geq {w_f^T} \\cdot (w_{T-1} + y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-1} + \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  &\\geq {w_f^T} w_{T-2} + 2 - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n                  & ... \\\\\n                  &\\geq {w_f^T} w_{0} + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot x_{n(T-1)}) \\\\\n(w_0 = 0) \\quad   &\\geq 0 + T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\cdot  x_{n(T-1)}) \\\\\n                  &\\geq T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)} \\\\\n(\\min \\limits_n\\ y_n w_f^T x_n > 0) \\quad  & > 0\n\\end{align}\n\\tag{$11$}</script><p>公式（10）中，我们关键是要得到</p>\n<script type=\"math/tex; mode=display\">\n{w_f^T \\cdot w_T} > T - \\min \\limits_n w_f^T \\cdot y_{n(T-1)}</script><p>接着，我们来研究分母:除了$w_T$不容易确定之外，$w_T$的L1范式也不容易得出,但是我们可以转换一下，结合公式（8）(10)来进行处理，即公式（12）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n{\\lvert \\lvert w_T\\rvert \\rvert} ^ 2 &= {\\lvert \\lvert w_{T-1} + y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2   \\\\\n                                     &= {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 2y_{n(T-1)} w_{T-1} x_{n(T-1)}  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + {\\lvert \\lvert y_{n(T-1)} x_{n(T-1)} \\rvert \\rvert} ^ 2 + 0  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-1} \\rvert \\rvert} ^ 2 + \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & \\leq {\\lvert \\lvert w_{T-2} \\rvert \\rvert} ^ 2 + 2 - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & ... \\\\\n                                     & \\leq {\\lvert \\lvert w_{0} \\rvert \\rvert} ^ 2 + T - \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2  \\\\\n                                     & = T \\cdot \\max\\limits_n {\\lvert \\lvert x_{n} \\rvert \\rvert} ^ 2\n\\end{align}\n\\tag{$12$}</script><p>到此为止，我们已经把分子的下限和分母的上限都找到了，这时候总体的值就应该大于等于某个值。有公式（11）（12），我们可以推论到公式（13）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}  \\\\\n         & = \\sqrt{T} \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }} \\\\\n         & = \\sqrt(T) \\cdot C\n         \\quad \\quad \\quad(其中 C = \\frac{\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n} {\\sqrt{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 }})\n\\end{align}\n\\tag{$13$}</script><p>再有归一化之后的内积不可以大于1，所以公式（13）可以加以限制为公式（14)</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n1 \\geq\n\\frac{w_f^T \\cdot w_T}{ {\\lvert \\lvert w_f^T \\rvert \\rvert} \\cdot {\\lvert \\lvert w_T\\rvert \\rvert}} & \\geq \\frac{T \\cdot \\min\\limits_n y_n w_f^T x_n}{w_f^T \\sqrt{T \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert}}}\n\\end{align}\n\\tag{$14$}</script><p>求解公式（14）可以得到公式（15）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nT &\\leq \\frac{\\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2 } {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}  \\\\\n  & = \\frac{R^2}{ρ^2}\\\\\n &（其中：R^2 = \\max\\limits_n {\\lvert \\lvert w_n \\rvert \\rvert} ^ 2, \\quad\n                         ρ^2 = {\\left( {\\min\\limits_n y_n \\frac{w_f^T}{\\lvert \\lvert w_f^T \\rvert \\rvert} x_n}\\right)^2}\n\\end{align}\n\\tag{$15$}</script><blockquote>\n<p>从公式（15）可以看出，T是有上限的，所以可以说明在线性可分的情况下PLA算法最终会停止于T点，找到一个最接近目标函数的target function $g(x)$</p>\n</blockquote>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"3-Non-Separable-Data\"><a href=\"#3-Non-Separable-Data\" class=\"headerlink\" title=\"3. Non-Separable Data\"></a>3. Non-Separable Data</h2><h3 id=\"1-PLA的缺陷\"><a href=\"#1-PLA的缺陷\" class=\"headerlink\" title=\"1) PLA的缺陷\"></a>1) PLA的缺陷</h3><p>上面提到的PLA算法是基于线性可分的数据集的，这种算法不实用，有2个原因。</p>\n<ol>\n<li>在机器学习的时候，我们是不知道数据是否可分的，如果不可分，那样PLA不停止怎么办？</li>\n<li>还是与PLA不停止有关，这个时候如果数据集真的线性可分，但是因为数据量太大，跑了很久都没有跑完，怎么办？我们不知道究竟是数据问题，还是数据量太大还没跑完的问题。</li>\n</ol>\n<p>所以这时候要求我们改进PLA算法。</p>\n<h3 id=\"2）实际应用中线性可分多还是线性不可分的数据多？\"><a href=\"#2）实际应用中线性可分多还是线性不可分的数据多？\" class=\"headerlink\" title=\"2）实际应用中线性可分多还是线性不可分的数据多？\"></a>2）实际应用中线性可分多还是线性不可分的数据多？</h3><p>线性不可分的数据多：因为实际应用中存在很多噪音（Noise）。而出现噪音的原因有很多种，如：</p>\n<ul>\n<li>录入数据的时候出错</li>\n<li>采集数据的设备存在误差</li>\n<li>…</li>\n</ul>\n<p>所以存在噪音的时候，数据集会变成图四那样。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d29c4fbd29627be6829f26874e8d23c2a246be6b/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-4%20Noise.png\" alt=\"Noise\"></p>\n<p>图四 Noise</p>\n<p>因为噪音占的比例不会很大，所以最终我们还是可以找到犯错率最少的权值向量$w_g$，如公式（16）所示。</p>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{equation}\n  w_g = \\mathop{\\argmin}_{w}{\\sum_{n=1}^N sign(w^T \\cdot x_n) \\neq y_n}\n\\end{equation}\n\\tag{$16$}</script><blockquote>\n<p>但是这个公式在数学上是NP难问题，我们无法直接求解，于是我们需要找出一种近似的算法来求解这个问题：pocket 算法。</p>\n</blockquote>\n<h3 id=\"3-Pocket-算法\"><a href=\"#3-Pocket-算法\" class=\"headerlink\" title=\"3) Pocket 算法\"></a>3) Pocket 算法</h3><h4 id=\"①-Pocket算法原理\"><a href=\"#①-Pocket算法原理\" class=\"headerlink\" title=\"① Pocket算法原理\"></a>① Pocket算法原理</h4><blockquote>\n<p>Pocket 算法属于贪心算法，即如果找到原来的权值更好的权值，才去做修改，否则停止。</p>\n</blockquote>\n<p>流程如下：</p>\n<ol>\n<li>也是随机的初始化一个权值向量</li>\n<li>随机的使用n个点中的一个点去发现是否有错误（此处与cyclic PLA使用的循环方式有所不同，不是按顺序一个一个的查看是否符合条件，而是在n个点中随机的抽取，这种方式可以增加其寻找最优解的速度）</li>\n<li>和PLA一样使用公式2-5进行修正.</li>\n<li>如果有了修正，则计算出刚刚修正过的权值向量和上一个权值向量到底谁犯的错误比较少，将少的保留重复第2步到第4步的动作。</li>\n<li>假如很长时间都没有新的权值向量比当前的权值向量犯错更少，则返回该向量作为函数g。</li>\n</ol>\n<p>流程图如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/73b88a89d3618c606f70bb3a6c915acb8686d351/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter2-5%20Pocket%20Algorithm%20procedure.jpg\" alt=\"Pocket Algorithm Procedure\"></p>\n<center> 图五 Pocket Algorithm Procedure </center>\n\n\n<h4 id=\"②优缺点分析\"><a href=\"#②优缺点分析\" class=\"headerlink\" title=\"②优缺点分析\"></a>②优缺点分析</h4><p>优点：Pocket算法不需要考虑数据集是否线性可分，都可以进行</p>\n<p>缺点：每有一个错误点，都要遍历整个数据集来获得该店的错误率$e$，所以计算量会很大</p>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Binary Classification中最简单的PLA算法</li>\n<li>然后讨论了PLA算法能在某一步之后停下来。</li>\n<li>最后讨论了PLA算法有缺陷：数据必须线性可分。所以根据这个缺点，引用了Pocket算法</li>\n</ol>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\2\\2 - 2 - Perceptron Learning Algorithm (PLA) (19-46)</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"3.When can Machine Learn? - Types of Learning","date":"2017-10-04T04:03:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# When can Machine Learn? - Types of Learning\n\n## 1. Learning with Different Output Space\n介绍类型的输出空间：二值输出（二元分类），多值输出（多元分类），实数输出（回归），结构输出\n\n### 1) Binary Classification\n前两章中提到的银行发信用卡问题就是一个典型的二元分类问题，其输出空间只包含两个标记+1和-1，分别对应着发卡与不发卡。\n用符号可以表示为：\n$$\ng(x) ∈ \\{value_1, value_2\\}\n\\tag{$1$}\n$$\n\n常用的算法有：\n> 以后补充\n\n### 2) Multiclass Classification\n有二元分类，就不难想到多元分类的问题，该类问题输出标签不止两种，而是{1,2,…,K}。这在人们的生活中非常常见，比如给病人症状的分类，购买物品的种类等等，其主要的应用场景就是模式识别。\n用符号可以表示为：\n$$\ng(x) ∈ \\{value_1, value_2, ..., value_n\\}\n\\tag{$2$}\n$$\n\n常用的算法有：\n> 以后补充\n\n### 3) Regression\n当输出的空间为实数的时候，就属于回归问题，这种输出与二元，多元分类的区别在于，我们无法提前打好标签到输出结果中。应用场景为：病人患病几率，给客户发信用卡的几率等。统计学中对回归问题有很多处理方法，以及评估的方法。\n用符号可以表示为：\n$$\ng(x) ∈ [ a, b ]\n\\tag{$$}\n$$\n\n常用的算法有：\n> 以后补充\n\n### 4) Structured Learning （不熟悉）\n结构化的学习，就是说输出的结果可能是一串特定的结构的数据，比如说语义识别中的语意结构。\n\n常用的算法有：\n> 以后补充\n\n\n\n--------------------------------\n\n<br><br>\n\n\n## 2. Learning with Different Data Label\n不同的数据标记: 标记了输入和输出（监督学习），标记部分数据的输入和输出（半监督学习），什么都不标记（无监督学习），训练模型根据后天的反馈进行调整（增强学习）\n\n常用的算法有：\n> 以后补充\n\n### 1) Supervised Learning\n知道数据输入的同时还知道数据的标记。就相当于告诉你题目的同时还告诉你答案，让你在这种环境下学习，称之为监督学习（supervised learning）或者叫有师学习（learning with a teacher），之前讨论的一些算法都是这类问题。\n\n常用的算法有：\n> 以后补充\n\n### 2) Semi-supervised Learning\n半监督学习，它通过少量有标记的训练点和大量无标记的训练点达到学习的目的。这种类型的例子也有很多，比如图像的识别，很多情况下我们不可能把每张图片都做上标记（因为做这种标记需要耗费大量的人力物力，是一种昂贵的行为），此时，使用半监督学习是一种不错的选择。\n\n常用的算法有：\n> 以后补充\n\n### 3) Unsupervised Learning\n这是一种没有标示（就是没有输出y）的问题，就是不告诉你题目的正确答案让你自己去做题。\n\n常用的算法有：\n> 以后补充\n\n### 4) Reinforcement Learning\n前面三种学习方式是机器学习中最传统的三种方式，除此之外，通过对一个行为作出奖励或者惩罚，以此获得的输出，进而进行学习，这种学习方式称之为强化学习。\n\n常用的算法有：\n> 以后补充\n\n\n\n--------------------------------\n<br><br>\n\n## 3. Learning with Different Protocol\n通过不同的方式去提供数据到机器中：一次性给完（batch)，一点一点的输入（online），让机器主动提出问题（active）\n\n### 1) Batch\n\n批量（batch）学习就是将很多数据一次性的给算法进行学习，是最常见的方式\n\n### 2) Online\n\n在线（online）学习就是一点一点将数据传输进去，如增强学习；\n\n### 3) Active\n主动（active）学习是主动提出问题让算法解决，可以节省大量的训练和标记消耗。类似于让机器提问题，告诉我们机器有什么问题不会，从而教它\n\n--------------------------------\n<br><br>\n\n## 4. Learning with Different Input Space\n不同的输入空间:具体特征（Concrete Features），原始特征（Raw Features），抽象特征（Abstract Features）\n\n### 1) Concrete Features\n具体特征（Concrete Features），具体特征最大特点就是便于机器学习的处理，这种情况是人类或者机器通过一定的方式提取获得的，具有实用性。\n\n### 2) Raw Features\n原始特征（Raw Features），如图片的像素等等，是最为常见到的资料，但是需要经过处理，转换成具体特征，才容易使用，实用性不太大。\n\n### 3) Abstract Features\n抽象特征（Abstract Features），如一些ID之类的看似无意义的数据，这就更需要特征的转换、提取等工作（相对于原始特征而言），几乎没有实用性。\n\n\n--------------------------------\n<br><br>\n# Summary\nA collection of concept of different Learning types.\n\n<br><br>\n--------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-04-3.When can Machine Learn - Types of Learning.md","raw":"---\ntitle: 3.When can Machine Learn? - Types of Learning\ndate: 2017-10-04 12:03:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# When can Machine Learn? - Types of Learning\n\n## 1. Learning with Different Output Space\n介绍类型的输出空间：二值输出（二元分类），多值输出（多元分类），实数输出（回归），结构输出\n\n### 1) Binary Classification\n前两章中提到的银行发信用卡问题就是一个典型的二元分类问题，其输出空间只包含两个标记+1和-1，分别对应着发卡与不发卡。\n用符号可以表示为：\n$$\ng(x) ∈ \\{value_1, value_2\\}\n\\tag{$1$}\n$$\n\n常用的算法有：\n> 以后补充\n\n### 2) Multiclass Classification\n有二元分类，就不难想到多元分类的问题，该类问题输出标签不止两种，而是{1,2,…,K}。这在人们的生活中非常常见，比如给病人症状的分类，购买物品的种类等等，其主要的应用场景就是模式识别。\n用符号可以表示为：\n$$\ng(x) ∈ \\{value_1, value_2, ..., value_n\\}\n\\tag{$2$}\n$$\n\n常用的算法有：\n> 以后补充\n\n### 3) Regression\n当输出的空间为实数的时候，就属于回归问题，这种输出与二元，多元分类的区别在于，我们无法提前打好标签到输出结果中。应用场景为：病人患病几率，给客户发信用卡的几率等。统计学中对回归问题有很多处理方法，以及评估的方法。\n用符号可以表示为：\n$$\ng(x) ∈ [ a, b ]\n\\tag{$$}\n$$\n\n常用的算法有：\n> 以后补充\n\n### 4) Structured Learning （不熟悉）\n结构化的学习，就是说输出的结果可能是一串特定的结构的数据，比如说语义识别中的语意结构。\n\n常用的算法有：\n> 以后补充\n\n\n\n--------------------------------\n\n<br><br>\n\n\n## 2. Learning with Different Data Label\n不同的数据标记: 标记了输入和输出（监督学习），标记部分数据的输入和输出（半监督学习），什么都不标记（无监督学习），训练模型根据后天的反馈进行调整（增强学习）\n\n常用的算法有：\n> 以后补充\n\n### 1) Supervised Learning\n知道数据输入的同时还知道数据的标记。就相当于告诉你题目的同时还告诉你答案，让你在这种环境下学习，称之为监督学习（supervised learning）或者叫有师学习（learning with a teacher），之前讨论的一些算法都是这类问题。\n\n常用的算法有：\n> 以后补充\n\n### 2) Semi-supervised Learning\n半监督学习，它通过少量有标记的训练点和大量无标记的训练点达到学习的目的。这种类型的例子也有很多，比如图像的识别，很多情况下我们不可能把每张图片都做上标记（因为做这种标记需要耗费大量的人力物力，是一种昂贵的行为），此时，使用半监督学习是一种不错的选择。\n\n常用的算法有：\n> 以后补充\n\n### 3) Unsupervised Learning\n这是一种没有标示（就是没有输出y）的问题，就是不告诉你题目的正确答案让你自己去做题。\n\n常用的算法有：\n> 以后补充\n\n### 4) Reinforcement Learning\n前面三种学习方式是机器学习中最传统的三种方式，除此之外，通过对一个行为作出奖励或者惩罚，以此获得的输出，进而进行学习，这种学习方式称之为强化学习。\n\n常用的算法有：\n> 以后补充\n\n\n\n--------------------------------\n<br><br>\n\n## 3. Learning with Different Protocol\n通过不同的方式去提供数据到机器中：一次性给完（batch)，一点一点的输入（online），让机器主动提出问题（active）\n\n### 1) Batch\n\n批量（batch）学习就是将很多数据一次性的给算法进行学习，是最常见的方式\n\n### 2) Online\n\n在线（online）学习就是一点一点将数据传输进去，如增强学习；\n\n### 3) Active\n主动（active）学习是主动提出问题让算法解决，可以节省大量的训练和标记消耗。类似于让机器提问题，告诉我们机器有什么问题不会，从而教它\n\n--------------------------------\n<br><br>\n\n## 4. Learning with Different Input Space\n不同的输入空间:具体特征（Concrete Features），原始特征（Raw Features），抽象特征（Abstract Features）\n\n### 1) Concrete Features\n具体特征（Concrete Features），具体特征最大特点就是便于机器学习的处理，这种情况是人类或者机器通过一定的方式提取获得的，具有实用性。\n\n### 2) Raw Features\n原始特征（Raw Features），如图片的像素等等，是最为常见到的资料，但是需要经过处理，转换成具体特征，才容易使用，实用性不太大。\n\n### 3) Abstract Features\n抽象特征（Abstract Features），如一些ID之类的看似无意义的数据，这就更需要特征的转换、提取等工作（相对于原始特征而言），几乎没有实用性。\n\n\n--------------------------------\n<br><br>\n# Summary\nA collection of concept of different Learning types.\n\n<br><br>\n--------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-04-3.When can Machine Learn - Types of Learning","published":1,"updated":"2018-10-27T04:30:42.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bk0019e0owgkc7jmyh","content":"<h1 id=\"When-can-Machine-Learn-Types-of-Learning\"><a href=\"#When-can-Machine-Learn-Types-of-Learning\" class=\"headerlink\" title=\"When can Machine Learn? - Types of Learning\"></a>When can Machine Learn? - Types of Learning</h1><h2 id=\"1-Learning-with-Different-Output-Space\"><a href=\"#1-Learning-with-Different-Output-Space\" class=\"headerlink\" title=\"1. Learning with Different Output Space\"></a>1. Learning with Different Output Space</h2><p>介绍类型的输出空间：二值输出（二元分类），多值输出（多元分类），实数输出（回归），结构输出</p>\n<h3 id=\"1-Binary-Classification\"><a href=\"#1-Binary-Classification\" class=\"headerlink\" title=\"1) Binary Classification\"></a>1) Binary Classification</h3><p>前两章中提到的银行发信用卡问题就是一个典型的二元分类问题，其输出空间只包含两个标记+1和-1，分别对应着发卡与不发卡。<br>用符号可以表示为：</p>\n<script type=\"math/tex; mode=display\">\ng(x) ∈ \\{value_1, value_2\\}\n\\tag{$1$}</script><p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"2-Multiclass-Classification\"><a href=\"#2-Multiclass-Classification\" class=\"headerlink\" title=\"2) Multiclass Classification\"></a>2) Multiclass Classification</h3><p>有二元分类，就不难想到多元分类的问题，该类问题输出标签不止两种，而是{1,2,…,K}。这在人们的生活中非常常见，比如给病人症状的分类，购买物品的种类等等，其主要的应用场景就是模式识别。<br>用符号可以表示为：</p>\n<script type=\"math/tex; mode=display\">\ng(x) ∈ \\{value_1, value_2, ..., value_n\\}\n\\tag{$2$}</script><p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"3-Regression\"><a href=\"#3-Regression\" class=\"headerlink\" title=\"3) Regression\"></a>3) Regression</h3><p>当输出的空间为实数的时候，就属于回归问题，这种输出与二元，多元分类的区别在于，我们无法提前打好标签到输出结果中。应用场景为：病人患病几率，给客户发信用卡的几率等。统计学中对回归问题有很多处理方法，以及评估的方法。<br>用符号可以表示为：</p>\n<script type=\"math/tex; mode=display\">\ng(x) ∈ [ a, b ]\n\\tag{$$}</script><p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"4-Structured-Learning-（不熟悉）\"><a href=\"#4-Structured-Learning-（不熟悉）\" class=\"headerlink\" title=\"4) Structured Learning （不熟悉）\"></a>4) Structured Learning （不熟悉）</h3><p>结构化的学习，就是说输出的结果可能是一串特定的结构的数据，比如说语义识别中的语意结构。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<hr>\n<p><br><br></p>\n<h2 id=\"2-Learning-with-Different-Data-Label\"><a href=\"#2-Learning-with-Different-Data-Label\" class=\"headerlink\" title=\"2. Learning with Different Data Label\"></a>2. Learning with Different Data Label</h2><p>不同的数据标记: 标记了输入和输出（监督学习），标记部分数据的输入和输出（半监督学习），什么都不标记（无监督学习），训练模型根据后天的反馈进行调整（增强学习）</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"1-Supervised-Learning\"><a href=\"#1-Supervised-Learning\" class=\"headerlink\" title=\"1) Supervised Learning\"></a>1) Supervised Learning</h3><p>知道数据输入的同时还知道数据的标记。就相当于告诉你题目的同时还告诉你答案，让你在这种环境下学习，称之为监督学习（supervised learning）或者叫有师学习（learning with a teacher），之前讨论的一些算法都是这类问题。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"2-Semi-supervised-Learning\"><a href=\"#2-Semi-supervised-Learning\" class=\"headerlink\" title=\"2) Semi-supervised Learning\"></a>2) Semi-supervised Learning</h3><p>半监督学习，它通过少量有标记的训练点和大量无标记的训练点达到学习的目的。这种类型的例子也有很多，比如图像的识别，很多情况下我们不可能把每张图片都做上标记（因为做这种标记需要耗费大量的人力物力，是一种昂贵的行为），此时，使用半监督学习是一种不错的选择。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"3-Unsupervised-Learning\"><a href=\"#3-Unsupervised-Learning\" class=\"headerlink\" title=\"3) Unsupervised Learning\"></a>3) Unsupervised Learning</h3><p>这是一种没有标示（就是没有输出y）的问题，就是不告诉你题目的正确答案让你自己去做题。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"4-Reinforcement-Learning\"><a href=\"#4-Reinforcement-Learning\" class=\"headerlink\" title=\"4) Reinforcement Learning\"></a>4) Reinforcement Learning</h3><p>前面三种学习方式是机器学习中最传统的三种方式，除此之外，通过对一个行为作出奖励或者惩罚，以此获得的输出，进而进行学习，这种学习方式称之为强化学习。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-Learning-with-Different-Protocol\"><a href=\"#3-Learning-with-Different-Protocol\" class=\"headerlink\" title=\"3. Learning with Different Protocol\"></a>3. Learning with Different Protocol</h2><p>通过不同的方式去提供数据到机器中：一次性给完（batch)，一点一点的输入（online），让机器主动提出问题（active）</p>\n<h3 id=\"1-Batch\"><a href=\"#1-Batch\" class=\"headerlink\" title=\"1) Batch\"></a>1) Batch</h3><p>批量（batch）学习就是将很多数据一次性的给算法进行学习，是最常见的方式</p>\n<h3 id=\"2-Online\"><a href=\"#2-Online\" class=\"headerlink\" title=\"2) Online\"></a>2) Online</h3><p>在线（online）学习就是一点一点将数据传输进去，如增强学习；</p>\n<h3 id=\"3-Active\"><a href=\"#3-Active\" class=\"headerlink\" title=\"3) Active\"></a>3) Active</h3><p>主动（active）学习是主动提出问题让算法解决，可以节省大量的训练和标记消耗。类似于让机器提问题，告诉我们机器有什么问题不会，从而教它</p>\n<hr>\n<p><br><br></p>\n<h2 id=\"4-Learning-with-Different-Input-Space\"><a href=\"#4-Learning-with-Different-Input-Space\" class=\"headerlink\" title=\"4. Learning with Different Input Space\"></a>4. Learning with Different Input Space</h2><p>不同的输入空间:具体特征（Concrete Features），原始特征（Raw Features），抽象特征（Abstract Features）</p>\n<h3 id=\"1-Concrete-Features\"><a href=\"#1-Concrete-Features\" class=\"headerlink\" title=\"1) Concrete Features\"></a>1) Concrete Features</h3><p>具体特征（Concrete Features），具体特征最大特点就是便于机器学习的处理，这种情况是人类或者机器通过一定的方式提取获得的，具有实用性。</p>\n<h3 id=\"2-Raw-Features\"><a href=\"#2-Raw-Features\" class=\"headerlink\" title=\"2) Raw Features\"></a>2) Raw Features</h3><p>原始特征（Raw Features），如图片的像素等等，是最为常见到的资料，但是需要经过处理，转换成具体特征，才容易使用，实用性不太大。</p>\n<h3 id=\"3-Abstract-Features\"><a href=\"#3-Abstract-Features\" class=\"headerlink\" title=\"3) Abstract Features\"></a>3) Abstract Features</h3><p>抽象特征（Abstract Features），如一些ID之类的看似无意义的数据，这就更需要特征的转换、提取等工作（相对于原始特征而言），几乎没有实用性。</p>\n<hr>\n<p><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>A collection of concept of different Learning types.</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"When-can-Machine-Learn-Types-of-Learning\"><a href=\"#When-can-Machine-Learn-Types-of-Learning\" class=\"headerlink\" title=\"When can Machine Learn? - Types of Learning\"></a>When can Machine Learn? - Types of Learning</h1><h2 id=\"1-Learning-with-Different-Output-Space\"><a href=\"#1-Learning-with-Different-Output-Space\" class=\"headerlink\" title=\"1. Learning with Different Output Space\"></a>1. Learning with Different Output Space</h2><p>介绍类型的输出空间：二值输出（二元分类），多值输出（多元分类），实数输出（回归），结构输出</p>\n<h3 id=\"1-Binary-Classification\"><a href=\"#1-Binary-Classification\" class=\"headerlink\" title=\"1) Binary Classification\"></a>1) Binary Classification</h3><p>前两章中提到的银行发信用卡问题就是一个典型的二元分类问题，其输出空间只包含两个标记+1和-1，分别对应着发卡与不发卡。<br>用符号可以表示为：</p>\n<script type=\"math/tex; mode=display\">\ng(x) ∈ \\{value_1, value_2\\}\n\\tag{$1$}</script><p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"2-Multiclass-Classification\"><a href=\"#2-Multiclass-Classification\" class=\"headerlink\" title=\"2) Multiclass Classification\"></a>2) Multiclass Classification</h3><p>有二元分类，就不难想到多元分类的问题，该类问题输出标签不止两种，而是{1,2,…,K}。这在人们的生活中非常常见，比如给病人症状的分类，购买物品的种类等等，其主要的应用场景就是模式识别。<br>用符号可以表示为：</p>\n<script type=\"math/tex; mode=display\">\ng(x) ∈ \\{value_1, value_2, ..., value_n\\}\n\\tag{$2$}</script><p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"3-Regression\"><a href=\"#3-Regression\" class=\"headerlink\" title=\"3) Regression\"></a>3) Regression</h3><p>当输出的空间为实数的时候，就属于回归问题，这种输出与二元，多元分类的区别在于，我们无法提前打好标签到输出结果中。应用场景为：病人患病几率，给客户发信用卡的几率等。统计学中对回归问题有很多处理方法，以及评估的方法。<br>用符号可以表示为：</p>\n<script type=\"math/tex; mode=display\">\ng(x) ∈ [ a, b ]\n\\tag{$$}</script><p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"4-Structured-Learning-（不熟悉）\"><a href=\"#4-Structured-Learning-（不熟悉）\" class=\"headerlink\" title=\"4) Structured Learning （不熟悉）\"></a>4) Structured Learning （不熟悉）</h3><p>结构化的学习，就是说输出的结果可能是一串特定的结构的数据，比如说语义识别中的语意结构。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<hr>\n<p><br><br></p>\n<h2 id=\"2-Learning-with-Different-Data-Label\"><a href=\"#2-Learning-with-Different-Data-Label\" class=\"headerlink\" title=\"2. Learning with Different Data Label\"></a>2. Learning with Different Data Label</h2><p>不同的数据标记: 标记了输入和输出（监督学习），标记部分数据的输入和输出（半监督学习），什么都不标记（无监督学习），训练模型根据后天的反馈进行调整（增强学习）</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"1-Supervised-Learning\"><a href=\"#1-Supervised-Learning\" class=\"headerlink\" title=\"1) Supervised Learning\"></a>1) Supervised Learning</h3><p>知道数据输入的同时还知道数据的标记。就相当于告诉你题目的同时还告诉你答案，让你在这种环境下学习，称之为监督学习（supervised learning）或者叫有师学习（learning with a teacher），之前讨论的一些算法都是这类问题。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"2-Semi-supervised-Learning\"><a href=\"#2-Semi-supervised-Learning\" class=\"headerlink\" title=\"2) Semi-supervised Learning\"></a>2) Semi-supervised Learning</h3><p>半监督学习，它通过少量有标记的训练点和大量无标记的训练点达到学习的目的。这种类型的例子也有很多，比如图像的识别，很多情况下我们不可能把每张图片都做上标记（因为做这种标记需要耗费大量的人力物力，是一种昂贵的行为），此时，使用半监督学习是一种不错的选择。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"3-Unsupervised-Learning\"><a href=\"#3-Unsupervised-Learning\" class=\"headerlink\" title=\"3) Unsupervised Learning\"></a>3) Unsupervised Learning</h3><p>这是一种没有标示（就是没有输出y）的问题，就是不告诉你题目的正确答案让你自己去做题。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<h3 id=\"4-Reinforcement-Learning\"><a href=\"#4-Reinforcement-Learning\" class=\"headerlink\" title=\"4) Reinforcement Learning\"></a>4) Reinforcement Learning</h3><p>前面三种学习方式是机器学习中最传统的三种方式，除此之外，通过对一个行为作出奖励或者惩罚，以此获得的输出，进而进行学习，这种学习方式称之为强化学习。</p>\n<p>常用的算法有：</p>\n<blockquote>\n<p>以后补充</p>\n</blockquote>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-Learning-with-Different-Protocol\"><a href=\"#3-Learning-with-Different-Protocol\" class=\"headerlink\" title=\"3. Learning with Different Protocol\"></a>3. Learning with Different Protocol</h2><p>通过不同的方式去提供数据到机器中：一次性给完（batch)，一点一点的输入（online），让机器主动提出问题（active）</p>\n<h3 id=\"1-Batch\"><a href=\"#1-Batch\" class=\"headerlink\" title=\"1) Batch\"></a>1) Batch</h3><p>批量（batch）学习就是将很多数据一次性的给算法进行学习，是最常见的方式</p>\n<h3 id=\"2-Online\"><a href=\"#2-Online\" class=\"headerlink\" title=\"2) Online\"></a>2) Online</h3><p>在线（online）学习就是一点一点将数据传输进去，如增强学习；</p>\n<h3 id=\"3-Active\"><a href=\"#3-Active\" class=\"headerlink\" title=\"3) Active\"></a>3) Active</h3><p>主动（active）学习是主动提出问题让算法解决，可以节省大量的训练和标记消耗。类似于让机器提问题，告诉我们机器有什么问题不会，从而教它</p>\n<hr>\n<p><br><br></p>\n<h2 id=\"4-Learning-with-Different-Input-Space\"><a href=\"#4-Learning-with-Different-Input-Space\" class=\"headerlink\" title=\"4. Learning with Different Input Space\"></a>4. Learning with Different Input Space</h2><p>不同的输入空间:具体特征（Concrete Features），原始特征（Raw Features），抽象特征（Abstract Features）</p>\n<h3 id=\"1-Concrete-Features\"><a href=\"#1-Concrete-Features\" class=\"headerlink\" title=\"1) Concrete Features\"></a>1) Concrete Features</h3><p>具体特征（Concrete Features），具体特征最大特点就是便于机器学习的处理，这种情况是人类或者机器通过一定的方式提取获得的，具有实用性。</p>\n<h3 id=\"2-Raw-Features\"><a href=\"#2-Raw-Features\" class=\"headerlink\" title=\"2) Raw Features\"></a>2) Raw Features</h3><p>原始特征（Raw Features），如图片的像素等等，是最为常见到的资料，但是需要经过处理，转换成具体特征，才容易使用，实用性不太大。</p>\n<h3 id=\"3-Abstract-Features\"><a href=\"#3-Abstract-Features\" class=\"headerlink\" title=\"3) Abstract Features\"></a>3) Abstract Features</h3><p>抽象特征（Abstract Features），如一些ID之类的看似无意义的数据，这就更需要特征的转换、提取等工作（相对于原始特征而言），几乎没有实用性。</p>\n<hr>\n<p><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>A collection of concept of different Learning types.</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"4.When can Machine Learn? - Feasible of Learning","date":"2017-10-06T08:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# When can Machine Learn? - Feasible of Learning\n\n> 这章主要讨论 Whether machine learning is possible or not.\n\n\n## 1. Learning is Impossible?\n在讨论之前，先看下面的一个问题\n\n![Learning Puzzle](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3fb303bc1e0eceffd4c6a3dc62dbb9b8bf078c43/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-1%20Learning%20Puzzle.png)\n\n<center>图一 Learning Puzzle <sup>[1]</sup></center>\n\n<br>\n这类似于一道智商题,却没有标准答案，根据你不同的一个视角，可以找到不同的规则。比如：\n\n1. 左上角的正方形是否涂黑\n2. 是否对称\n3. 正中间的正方形是否涂黑\n4. ...\n\n所以无论机器学到的是什么模型，其他人都能说机器说错了。也就是说机器不能真的学习了。\n\n----------------------------------------\n<br><br>\n\n## 2. Probability of the Rescue\n\n### 1) Hoeffding Inequity\n\n上面提到了机器不能学习，因为机器求出来的假设函数$g(x)$很难与目标函数$f(x)$一样：因为数据不一样。 但是根据Hoeffding不等式（公式1），可以证明，在数据量足够大的情况，可以保证$g(x)$很接近于$$f(x)$.\n\n$$\n\\rho \\left[ \\lvert \\nu - \\mu \\rvert  > \\epsilon\\right ] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$1$}\n$$\n\n>其中 $\\rho$为概率符号， $\\lvert \\nu - \\mu \\rvert$表示2个值的近似程度， \n\n$\\epsilon$是这个近似程度的下界，$N$为样本数量的大小，所以不等式的意思是两个值的差别大于 $\\epsilon$的概率小于等于 $2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)$。所以，如果当 $\\epsilon$一定的情况下， 随着样本数量 $N$越大，那么这个差距的可能性越小（参考 $e^{-n}$ 的曲线），当 $\\epsilon$很小且 $N$大到一定的程度的时候，$\\mu$和 $\\nu$差别很小的概率很低，即 $\\mu$和 $\\nu$相等是一个大概近似正确（Probably Approximately Correct, PAC）的情况。\n\n\n下面举例说明公式的意义（以概率统计中的从罐子中有放回的取球为例），如图二。\n\n![Sampling](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/36d1fe3ba6ea839628bebdfebf2dc55e1ca202d4/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-2%20Sampling.png)\n\n<center> 图二 Sampling<sup>[2]</sup></center>\n\n\n罐子中只有橙色和绿色的球，其中橙色球的概率为 $\\mu$,那么绿色球的概率为 $1-\\mu$， 如果通过抽样，得到橙色球的概率为 $\\nu$，那么绿色球的概率为$1-\\nu$（其中，$\\mu$是假设的，是未知的，$\\nu$而是通过抽样得到的，已知的)。因为抽样的罐子是均匀是，所以抽样得到的橙色球的概率 $\\nu$要近似于实际罐子中橙色球的概率 $\\mu$。这个近似值得范围就是Hoeffding Inequity所表示的。\n\n\n---------------------\n\n### 2) Connection Between Hoeffding Inequity and Learning\n\n下面引用PPT里面的对比图来进行解释。\n\n![Connection to Learning](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a1422a508266710d0f3a0b90c5227c7400307921/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-3%20Connection%20To%20Learning.png)\n\n<center> 图三 Connetion to Learning <sup>[3]</sup></center>\n\n\n上面的抽样调查中，我们关键有： 罐子中橙色球的实际概率 $\\mu$, 抽样出来的球 ∈ 罐子，抽样的橙色球概率，抽样得到的绿色球概率\n对应到实际学习中就是： 实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$, 训练样本$x$ ∈ 整个数据集 $X$，训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$, 训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,\n\n并且可以得到以下公式（2）和公式（3）\n$$\n\\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$2$}\n$$\n\n$$\n\\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$3$}\n$$\n\n> $\\epsilon$表示为期望值，即实际样本中的错误率 $E_{out}$\n\n为了查看方便，列个表格进行说明\n\n罐子|机器学习\n-|-|\n罐子中橙色球的实际概率 $\\mu$    | 实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$\n抽样出来的球 ∈ 罐子            | 训练样本$x$ ∈ 整个数据集 $X$\n抽样的橙色球概率               |训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$\n抽样得到的绿色球概率           |训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,\n\n\n因此结合Hoeffding的理论支持后，我们可以扩展机器学习的流程图，如图四所示。\n\n![New Learning Diagram](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b89d9143e63c41c2d334d8471c8fa7730702458e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-4%20Learning%20Diagram.png)\n\n<center> 图四 New Learning Diagram <sup>[3]</sup></center>\n\n\n> 其中虚线表示未知概率 $\\rho$ 对随机抽样以及实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$  的影响，实线表示训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$。\n\n上面提到的$E_{in}$ $E_{out}$ 可以分别用下面的公式（4）（5）表示\n$$\nE_{in} = \\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$4$}\n$$\n$$\nE_{out} = \\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$5$}\n$$\n\n所以Hoedding的不等式可以变成公式（6）\n接近于$f(x)$.\n$$\n\\rho \\left[ \\lvert E_{in} - E_{out} \\rvert  > \\epsilon\\right] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$6$}\n$$\n同样的，当 $\\epsilon$一定（一般都很小），并且训练样本 $N$足够大的情况下，我们有 $E_{in} \\approx E_{out}$，也就是说 $g(x) \\approx f(x)$，这时候的流程图就变成了一个 $h$对应一个 $f$的情况了，如图五所示。\n\n![A Verification Flow](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9007d438d4541ff836281cc7d1648bbcdbad927c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-5%20Learning%20Diagram%20-%20the%20verification%20flow.png)\n\n<center> 图五 A Verification Flow <sup>[3]</sup></center>\n\n<br>\n但这个并非是真正意义上的学习，因为只有一个Hypothesis(因为通过一个一段数据集，我们只能得到一个Hypothesis)，所以我们下面讨论多个。\n\n### 3) Connection Between Hoeffding Inequity and Real Learning\n上面我们讨论了根据Hoeffding Inequity，在 $N$无限大的时候，一个Hypothesis的 $\\lvert E_{in} - E_{out} \\rvert < \\epsilon$的概率会无限的小，所以同时满足 $\\epsilon$ 很小 且 $N$很大的情况下，我们可以得到 $E_{in} \\approx E_{out}$。\n\n> 疑问：但是在应对多个Hypothesis的时候，我们就有多个 $h(x)$ 和多个 $E_{in}$，那样我们真的能确定 $E_{in} \\approx E_{out}$ 吗？\n\n#### ① Introduction of Bad Data\n在连续抛5次硬币过程中，一个人抛到正面朝上的概率为 $\\frac{1}{32}$，如果现在有150个人，那么这150个人里面，至少有一个人5次都抛出正面朝上的几率为 $1- (\\frac{31}{32})^{150} > 99\\%$。\n> 分析： 因为一个人连续5次抛出正面朝上几率为 $\\frac{1}{32} < 3\\%$， 所以如果机器学习的话，在测试的时候他更偏向于预测“不能连续抛出5次正面朝上”（因为选择会偏向于选择概率更大的一边）。但是当150次试验的时候，一个人连续5次抛出正面朝上的几率 $E_{out}>99\\%$，而在训练的时候的概率$E_{in} < 3\\%$，也就是说机器学习了之后进行了错误的估计（即$E_{in} 远远\\neq E_{out}$。导致这种结果的几率就是所谓的 bad data（也就是Noise:偏差值，数据与所需数据不吻合等）。\n\n> 疑问：\n>\n> 1.如果说存在bad data，那样的话怎么区分呢？（下面会证明bad data出现的概率）。\n>\n> 2.如果万一 $E_{in}$ 很大的话，那么 $E_{out}$ 也很大，那么这机器学习还什么意义呢？(这个问题后面解释)\n\n#### ② Probability of Bad Data\n\n首先在单个假设的时候如图六所示\n\n![Bad Data for One h](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-6%20bad%20data%20for%20one%20H.png)\n\n<center> 图六 Bad Data for One h<sup>[4]</sup></center>\n\n而在多个假设的时候如图七所示\n\n![Bad Data for Many h](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-7%20bad%20data%20for%20many%20H.png)\n\n<center> 图七 Bad Data for Many h<sup>[4]</sup></center>\n\n最后计算 Bad Data发生的概率如图8所示。\n\n![Bound of Bad Data](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-8%20bound%20of%20bad%20data.png)\n\n<center> 图八 Bound of Bad Data<sup>[4]</sup></center>\n\n\n> 由计算结果可以发现，这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$\n\n总结如下表：\n\n-                              | M很小的时候 | M很大的时候 | N很小的时候 | N很大的时候 |\n-                              |:----------:|:----------:|:----------:|:----------:|\n$E_{in}(g) \\approx E_{out}(g)$ |Yes，Bad Data的数量也少了| No，Bad Data的数量也多了         |Yes，Bad Data出现的概率变小了 | No，Bad Data出现的概率变大了\n$E_{in}(g) \\approx 0$          |No，选到低错误率的可能性变小了|Yes，选到低错误率的可能性变大了|没必然联系，样本总数多于少，与错误率无关|没必然联系，样本总数多于少，与错误率无关\n\n最终我们的Learning Flow 就可以变成图9。\n\n![The Statistic Learning Flow](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-9%20statistic%20learning%20flow.png)\n\n<center> 图九 The Statistic Learning Flow<sup>[4]</sup></center>\n\n> 在足够样本的情况下，机器算是能学到东西了!\n\n----------------------------------------\n<br><br>\n\n\n# Summary\n这章主要讨论 Whether machine learning is possible or not.\n思路：\n1. 首先直线学习是不可能的：因为输入样本与实际测试样本差别可能很大\n2. 1中讨论的情况是事情，但是有根据统计学中的Hoeffding不等式，可以有补救的办法（某种程度上，可以使得学习后的机器在实际测试中有较小的错误），然后根据Hoeffding不等式，来联系机器学习，说明机器学习是某种程度上可行的\n\n\n----------------------------------------\n<br><br>\n\n\n# Reference\n1.机器学习基石(台湾大学-林轩田)\\4\\4 - 1 - Learning is Impossible- (13-32)\n\n2.机器学习基石(台湾大学-林轩田)\\4\\4 - 2 - Probability to the Rescue (11-33)\n\n3.机器学习基石(台湾大学-林轩田)\\4\\4 - 3 - Connection to Learning (16-46)\n\n4.机器学习基石(台湾大学-林轩田)\\4\\4 - 4 - Connection to Real Learning (18-06)\n\n<br><br>\n----------------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-06-4.When can Machine Learn - Feasible of Learning.md","raw":"---\ntitle: 4.When can Machine Learn? - Feasible of Learning\ndate: 2017-10-06 16:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# When can Machine Learn? - Feasible of Learning\n\n> 这章主要讨论 Whether machine learning is possible or not.\n\n\n## 1. Learning is Impossible?\n在讨论之前，先看下面的一个问题\n\n![Learning Puzzle](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3fb303bc1e0eceffd4c6a3dc62dbb9b8bf078c43/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-1%20Learning%20Puzzle.png)\n\n<center>图一 Learning Puzzle <sup>[1]</sup></center>\n\n<br>\n这类似于一道智商题,却没有标准答案，根据你不同的一个视角，可以找到不同的规则。比如：\n\n1. 左上角的正方形是否涂黑\n2. 是否对称\n3. 正中间的正方形是否涂黑\n4. ...\n\n所以无论机器学到的是什么模型，其他人都能说机器说错了。也就是说机器不能真的学习了。\n\n----------------------------------------\n<br><br>\n\n## 2. Probability of the Rescue\n\n### 1) Hoeffding Inequity\n\n上面提到了机器不能学习，因为机器求出来的假设函数$g(x)$很难与目标函数$f(x)$一样：因为数据不一样。 但是根据Hoeffding不等式（公式1），可以证明，在数据量足够大的情况，可以保证$g(x)$很接近于$$f(x)$.\n\n$$\n\\rho \\left[ \\lvert \\nu - \\mu \\rvert  > \\epsilon\\right ] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$1$}\n$$\n\n>其中 $\\rho$为概率符号， $\\lvert \\nu - \\mu \\rvert$表示2个值的近似程度， \n\n$\\epsilon$是这个近似程度的下界，$N$为样本数量的大小，所以不等式的意思是两个值的差别大于 $\\epsilon$的概率小于等于 $2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)$。所以，如果当 $\\epsilon$一定的情况下， 随着样本数量 $N$越大，那么这个差距的可能性越小（参考 $e^{-n}$ 的曲线），当 $\\epsilon$很小且 $N$大到一定的程度的时候，$\\mu$和 $\\nu$差别很小的概率很低，即 $\\mu$和 $\\nu$相等是一个大概近似正确（Probably Approximately Correct, PAC）的情况。\n\n\n下面举例说明公式的意义（以概率统计中的从罐子中有放回的取球为例），如图二。\n\n![Sampling](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/36d1fe3ba6ea839628bebdfebf2dc55e1ca202d4/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-2%20Sampling.png)\n\n<center> 图二 Sampling<sup>[2]</sup></center>\n\n\n罐子中只有橙色和绿色的球，其中橙色球的概率为 $\\mu$,那么绿色球的概率为 $1-\\mu$， 如果通过抽样，得到橙色球的概率为 $\\nu$，那么绿色球的概率为$1-\\nu$（其中，$\\mu$是假设的，是未知的，$\\nu$而是通过抽样得到的，已知的)。因为抽样的罐子是均匀是，所以抽样得到的橙色球的概率 $\\nu$要近似于实际罐子中橙色球的概率 $\\mu$。这个近似值得范围就是Hoeffding Inequity所表示的。\n\n\n---------------------\n\n### 2) Connection Between Hoeffding Inequity and Learning\n\n下面引用PPT里面的对比图来进行解释。\n\n![Connection to Learning](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a1422a508266710d0f3a0b90c5227c7400307921/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-3%20Connection%20To%20Learning.png)\n\n<center> 图三 Connetion to Learning <sup>[3]</sup></center>\n\n\n上面的抽样调查中，我们关键有： 罐子中橙色球的实际概率 $\\mu$, 抽样出来的球 ∈ 罐子，抽样的橙色球概率，抽样得到的绿色球概率\n对应到实际学习中就是： 实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$, 训练样本$x$ ∈ 整个数据集 $X$，训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$, 训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,\n\n并且可以得到以下公式（2）和公式（3）\n$$\n\\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$2$}\n$$\n\n$$\n\\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$3$}\n$$\n\n> $\\epsilon$表示为期望值，即实际样本中的错误率 $E_{out}$\n\n为了查看方便，列个表格进行说明\n\n罐子|机器学习\n-|-|\n罐子中橙色球的实际概率 $\\mu$    | 实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$\n抽样出来的球 ∈ 罐子            | 训练样本$x$ ∈ 整个数据集 $X$\n抽样的橙色球概率               |训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$\n抽样得到的绿色球概率           |训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,\n\n\n因此结合Hoeffding的理论支持后，我们可以扩展机器学习的流程图，如图四所示。\n\n![New Learning Diagram](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b89d9143e63c41c2d334d8471c8fa7730702458e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-4%20Learning%20Diagram.png)\n\n<center> 图四 New Learning Diagram <sup>[3]</sup></center>\n\n\n> 其中虚线表示未知概率 $\\rho$ 对随机抽样以及实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$  的影响，实线表示训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$。\n\n上面提到的$E_{in}$ $E_{out}$ 可以分别用下面的公式（4）（5）表示\n$$\nE_{in} = \\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$4$}\n$$\n$$\nE_{out} = \\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$5$}\n$$\n\n所以Hoedding的不等式可以变成公式（6）\n接近于$f(x)$.\n$$\n\\rho \\left[ \\lvert E_{in} - E_{out} \\rvert  > \\epsilon\\right] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$6$}\n$$\n同样的，当 $\\epsilon$一定（一般都很小），并且训练样本 $N$足够大的情况下，我们有 $E_{in} \\approx E_{out}$，也就是说 $g(x) \\approx f(x)$，这时候的流程图就变成了一个 $h$对应一个 $f$的情况了，如图五所示。\n\n![A Verification Flow](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9007d438d4541ff836281cc7d1648bbcdbad927c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-5%20Learning%20Diagram%20-%20the%20verification%20flow.png)\n\n<center> 图五 A Verification Flow <sup>[3]</sup></center>\n\n<br>\n但这个并非是真正意义上的学习，因为只有一个Hypothesis(因为通过一个一段数据集，我们只能得到一个Hypothesis)，所以我们下面讨论多个。\n\n### 3) Connection Between Hoeffding Inequity and Real Learning\n上面我们讨论了根据Hoeffding Inequity，在 $N$无限大的时候，一个Hypothesis的 $\\lvert E_{in} - E_{out} \\rvert < \\epsilon$的概率会无限的小，所以同时满足 $\\epsilon$ 很小 且 $N$很大的情况下，我们可以得到 $E_{in} \\approx E_{out}$。\n\n> 疑问：但是在应对多个Hypothesis的时候，我们就有多个 $h(x)$ 和多个 $E_{in}$，那样我们真的能确定 $E_{in} \\approx E_{out}$ 吗？\n\n#### ① Introduction of Bad Data\n在连续抛5次硬币过程中，一个人抛到正面朝上的概率为 $\\frac{1}{32}$，如果现在有150个人，那么这150个人里面，至少有一个人5次都抛出正面朝上的几率为 $1- (\\frac{31}{32})^{150} > 99\\%$。\n> 分析： 因为一个人连续5次抛出正面朝上几率为 $\\frac{1}{32} < 3\\%$， 所以如果机器学习的话，在测试的时候他更偏向于预测“不能连续抛出5次正面朝上”（因为选择会偏向于选择概率更大的一边）。但是当150次试验的时候，一个人连续5次抛出正面朝上的几率 $E_{out}>99\\%$，而在训练的时候的概率$E_{in} < 3\\%$，也就是说机器学习了之后进行了错误的估计（即$E_{in} 远远\\neq E_{out}$。导致这种结果的几率就是所谓的 bad data（也就是Noise:偏差值，数据与所需数据不吻合等）。\n\n> 疑问：\n>\n> 1.如果说存在bad data，那样的话怎么区分呢？（下面会证明bad data出现的概率）。\n>\n> 2.如果万一 $E_{in}$ 很大的话，那么 $E_{out}$ 也很大，那么这机器学习还什么意义呢？(这个问题后面解释)\n\n#### ② Probability of Bad Data\n\n首先在单个假设的时候如图六所示\n\n![Bad Data for One h](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-6%20bad%20data%20for%20one%20H.png)\n\n<center> 图六 Bad Data for One h<sup>[4]</sup></center>\n\n而在多个假设的时候如图七所示\n\n![Bad Data for Many h](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-7%20bad%20data%20for%20many%20H.png)\n\n<center> 图七 Bad Data for Many h<sup>[4]</sup></center>\n\n最后计算 Bad Data发生的概率如图8所示。\n\n![Bound of Bad Data](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-8%20bound%20of%20bad%20data.png)\n\n<center> 图八 Bound of Bad Data<sup>[4]</sup></center>\n\n\n> 由计算结果可以发现，这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$\n\n总结如下表：\n\n-                              | M很小的时候 | M很大的时候 | N很小的时候 | N很大的时候 |\n-                              |:----------:|:----------:|:----------:|:----------:|\n$E_{in}(g) \\approx E_{out}(g)$ |Yes，Bad Data的数量也少了| No，Bad Data的数量也多了         |Yes，Bad Data出现的概率变小了 | No，Bad Data出现的概率变大了\n$E_{in}(g) \\approx 0$          |No，选到低错误率的可能性变小了|Yes，选到低错误率的可能性变大了|没必然联系，样本总数多于少，与错误率无关|没必然联系，样本总数多于少，与错误率无关\n\n最终我们的Learning Flow 就可以变成图9。\n\n![The Statistic Learning Flow](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-9%20statistic%20learning%20flow.png)\n\n<center> 图九 The Statistic Learning Flow<sup>[4]</sup></center>\n\n> 在足够样本的情况下，机器算是能学到东西了!\n\n----------------------------------------\n<br><br>\n\n\n# Summary\n这章主要讨论 Whether machine learning is possible or not.\n思路：\n1. 首先直线学习是不可能的：因为输入样本与实际测试样本差别可能很大\n2. 1中讨论的情况是事情，但是有根据统计学中的Hoeffding不等式，可以有补救的办法（某种程度上，可以使得学习后的机器在实际测试中有较小的错误），然后根据Hoeffding不等式，来联系机器学习，说明机器学习是某种程度上可行的\n\n\n----------------------------------------\n<br><br>\n\n\n# Reference\n1.机器学习基石(台湾大学-林轩田)\\4\\4 - 1 - Learning is Impossible- (13-32)\n\n2.机器学习基石(台湾大学-林轩田)\\4\\4 - 2 - Probability to the Rescue (11-33)\n\n3.机器学习基石(台湾大学-林轩田)\\4\\4 - 3 - Connection to Learning (16-46)\n\n4.机器学习基石(台湾大学-林轩田)\\4\\4 - 4 - Connection to Real Learning (18-06)\n\n<br><br>\n----------------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-06-4.When can Machine Learn - Feasible of Learning","published":1,"updated":"2018-10-27T04:30:42.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bl001de0owzjxss9bh","content":"<h1 id=\"When-can-Machine-Learn-Feasible-of-Learning\"><a href=\"#When-can-Machine-Learn-Feasible-of-Learning\" class=\"headerlink\" title=\"When can Machine Learn? - Feasible of Learning\"></a>When can Machine Learn? - Feasible of Learning</h1><blockquote>\n<p>这章主要讨论 Whether machine learning is possible or not.</p>\n</blockquote>\n<h2 id=\"1-Learning-is-Impossible\"><a href=\"#1-Learning-is-Impossible\" class=\"headerlink\" title=\"1. Learning is Impossible?\"></a>1. Learning is Impossible?</h2><p>在讨论之前，先看下面的一个问题</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3fb303bc1e0eceffd4c6a3dc62dbb9b8bf078c43/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-1%20Learning%20Puzzle.png\" alt=\"Learning Puzzle\"></p>\n<center>图一 Learning Puzzle <sup>[1]</sup></center>\n\n<p><br><br>这类似于一道智商题,却没有标准答案，根据你不同的一个视角，可以找到不同的规则。比如：</p>\n<ol>\n<li>左上角的正方形是否涂黑</li>\n<li>是否对称</li>\n<li>正中间的正方形是否涂黑</li>\n<li>…</li>\n</ol>\n<p>所以无论机器学到的是什么模型，其他人都能说机器说错了。也就是说机器不能真的学习了。</p>\n<hr>\n<p><br><br></p>\n<h2 id=\"2-Probability-of-the-Rescue\"><a href=\"#2-Probability-of-the-Rescue\" class=\"headerlink\" title=\"2. Probability of the Rescue\"></a>2. Probability of the Rescue</h2><h3 id=\"1-Hoeffding-Inequity\"><a href=\"#1-Hoeffding-Inequity\" class=\"headerlink\" title=\"1) Hoeffding Inequity\"></a>1) Hoeffding Inequity</h3><p>上面提到了机器不能学习，因为机器求出来的假设函数$g(x)$很难与目标函数$f(x)$一样：因为数据不一样。 但是根据Hoeffding不等式（公式1），可以证明，在数据量足够大的情况，可以保证$g(x)$很接近于$$f(x)$.</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert \\nu - \\mu \\rvert  > \\epsilon\\right ] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$1$}</script><blockquote>\n<p>其中 $\\rho$为概率符号， $\\lvert \\nu - \\mu \\rvert$表示2个值的近似程度， </p>\n</blockquote>\n<p>$\\epsilon$是这个近似程度的下界，$N$为样本数量的大小，所以不等式的意思是两个值的差别大于 $\\epsilon$的概率小于等于 $2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)$。所以，如果当 $\\epsilon$一定的情况下， 随着样本数量 $N$越大，那么这个差距的可能性越小（参考 $e^{-n}$ 的曲线），当 $\\epsilon$很小且 $N$大到一定的程度的时候，$\\mu$和 $\\nu$差别很小的概率很低，即 $\\mu$和 $\\nu$相等是一个大概近似正确（Probably Approximately Correct, PAC）的情况。</p>\n<p>下面举例说明公式的意义（以概率统计中的从罐子中有放回的取球为例），如图二。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/36d1fe3ba6ea839628bebdfebf2dc55e1ca202d4/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-2%20Sampling.png\" alt=\"Sampling\"></p>\n<center> 图二 Sampling<sup>[2]</sup></center>\n\n\n<p>罐子中只有橙色和绿色的球，其中橙色球的概率为 $\\mu$,那么绿色球的概率为 $1-\\mu$， 如果通过抽样，得到橙色球的概率为 $\\nu$，那么绿色球的概率为$1-\\nu$（其中，$\\mu$是假设的，是未知的，$\\nu$而是通过抽样得到的，已知的)。因为抽样的罐子是均匀是，所以抽样得到的橙色球的概率 $\\nu$要近似于实际罐子中橙色球的概率 $\\mu$。这个近似值得范围就是Hoeffding Inequity所表示的。</p>\n<hr>\n<h3 id=\"2-Connection-Between-Hoeffding-Inequity-and-Learning\"><a href=\"#2-Connection-Between-Hoeffding-Inequity-and-Learning\" class=\"headerlink\" title=\"2) Connection Between Hoeffding Inequity and Learning\"></a>2) Connection Between Hoeffding Inequity and Learning</h3><p>下面引用PPT里面的对比图来进行解释。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a1422a508266710d0f3a0b90c5227c7400307921/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-3%20Connection%20To%20Learning.png\" alt=\"Connection to Learning\"></p>\n<center> 图三 Connetion to Learning <sup>[3]</sup></center>\n\n\n<p>上面的抽样调查中，我们关键有： 罐子中橙色球的实际概率 $\\mu$, 抽样出来的球 ∈ 罐子，抽样的橙色球概率，抽样得到的绿色球概率<br>对应到实际学习中就是： 实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$, 训练样本$x$ ∈ 整个数据集 $X$，训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$, 训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,</p>\n<p>并且可以得到以下公式（2）和公式（3）</p>\n<script type=\"math/tex; mode=display\">\n\\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$2$}</script><script type=\"math/tex; mode=display\">\n\\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$3$}</script><blockquote>\n<p>$\\epsilon$表示为期望值，即实际样本中的错误率 $E_{out}$</p>\n</blockquote>\n<p>为了查看方便，列个表格进行说明</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>罐子</th>\n<th>机器学习</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>罐子中橙色球的实际概率 $\\mu$</td>\n<td>实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$</td>\n</tr>\n<tr>\n<td>抽样出来的球 ∈ 罐子</td>\n<td>训练样本$x$ ∈ 整个数据集 $X$</td>\n</tr>\n<tr>\n<td>抽样的橙色球概率</td>\n<td>训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$</td>\n</tr>\n<tr>\n<td>抽样得到的绿色球概率</td>\n<td>训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>因此结合Hoeffding的理论支持后，我们可以扩展机器学习的流程图，如图四所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b89d9143e63c41c2d334d8471c8fa7730702458e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-4%20Learning%20Diagram.png\" alt=\"New Learning Diagram\"></p>\n<center> 图四 New Learning Diagram <sup>[3]</sup></center>\n\n\n<blockquote>\n<p>其中虚线表示未知概率 $\\rho$ 对随机抽样以及实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$  的影响，实线表示训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$。</p>\n</blockquote>\n<p>上面提到的$E_{in}$ $E_{out}$ 可以分别用下面的公式（4）（5）表示</p>\n<script type=\"math/tex; mode=display\">\nE_{in} = \\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\nE_{out} = \\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$5$}</script><p>所以Hoedding的不等式可以变成公式（6）<br>接近于$f(x)$.</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in} - E_{out} \\rvert  > \\epsilon\\right] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$6$}</script><p>同样的，当 $\\epsilon$一定（一般都很小），并且训练样本 $N$足够大的情况下，我们有 $E_{in} \\approx E_{out}$，也就是说 $g(x) \\approx f(x)$，这时候的流程图就变成了一个 $h$对应一个 $f$的情况了，如图五所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9007d438d4541ff836281cc7d1648bbcdbad927c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-5%20Learning%20Diagram%20-%20the%20verification%20flow.png\" alt=\"A Verification Flow\"></p>\n<center> 图五 A Verification Flow <sup>[3]</sup></center>\n\n<p><br><br>但这个并非是真正意义上的学习，因为只有一个Hypothesis(因为通过一个一段数据集，我们只能得到一个Hypothesis)，所以我们下面讨论多个。</p>\n<h3 id=\"3-Connection-Between-Hoeffding-Inequity-and-Real-Learning\"><a href=\"#3-Connection-Between-Hoeffding-Inequity-and-Real-Learning\" class=\"headerlink\" title=\"3) Connection Between Hoeffding Inequity and Real Learning\"></a>3) Connection Between Hoeffding Inequity and Real Learning</h3><p>上面我们讨论了根据Hoeffding Inequity，在 $N$无限大的时候，一个Hypothesis的 $\\lvert E_{in} - E_{out} \\rvert &lt; \\epsilon$的概率会无限的小，所以同时满足 $\\epsilon$ 很小 且 $N$很大的情况下，我们可以得到 $E_{in} \\approx E_{out}$。</p>\n<blockquote>\n<p>疑问：但是在应对多个Hypothesis的时候，我们就有多个 $h(x)$ 和多个 $E_{in}$，那样我们真的能确定 $E_{in} \\approx E_{out}$ 吗？</p>\n</blockquote>\n<h4 id=\"①-Introduction-of-Bad-Data\"><a href=\"#①-Introduction-of-Bad-Data\" class=\"headerlink\" title=\"① Introduction of Bad Data\"></a>① Introduction of Bad Data</h4><p>在连续抛5次硬币过程中，一个人抛到正面朝上的概率为 $\\frac{1}{32}$，如果现在有150个人，那么这150个人里面，至少有一个人5次都抛出正面朝上的几率为 $1- (\\frac{31}{32})^{150} &gt; 99\\%$。</p>\n<blockquote>\n<p>分析： 因为一个人连续5次抛出正面朝上几率为 $\\frac{1}{32} &lt; 3\\%$， 所以如果机器学习的话，在测试的时候他更偏向于预测“不能连续抛出5次正面朝上”（因为选择会偏向于选择概率更大的一边）。但是当150次试验的时候，一个人连续5次抛出正面朝上的几率 $E_{out}&gt;99\\%$，而在训练的时候的概率$E_{in} &lt; 3\\%$，也就是说机器学习了之后进行了错误的估计（即$E_{in} 远远\\neq E_{out}$。导致这种结果的几率就是所谓的 bad data（也就是Noise:偏差值，数据与所需数据不吻合等）。</p>\n<p>疑问：</p>\n<p>1.如果说存在bad data，那样的话怎么区分呢？（下面会证明bad data出现的概率）。</p>\n<p>2.如果万一 $E_{in}$ 很大的话，那么 $E_{out}$ 也很大，那么这机器学习还什么意义呢？(这个问题后面解释)</p>\n</blockquote>\n<h4 id=\"②-Probability-of-Bad-Data\"><a href=\"#②-Probability-of-Bad-Data\" class=\"headerlink\" title=\"② Probability of Bad Data\"></a>② Probability of Bad Data</h4><p>首先在单个假设的时候如图六所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-6%20bad%20data%20for%20one%20H.png\" alt=\"Bad Data for One h\"></p>\n<center> 图六 Bad Data for One h<sup>[4]</sup></center>\n\n<p>而在多个假设的时候如图七所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-7%20bad%20data%20for%20many%20H.png\" alt=\"Bad Data for Many h\"></p>\n<center> 图七 Bad Data for Many h<sup>[4]</sup></center>\n\n<p>最后计算 Bad Data发生的概率如图8所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-8%20bound%20of%20bad%20data.png\" alt=\"Bound of Bad Data\"></p>\n<center> 图八 Bound of Bad Data<sup>[4]</sup></center>\n\n\n<blockquote>\n<p>由计算结果可以发现，这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$</p>\n</blockquote>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">M很小的时候</th>\n<th style=\"text-align:center\">M很大的时候</th>\n<th style=\"text-align:center\">N很小的时候</th>\n<th style=\"text-align:center\">N很大的时候</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$E_{in}(g) \\approx E_{out}(g)$</td>\n<td style=\"text-align:center\">Yes，Bad Data的数量也少了</td>\n<td style=\"text-align:center\">No，Bad Data的数量也多了</td>\n<td style=\"text-align:center\">Yes，Bad Data出现的概率变小了</td>\n<td style=\"text-align:center\">No，Bad Data出现的概率变大了</td>\n</tr>\n<tr>\n<td>$E_{in}(g) \\approx 0$</td>\n<td style=\"text-align:center\">No，选到低错误率的可能性变小了</td>\n<td style=\"text-align:center\">Yes，选到低错误率的可能性变大了</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>最终我们的Learning Flow 就可以变成图9。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-9%20statistic%20learning%20flow.png\" alt=\"The Statistic Learning Flow\"></p>\n<center> 图九 The Statistic Learning Flow<sup>[4]</sup></center>\n\n<blockquote>\n<p>在足够样本的情况下，机器算是能学到东西了!</p>\n</blockquote>\n<hr>\n<p><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>这章主要讨论 Whether machine learning is possible or not.<br>思路：</p>\n<ol>\n<li>首先直线学习是不可能的：因为输入样本与实际测试样本差别可能很大</li>\n<li>1中讨论的情况是事情，但是有根据统计学中的Hoeffding不等式，可以有补救的办法（某种程度上，可以使得学习后的机器在实际测试中有较小的错误），然后根据Hoeffding不等式，来联系机器学习，说明机器学习是某种程度上可行的</li>\n</ol>\n<hr>\n<p><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>1.机器学习基石(台湾大学-林轩田)\\4\\4 - 1 - Learning is Impossible- (13-32)</p>\n<p>2.机器学习基石(台湾大学-林轩田)\\4\\4 - 2 - Probability to the Rescue (11-33)</p>\n<p>3.机器学习基石(台湾大学-林轩田)\\4\\4 - 3 - Connection to Learning (16-46)</p>\n<p>4.机器学习基石(台湾大学-林轩田)\\4\\4 - 4 - Connection to Real Learning (18-06)</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"When-can-Machine-Learn-Feasible-of-Learning\"><a href=\"#When-can-Machine-Learn-Feasible-of-Learning\" class=\"headerlink\" title=\"When can Machine Learn? - Feasible of Learning\"></a>When can Machine Learn? - Feasible of Learning</h1><blockquote>\n<p>这章主要讨论 Whether machine learning is possible or not.</p>\n</blockquote>\n<h2 id=\"1-Learning-is-Impossible\"><a href=\"#1-Learning-is-Impossible\" class=\"headerlink\" title=\"1. Learning is Impossible?\"></a>1. Learning is Impossible?</h2><p>在讨论之前，先看下面的一个问题</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3fb303bc1e0eceffd4c6a3dc62dbb9b8bf078c43/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-1%20Learning%20Puzzle.png\" alt=\"Learning Puzzle\"></p>\n<center>图一 Learning Puzzle <sup>[1]</sup></center>\n\n<p><br><br>这类似于一道智商题,却没有标准答案，根据你不同的一个视角，可以找到不同的规则。比如：</p>\n<ol>\n<li>左上角的正方形是否涂黑</li>\n<li>是否对称</li>\n<li>正中间的正方形是否涂黑</li>\n<li>…</li>\n</ol>\n<p>所以无论机器学到的是什么模型，其他人都能说机器说错了。也就是说机器不能真的学习了。</p>\n<hr>\n<p><br><br></p>\n<h2 id=\"2-Probability-of-the-Rescue\"><a href=\"#2-Probability-of-the-Rescue\" class=\"headerlink\" title=\"2. Probability of the Rescue\"></a>2. Probability of the Rescue</h2><h3 id=\"1-Hoeffding-Inequity\"><a href=\"#1-Hoeffding-Inequity\" class=\"headerlink\" title=\"1) Hoeffding Inequity\"></a>1) Hoeffding Inequity</h3><p>上面提到了机器不能学习，因为机器求出来的假设函数$g(x)$很难与目标函数$f(x)$一样：因为数据不一样。 但是根据Hoeffding不等式（公式1），可以证明，在数据量足够大的情况，可以保证$g(x)$很接近于$$f(x)$.</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert \\nu - \\mu \\rvert  > \\epsilon\\right ] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$1$}</script><blockquote>\n<p>其中 $\\rho$为概率符号， $\\lvert \\nu - \\mu \\rvert$表示2个值的近似程度， </p>\n</blockquote>\n<p>$\\epsilon$是这个近似程度的下界，$N$为样本数量的大小，所以不等式的意思是两个值的差别大于 $\\epsilon$的概率小于等于 $2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)$。所以，如果当 $\\epsilon$一定的情况下， 随着样本数量 $N$越大，那么这个差距的可能性越小（参考 $e^{-n}$ 的曲线），当 $\\epsilon$很小且 $N$大到一定的程度的时候，$\\mu$和 $\\nu$差别很小的概率很低，即 $\\mu$和 $\\nu$相等是一个大概近似正确（Probably Approximately Correct, PAC）的情况。</p>\n<p>下面举例说明公式的意义（以概率统计中的从罐子中有放回的取球为例），如图二。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/36d1fe3ba6ea839628bebdfebf2dc55e1ca202d4/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-2%20Sampling.png\" alt=\"Sampling\"></p>\n<center> 图二 Sampling<sup>[2]</sup></center>\n\n\n<p>罐子中只有橙色和绿色的球，其中橙色球的概率为 $\\mu$,那么绿色球的概率为 $1-\\mu$， 如果通过抽样，得到橙色球的概率为 $\\nu$，那么绿色球的概率为$1-\\nu$（其中，$\\mu$是假设的，是未知的，$\\nu$而是通过抽样得到的，已知的)。因为抽样的罐子是均匀是，所以抽样得到的橙色球的概率 $\\nu$要近似于实际罐子中橙色球的概率 $\\mu$。这个近似值得范围就是Hoeffding Inequity所表示的。</p>\n<hr>\n<h3 id=\"2-Connection-Between-Hoeffding-Inequity-and-Learning\"><a href=\"#2-Connection-Between-Hoeffding-Inequity-and-Learning\" class=\"headerlink\" title=\"2) Connection Between Hoeffding Inequity and Learning\"></a>2) Connection Between Hoeffding Inequity and Learning</h3><p>下面引用PPT里面的对比图来进行解释。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a1422a508266710d0f3a0b90c5227c7400307921/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-3%20Connection%20To%20Learning.png\" alt=\"Connection to Learning\"></p>\n<center> 图三 Connetion to Learning <sup>[3]</sup></center>\n\n\n<p>上面的抽样调查中，我们关键有： 罐子中橙色球的实际概率 $\\mu$, 抽样出来的球 ∈ 罐子，抽样的橙色球概率，抽样得到的绿色球概率<br>对应到实际学习中就是： 实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$, 训练样本$x$ ∈ 整个数据集 $X$，训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$, 训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,</p>\n<p>并且可以得到以下公式（2）和公式（3）</p>\n<script type=\"math/tex; mode=display\">\n\\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$2$}</script><script type=\"math/tex; mode=display\">\n\\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$3$}</script><blockquote>\n<p>$\\epsilon$表示为期望值，即实际样本中的错误率 $E_{out}$</p>\n</blockquote>\n<p>为了查看方便，列个表格进行说明</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>罐子</th>\n<th>机器学习</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>罐子中橙色球的实际概率 $\\mu$</td>\n<td>实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$</td>\n</tr>\n<tr>\n<td>抽样出来的球 ∈ 罐子</td>\n<td>训练样本$x$ ∈ 整个数据集 $X$</td>\n</tr>\n<tr>\n<td>抽样的橙色球概率</td>\n<td>训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$</td>\n</tr>\n<tr>\n<td>抽样得到的绿色球概率</td>\n<td>训练过程中满足 $h(x) = g(x)$ 的概率 $1-E_{in}$,</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>因此结合Hoeffding的理论支持后，我们可以扩展机器学习的流程图，如图四所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b89d9143e63c41c2d334d8471c8fa7730702458e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-4%20Learning%20Diagram.png\" alt=\"New Learning Diagram\"></p>\n<center> 图四 New Learning Diagram <sup>[3]</sup></center>\n\n\n<blockquote>\n<p>其中虚线表示未知概率 $\\rho$ 对随机抽样以及实际测试中$h(x) \\neq g(x)$ 的概率 $E_{out}$  的影响，实线表示训练过程中满足 $h(x) \\neq g(x)$ 的概率 $E_{in}$。</p>\n</blockquote>\n<p>上面提到的$E_{in}$ $E_{out}$ 可以分别用下面的公式（4）（5）表示</p>\n<script type=\"math/tex; mode=display\">\nE_{in} = \\nu = \\frac{1}{N} \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]   \\quad (x_i ∈ X)\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\nE_{out} = \\mu = \\epsilon \\cdot \\sum\\limits_{i=1}^N \\left[\\left[ h(x_i) \\neq f(x_i) \\right]\\right]\n\\tag{$5$}</script><p>所以Hoedding的不等式可以变成公式（6）<br>接近于$f(x)$.</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in} - E_{out} \\rvert  > \\epsilon\\right] \\leq 2 \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$6$}</script><p>同样的，当 $\\epsilon$一定（一般都很小），并且训练样本 $N$足够大的情况下，我们有 $E_{in} \\approx E_{out}$，也就是说 $g(x) \\approx f(x)$，这时候的流程图就变成了一个 $h$对应一个 $f$的情况了，如图五所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9007d438d4541ff836281cc7d1648bbcdbad927c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-5%20Learning%20Diagram%20-%20the%20verification%20flow.png\" alt=\"A Verification Flow\"></p>\n<center> 图五 A Verification Flow <sup>[3]</sup></center>\n\n<p><br><br>但这个并非是真正意义上的学习，因为只有一个Hypothesis(因为通过一个一段数据集，我们只能得到一个Hypothesis)，所以我们下面讨论多个。</p>\n<h3 id=\"3-Connection-Between-Hoeffding-Inequity-and-Real-Learning\"><a href=\"#3-Connection-Between-Hoeffding-Inequity-and-Real-Learning\" class=\"headerlink\" title=\"3) Connection Between Hoeffding Inequity and Real Learning\"></a>3) Connection Between Hoeffding Inequity and Real Learning</h3><p>上面我们讨论了根据Hoeffding Inequity，在 $N$无限大的时候，一个Hypothesis的 $\\lvert E_{in} - E_{out} \\rvert &lt; \\epsilon$的概率会无限的小，所以同时满足 $\\epsilon$ 很小 且 $N$很大的情况下，我们可以得到 $E_{in} \\approx E_{out}$。</p>\n<blockquote>\n<p>疑问：但是在应对多个Hypothesis的时候，我们就有多个 $h(x)$ 和多个 $E_{in}$，那样我们真的能确定 $E_{in} \\approx E_{out}$ 吗？</p>\n</blockquote>\n<h4 id=\"①-Introduction-of-Bad-Data\"><a href=\"#①-Introduction-of-Bad-Data\" class=\"headerlink\" title=\"① Introduction of Bad Data\"></a>① Introduction of Bad Data</h4><p>在连续抛5次硬币过程中，一个人抛到正面朝上的概率为 $\\frac{1}{32}$，如果现在有150个人，那么这150个人里面，至少有一个人5次都抛出正面朝上的几率为 $1- (\\frac{31}{32})^{150} &gt; 99\\%$。</p>\n<blockquote>\n<p>分析： 因为一个人连续5次抛出正面朝上几率为 $\\frac{1}{32} &lt; 3\\%$， 所以如果机器学习的话，在测试的时候他更偏向于预测“不能连续抛出5次正面朝上”（因为选择会偏向于选择概率更大的一边）。但是当150次试验的时候，一个人连续5次抛出正面朝上的几率 $E_{out}&gt;99\\%$，而在训练的时候的概率$E_{in} &lt; 3\\%$，也就是说机器学习了之后进行了错误的估计（即$E_{in} 远远\\neq E_{out}$。导致这种结果的几率就是所谓的 bad data（也就是Noise:偏差值，数据与所需数据不吻合等）。</p>\n<p>疑问：</p>\n<p>1.如果说存在bad data，那样的话怎么区分呢？（下面会证明bad data出现的概率）。</p>\n<p>2.如果万一 $E_{in}$ 很大的话，那么 $E_{out}$ 也很大，那么这机器学习还什么意义呢？(这个问题后面解释)</p>\n</blockquote>\n<h4 id=\"②-Probability-of-Bad-Data\"><a href=\"#②-Probability-of-Bad-Data\" class=\"headerlink\" title=\"② Probability of Bad Data\"></a>② Probability of Bad Data</h4><p>首先在单个假设的时候如图六所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-6%20bad%20data%20for%20one%20H.png\" alt=\"Bad Data for One h\"></p>\n<center> 图六 Bad Data for One h<sup>[4]</sup></center>\n\n<p>而在多个假设的时候如图七所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f7bb05cf9a34185056b07452b108bcd7b2f13f8d/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-7%20bad%20data%20for%20many%20H.png\" alt=\"Bad Data for Many h\"></p>\n<center> 图七 Bad Data for Many h<sup>[4]</sup></center>\n\n<p>最后计算 Bad Data发生的概率如图8所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-8%20bound%20of%20bad%20data.png\" alt=\"Bound of Bad Data\"></p>\n<center> 图八 Bound of Bad Data<sup>[4]</sup></center>\n\n\n<blockquote>\n<p>由计算结果可以发现，这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$</p>\n</blockquote>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">M很小的时候</th>\n<th style=\"text-align:center\">M很大的时候</th>\n<th style=\"text-align:center\">N很小的时候</th>\n<th style=\"text-align:center\">N很大的时候</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$E_{in}(g) \\approx E_{out}(g)$</td>\n<td style=\"text-align:center\">Yes，Bad Data的数量也少了</td>\n<td style=\"text-align:center\">No，Bad Data的数量也多了</td>\n<td style=\"text-align:center\">Yes，Bad Data出现的概率变小了</td>\n<td style=\"text-align:center\">No，Bad Data出现的概率变大了</td>\n</tr>\n<tr>\n<td>$E_{in}(g) \\approx 0$</td>\n<td style=\"text-align:center\">No，选到低错误率的可能性变小了</td>\n<td style=\"text-align:center\">Yes，选到低错误率的可能性变大了</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>最终我们的Learning Flow 就可以变成图9。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a02388463f51e20944466bd7718bf2921b68e970/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter4-9%20statistic%20learning%20flow.png\" alt=\"The Statistic Learning Flow\"></p>\n<center> 图九 The Statistic Learning Flow<sup>[4]</sup></center>\n\n<blockquote>\n<p>在足够样本的情况下，机器算是能学到东西了!</p>\n</blockquote>\n<hr>\n<p><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>这章主要讨论 Whether machine learning is possible or not.<br>思路：</p>\n<ol>\n<li>首先直线学习是不可能的：因为输入样本与实际测试样本差别可能很大</li>\n<li>1中讨论的情况是事情，但是有根据统计学中的Hoeffding不等式，可以有补救的办法（某种程度上，可以使得学习后的机器在实际测试中有较小的错误），然后根据Hoeffding不等式，来联系机器学习，说明机器学习是某种程度上可行的</li>\n</ol>\n<hr>\n<p><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>1.机器学习基石(台湾大学-林轩田)\\4\\4 - 1 - Learning is Impossible- (13-32)</p>\n<p>2.机器学习基石(台湾大学-林轩田)\\4\\4 - 2 - Probability to the Rescue (11-33)</p>\n<p>3.机器学习基石(台湾大学-林轩田)\\4\\4 - 3 - Connection to Learning (16-46)</p>\n<p>4.机器学习基石(台湾大学-林轩田)\\4\\4 - 4 - Connection to Real Learning (18-06)</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"5.Why can Machine Learn?","date":"2017-10-08T08:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Why can Machine Learn?\n\n>这一节我的思路是把老师的第五，六、七节的内容结合起来了，并且思路不完全按照老师的授课来走。\n\n----------------------------------\n## 1. Preview of Last Chapter\n> 因为这一章的讨论是基于上一章最后一节得到的公式的，所以我们先Recap一下。\n\n上一节中，我们最后得出公式（1）（2）\n$$\n\\rho \\left[  BAD \\quad D \\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2N  \\right) \\\\\n\\tag{$1$}\n$$\n$$\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$2$}\n$$\n\n> 这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$\n\n总结如下表：\n\n-                              | M很小的时候 | M很大的时候 | N很小的时候 | N很大的时候 |\n-                              |:----------:|:----------:|:----------:|:----------:|\n$E_{in}(g) \\approx E_{out}(g)$ |Yes，Bad Data的数量也少了| No，Bad Data的数量也多了         |Yes，Bad Data出现的概率变小了 | No，Bad Data出现的概率变大了\n$E_{in}(g) \\approx 0$          |No，选到低错误率的可能性变小了|Yes，选到低错误率的可能性变大了|没必然联系，样本总数多于少，与错误率无关|没必然联系，样本总数多于少，与错误率无关\n\n>从表格中可以看出，$M$ 太大太小都会对机器学习的有效性造成影响，所以我们要进一步缩小$M$ 的取值范围。\n\n\n>问题：怎么缩小$M$的取值范围\n>\n>解决方案：在上一节中，我们再推导的过程中使用了联合上限（Union Bound)，造成实际的上限被放大了很多。因为在做集合的或运算的时候，我们单纯的把各个集合加起来，但是却没有减去他们的交集部分，所以造成了上限被放大的问题。\n\n关于Union Bound 的推导可以看这个链接[Boole's inequality](https://en.wikipedia.org/wiki/Boole%27s_inequality \"Boole's inequality\")\n\n总的来说就是因为我们推导公式（1）的时候使用了Union Bound，所以导致了不等式右边的值（上限）被放大了，所以现在我们可以把它进行缩减，求出有效的 $M$值(即 $M_H(N)$)，下面我们来推导这个有效值。\n\n## 2. VC Bound - A Upper Bound of Hoeffding Inequity\n### 1) Introduction\n场景：对于不同数量$N$的训练数据，有多少种不同的方法 $effective(N)$ 可以区分他们？\n\n当 $N=1$ 的时候，如图一所示，共有2种方法，$effective(N) = 2 = 2^1$。\n\n![N=1](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-1%20number%3D1.png)\n<center> 图一 N=1 <sup>[1]</sup></center>\n\n\n当 $N=2$ 的时候，如图二所示，共有4种方法，$effective(N) = 4 = 2^2$。\n\n![N=2](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-2%20number%3D2.png)\n<center> 图二 N=2 <sup>[1]</sup></center>\n\n\n当 $N=3$ 的时候，如图三、四所示，最多有8种方法，虽然说在特定的情形下，可能只有6中种方法，$effective(N) = 8 = 2^3$。\n\n![N=3 with error](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-4%20number%3D3%20with%20error.png)\n<center> 图三 N=3 with error <sup>[2]</sup></center>\n\n\n![N=3](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-3%20number%3D3.png)\n<center> 图四 N=3 <sup>[1]</sup></center>\n\n\n\n当 $N=4$ 的时候，如图五所示，无论怎么放着4个点，最多只有14种方法，$effective(N) = 14 < 2^4$。\n\n![N=4](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-5%20number%3D4.png)\n<center> 图五 N=4 <sup>[1]</sup></center>\n\n\n当 $N=5$ 的时候，很显然 $effective(N) = 32 <  2^5$，就不再继续讨论了。\n\n总结如下表：\n\nN|$effctive(N)$\n-  |-          |\n1  |$2 = 2^1$  |\n2  |$4 = 2^2$  |\n3  |$8 = 2^3$  |\n4  |$14 < 2^5$ |\n5  |$32 << 2^6$|\n...|...|\nN|$effctive(N) << 2^N$|\n\n总结如图六，可以看出当 $N>4$的时候，$effective(N) < 2^N$，也就是说我们把 $M和N$ 的关系构建了起来，所以我们可以用 $effective(N)$ 去替换 $M$，得到公式(3)\n\n$$\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2 \\cdot effective(N) \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$3$}\n$$\n\n![Summary](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-6%20summary.png)\n<center> 图六 Summary <sup>[1]</sup></center>\n\n\n\n### 2) Growth function\n上面Binary Clasification的分类方法叫做二分类法（dichotomy)，为了更好地表示 $N和effective(N)$ 的关系，我们引入成长函数（Growth Function) $M_H(N)$ 来表示，具体的数学表达如公式（4）所示。\n$$\nM_H(N) = \\max\\limits_{x_1,x_2,...,x_N ∈ X}  \\lvert H(x_1,x_2,...,x_N) \\rvert\n\\tag{$4$}  \\quad(其中，上限为2^N)\n$$\n\n### 3) Different Types of Growth function\n#### ① Growth Function for Positive Rays\n> Positive Rays 是用一个一维向量作用于一维坐标上，与该向量同方向的值为+1，反方向为-1\n如图七所示，Postives Rays 的成长函数为 $M_H(N) = (N-1)$，当 $N \\geq 2$的时候，$M_H(N) < 2^N = O(N)$\n\n![Growth Function for Positive Rays](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-7%20Growth%20Function%20for%20Positive%20Rays.png)\n<center> 图七 Growth Function for Positive Rays <sup>[2]</sup></center>\n\n\n\n#### ② Growth Function for Positive Interval\n> Positive Interval 是用一个一维“线段”作用于一维坐标上，与在线段里面的值为+1，外面的为-1\n如图八所示，Positive Interval 的成长函数为 $M_H(N) = C_{N+1}^2 + 1 = \\frac{1}{2}N^2 + \\frac{1}{2}N + 1$，当 $N \\geq 3$的时候，$M_H(N) < 2^N = O(N^2)$\n\n![Growth Function for Positive Interval](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-8%20Growth%20Function%20for%20Positive%20Intervals.png)\n<center> 图八 Growth Function for Positive Interval <sup>[2]</sup></center>\n\n\n\n#### ③ Growth Function for Convex Sets\n> Convex Sets 不太好理解。可以理解成在二维坐标上，用凸多边形去把所需要的点串起来。在多边形顶点上的点的值为+1，不在的为-1。因为我们讨论的是最大的可能性，所以当我们把所有的点都放在一个圆上的时候，必定存在一个凸多边形可以连接任意多个点（即可以画出任意多边形），然后再把所有点的组合情况加起来\n如图九所示，Convex Setsl 的成长函数为 $M_H(N) = \\sum\\limits_{i=0}^{N}C_{i}^{N} = 2^N$\n\n![Growth Function for Convex Sets](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-9%20Growth%20Function%20for%20Convex%20Sets.png)\n<center> 图九 Growth Function for Convex Sets <sup>[2]</sup></center>\n\n\n\n### 4) Break Point of Growth function\n我们称能满足完全二分类(出现不同种类的数量为$2^N$)的情况为shattered,能shattered的最大的点为突破点(break point)。\n然后根据上面对N从1-5的尝试，得到的最大可能性如下表\n\nN|$effctive(N)$\n-|-|\n1|$2 = 2^1$|\n2|$4 = 2^2$|\n3|$8 = 2^3$|\n4|$14 < 2^5$|\n5|$32 << 2^6$|\n...|...|\nN|$effctive(N) << 2^N$|\n\n可以推断出公式（3）\n$$\neffctive(N): M_H(N) \\leq \\max( possible \\quad M_H(N) \\quad Given \\quad break- point \\quad(K)) \\leq 2^N\n\\tag{$3$}\n$$\n\n\n上面关于Growth Function讨论的几种情况的Break Point 如图十所示，我们可以看出成长函数的复杂度与Break Point的大小存在一定的关系。\n\n![Break Point of Growth function](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/033cce3063c6d35c7ac55af137821cf97819be44/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-10%20Break%20Point.png)\n<center> 图十 Break Point of Growth function <sup>[3]</sup></center>\n\n\n### 5) Bounding Function\n#### ① Introduction of Bounding Function\n根据上一节的Break Point $K$和样本点 $N$的关系，我们引入一个新概念，上限函数(Bounding Function) $B(N,K)$。这个函数表示有$N$个样本点且成长函数的突破点是$K$的时候，最多有多少种组合情况，比如说$B(3,2) = 3$（这个比较容易想象，这里就不展开讨论了）。并且这个上限函数满足公式（4），因为这是采用而分类的方法来进行的，最大值为$2^N$。\n$$\nB(N,K) \\leq 2^N\n\\tag{$3$}\n$$\n\n但是显然在上面的例子中，我们可以看到$B(N,K) < 2^N \\quad(N \\geq K)$，所以我们下面进一步确定这个上限函数的最大值。\n\n#### ② Proof of Bounding Function\n\n我们下面用表格的方式来表示$B(N,K)$ 表格如下表，我们下面将会填满这个表格来找出相应的规律\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      |                        |                        |                        |                        |                        |                        | ... |\nN=2      |                        |                        |                        |                        |                        |                        | ... |\nN=3      |                        |                        |                        |                        |                        |                        | ... |\nN=4      |                        |                        |                        |                        |                        |                        | ... |\nN=5      |                        |                        |                        |                        |                        |                        | ... |\nN=6      |                        |                        |                        |                        |                        |                        | ... |\n...      |                        |                        |                        |                        |                        |                        | ... |\n\n1.根据上面的规律，我们知道在$N<K$的时候，$B(N,K) = 2^N$，所以表格更新如下\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      |                        | <font color=#FF0000>2</font>  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      |                        |                        | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      |                        |                        |                        | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      |                        |                        |                        |                        | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      |                        |                        |                        |                        |                        | <font color=#FF0000>32 | ... |\nN=6      |                        |                        |                        |                        |                        |                        | ... |\n...      |                        |                        |                        |                        |                        |                        | ... |\n\n2.然后当$K=1$的时候，我们至少有一种分法（全正或者全负），所以第一列全部为1，表格更新如下。\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  |                        | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  |                        |                        | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  |                        |                        |                        | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  |                        |                        |                        |                        | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n...      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n\n3.接着，当$N=K$的时候，我们上面也可以看到，所有的值最大都等于$2^N-1$(因为不能所有情况都出现一次)，所以表格更新如下。\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  | <font color=#FF0000>3  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  |                        | <font color=#FF0000>7  | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  |                        |                        | <font color=#FF0000>15 | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  |                        |                        |                        | <font color=#FF0000>31 | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  |                        |                        |                        |                        | <font color=#FF0000>63 | ... |\n...      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n\n4.在之前的章节，我们也数过$B(3,2) = 4$，其实看到这里我们已经大概有一些规律了：下面一项为上面两项之和， $B(N,K) = B(N-1, K) + B(N-1, K-1)$。当然我们只是猜测，下面我们继续证明。表格更新如下：\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  | <font color=#FF0000>3  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  | <font color=#F0FFF0)>4 | <font color=#FF0000>7  | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  |                        |                        | <font color=#FF0000>15 | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  |                        |                        |                        | <font color=#FF0000>31 | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  |                        |                        |                        |                        | <font color=#FF0000>63 | ... |\n...      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n\n\n5.我们证明上面的猜想$B(N,K) = B(N-1, K) + B(N-1, K-1)$\n1）首先我们遍历B(4,3)，可以得到图十一的结果，然后我们整理了一下结果的顺序，可以发现橙色区域 {$x_1,x_2,x_3$}结果分别出现了2次，而紫色区域的{$x_1,x_2,x_3$}结果只出现了1次。\n\n![Reorganized Dichotomies of B(4,3) - 1][11]\n\n[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\n\n<center> 图十一 Reorganized Dichotomies of B(4,3) - 1 <sup>[4]</sup></center>\n\n\n2）所以我们单独把{$x_1,x_2,x_3$}，提出来看，并把橙色区域的个数设为 $\\alpha$，紫色区域的个数为 $\\beta$，那么原来4个点的情况 $B(4,3) = 2 \\alpha + \\beta$，而3个点的情况 $B(3,3) = \\alpha + \\beta$，如下图十二所示。\n\n![Reorganized Dichotomies of B(4,3) - 2][12]\n\n[12]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%202.png\n\n<center> 图十二 Reorganized Dichotomies of B(4,3) - 2 <sup>[4]</sup></center>\n\n3)接着我们单独看 $\\alpha$可以发现这个刚好是 $B(3,2)$ 的最大可能性，也就是说$ \\alpha \\leq B(3,2) = 4 $，如图十三所示。\n\n![Reorganized Dichotomies of B(4,3) - 3][13]\n\n[13]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%203.png\n\n<center> 图十三 Reorganized Dichotomies of B(4,3) - 3 <sup>[4]</sup></center>\n\n\n4） 根据上面的分析，我们目前得到三个公式，如下面的公式（4）（5）（6）。\n$$\nB(4,5) = 2 \\cdot \\alpha + \\beta\n\\tag{$4$}\n$$\n$$\n\\alpha + \\beta \\leq B(3,3)\n\\tag{$5$}\n$$\n$$\n\\alpha \\leq B(3,2)\n\\tag{$6$}\n$$\n\n所以把公式(5)(6)加起来，我们可以更新公式（4）为公式（7）\n$$\nB(4,5) \\leq 2 \\cdot \\alpha + \\beta\n\\tag{$7$}\n$$\n\n5）最后我们用同样的方法来研究$B(N,K)$可以很容易证明到公式（8）（9）（10）\n$$\nB(N - 1,K) \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i}\n\\tag{$8$}\n$$\n$$\nB(N - 1,K - 1) \\leq \\sum\\limits_{i=0}^{k-2} C_{N-1}^{i} = \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i}\n\\tag{$9$}\n$$\n$$\n\\begin{align}\nB(N,K)  & \\leq {B(N-1,K) + B(N-1,K-1)} \\\\\n        & \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i} + \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i} \\\\\n        & = C_{N-1}^0 + \\sum\\limits_{i=1}^{k-1} \\left( C_{N-1}^{i} + C_{N-1}^{i}\\right)  \\\\\n        & = 1 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = C_{N}^0 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = \\sum\\limits_{i=0}^{k-1} C_{N}^{i}\n\\end{align}\n\\tag{$10$}\n$$\n\n所以我们的表格更新如下：\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  | <font color=#FF0000>3  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  | <font color=#F0FFF0)>4 | <font color=#FF0000>7  | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  | <font color=#FFA500)>$\\leq5$  | <font color=#FFA500>11  | <font color=#FF0000>15 | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  | <font color=#FFA500)>$\\leq6$  | <font color=#FFA500)>$\\leq16$  | <font color=#FFA500)>$\\leq15$  | <font color=#FF0000>31 | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  | <font color=#FFA500)>$\\leq7$  | <font color=#FFA500)>$\\leq22$  | <font color=#FFA500)>$\\leq26$  | <font color=#FFA500)>$\\leq57$  | <font color=#FF0000>63 | ... |\n...      | <font color=#0000FF>1  |              ...              |              ...              |              ...              |              ...              |              ...              | ... |\n\n我们再把$N^{K-1}$的表格整理如下：\n\n$N^{N-1}$|          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      |           1            |           1            |           1            |           1            |           1            |           1            | ... |\nN=2      |           1            |           2            |           4            |           8            |           8            |           16           | ... |\nN=3      |           1            |           3            |           9            |           27           |           27           |           81           | ... |\nN=4      |           1            |           4            |           16           |           64           |           64           |           256          | ... |\nN=5      |           1            |           5            |           25           |           125          |           125          |           625          | ... |\nN=6      |           1            |           6            |           36           |           216          |           216          |           1296         | ... |\n...      |          ...           |          ...           |          ...           |          ...           |          ...           |          ...           | ... |\n\n对比图参考老师上课的PPT，如图十四所示。\n\n![Comparision of B(N,K) and N^(K-1)][14]\n\n[14]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-14%20Comparision%20of%20B(N%2CK)%20and%20N%5E(K-1).png\n\n<center> 图十四 Comparision of B(N,K) and N^(K-1) <sup>[6]</sup></center>\n\n\n总结起来就是：在$N \\geq 2, K \\geq 3$的时候，总有公式（11）的情况。\n$$\nM_H(N) \\leq B(N,K) = \\sum\\limits_{i=0}^{K-1} \\leq N^{K-1}\n\\tag{$11$}\n$$\n\n\n### 6) Vapnik-Chervonenkis (VC) bound\n\n@TODO: 这一节主要是证明从数学的角度上证明VC Bound 并以此更新Hoeffding Inequity。目前听得失一知半解，所以只贴出结论，后面再补充。\n\n\n结论如图十五所示。\n\n![Vapnik-Chervonenkis (VC) bound](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/738603b7f8e8f10505a791140c32f4677d4e7d84/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-13%20VC%20bound.png)\n\n<center> 图十五 Vapnik-Chervonenkis (VC) bound <sup>[5]</sup></center>\n\n这个VC Bound的作用是把之前Hoeffding的参数 $M$替换成这里引入的成长函数 $M_H(N)$，并构建出成长函数与样本数量（N）的关系这样的话，我们就可以容易的得到结论：在样本N足够大时候，发生Bad Data的概率小于 $epsilon$ ($E_{in} \\approx E_{out}$)，可以得出错误率也低($E_{in} \\approx 0$)，说明机器学习是可能的。\n\n也就是说要说机器可以学习必须满足下面的条件：\n1. 假设空间的成长函数 $M_H(N)$ 存在Break Point K （即有一个好的假设空间$H$)\n2. 输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）\n3. 存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ -->也就是我们后面会研究的重点）\n\n其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ $\\Longrightarrow$ Machine Can Learn.\n\n\n\n------------------------------------\n<br><br>\n\n\n## 3. The VC Dimension\n### 1) Definition of VC Dimension\nVC Dimension( $d_{vc}$ )指的是能够使得成长函数可以被shatter的最大值（即 Break Point - 1)，用符号表示为公式（12）。\n$$\nd_{vc} = min(K) -1\n\\tag{$12$}\n$$\n\n上面的Hoeffding Inequity可以变成公式（13）\n$$\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right)\n\\tag{$13$}\n$$\n\n因此，根据这个特点，我们只要确保一个成长函数存在 VC Dimension，我们就可以确定他存在Break Point，是一个好的假设空间。\n\n### 2) Generalization Error\n我们引入泛化误差 $\\delta$ 表示 $E_{in}(g) 和 E_{out}(g)$ 的接近程度，即 $\\delta = E_{in}(g) - E_{out}(g)$ ，根据公式（13），我们稍作化简，如公式（14）。\n$$\n\\begin{align}\n\\delta                           &= 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right) \\\\\n\\frac{4 (2N)^{d_{vc}}}{\\delta}   &= \\exp(\\frac{1}{8} \\epsilon^2 N)  \\\\\n\\epsilon                         &= \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\end{align}\n\\tag{$14$}\n$$\n\n也就是说 $E_{in}(g) - E_{out}(g)$ 的误差会小于等于 $\\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}$。 所以我们可以求得 $E_{out}$ 的范围如公式（15）\n$$\nE_{in}(g) -  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )} \\leq E_{out}(g) \\leq E_{in}(g) + \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )})\n\\tag{$15$}\n$$\n\n### 3) Model Complexity\n上一节，我们求出了 $E_{in}(g) - E_{out}(g)$ 的误差，为了方便引用，我们引入了新的概念：模型复杂度（Model Complexitiy）来表示这个误差值，数学表示如公式（16）\n$$\n\\Omega(N,H,\\delta) =  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\tag{$15$}\n$$\n可以看出，随着VC Dimension的增大，$\\Omega$也会变大，然后 $E_{in}(g)$ 也会随着VC Dimension的增大而变小（因为选择的假设空间大了），但是 $E_{out}(g)$ 却不是一个单调函数，因为公式（15），然后这2个值一个变大一个变小，但是最终的话，$E_{out}$ 的曲线是先下降，然后上升（遍历一边就可以得到结果了），所以找到 $d_{vc}^{*}$ 很重要。(因为 $E_{out}$ 才是我们机器学习最重要的指标）\n结果如图十四所示。\n![Error and VC dimension](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png)\n<center> 图十六 Error and VC dimension <sup>[6]</sup></center>\n\n\n### 4) How much Data We need Theoretically and Practically\n问题：假如现在老板给员工下达了一个任务，要求这个模型的 ${\\epsilon = 0.1，\\delta = 0.1，  d_{vc} = 3}$ ，那样的话，我们需要多少个样本 $N$ 才能满足要求呢？\n回答：根据上面的公式（14），分别代入参数到等式中，可以求得样本数量 $N$ 如图十五的橙色区域所示。但是实际上，我们只需要 $10d_{vc}$就足够了。\n\n![How much Data We need Theoretically and Practically](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png)\n<center> 图十七 How much Data We need Theoretically and Practically <sup>[6]</sup></center>\n<br>\n\n因为我们在计算的时候同样的把上限给放大了，放大的原因如下所示:\n1. Hoeffding Inequity 不需要知道未知的情况，但是VC Bound可以用于各种分布，各种目标函数(因为 VC Bound的推导是基于不同的N和K)；\n2. 在给Binary Classification 强行装上成长函数本身就是一个宽松的上界，但是VC Bound可以用于各种数据样本；\n3. 使用二项式 $N^{d_{vc}}$ 作为成长函数的上界使得约束更加宽松，但是VC Bound可以用于任意具有相同VC维的假设空间；\n4. 联合限制（union bound）并不是一定会选择出现不好事情的假设函数，但是VC Bound可以用于任意算法。\n\n\n---------------------------------------------\n<br>\n<br>\n\n# Summary\n1. 我们首先通过回顾上一节的内容，得到结论是根据Hoeffding Inquity: 要使得机器可以学习的条件是 ① $E_{in} \\approx E_{out}$ ② $E_{in} \\approx 0$\n2. 接着我们讨论了什么情况下才能保证这2个条件满足，进行了讨论，最终我们通过引入① Growth Function ② Break Point ③ VC Bound, VC Dimension 更改Hoeffding Inequity的上限，最终得到我们需要的答案：\n    - 假设空间的成长函数 $M_H(N)$ 存在Break Point $K$ （即有一个好的假设空间 $H$)\n    - 输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）\n    - 存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ -->也就是我们后面会研究的重点）\n    - 其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ ⟹ Machine Can Learn.\n3. 之后我们讨论了理论上 $N \\approx 10000 d_{vc}$ 而实际上只需要 $N \\approx 10 d_{vc}$ 的能使得 $E_{out}$ 最小，并且分析了为什么理论上和实际上差别这么大\n\n\n---------------------------------------------\n<br>\n<br>\n\n\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\5\\5 - 2 - Effective Number of Lines (15-26)\n\n[2]机器学习基石(台湾大学-林轩田)\\5\\5 - 3 - Effective Number of Hypotheses (16-17)\n\n[3]机器学习基石(台湾大学-林轩田)\\5\\5 - 4 - Break Point (07-44)\n\n[4]机器学习基石(台湾大学-林轩田)\\6\\6 - 3 - Bounding Function- Inductive Cases (14-47)\n\n[5]机器学习基石(台湾大学-林轩田)\\6\\6 - 4 - A Pictorial Proof (16-01)\n\n[6]机器学习基石(台湾大学-林轩田)\\7\\7 - 4 - Interpreting VC Dimension (17-13)\n\n<br>\n<br>\n---------------------------------------------\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-08-5.Why Can Machine Learn.md","raw":"---\ntitle: 5.Why can Machine Learn?\ndate: 2017-10-08 16:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Why can Machine Learn?\n\n>这一节我的思路是把老师的第五，六、七节的内容结合起来了，并且思路不完全按照老师的授课来走。\n\n----------------------------------\n## 1. Preview of Last Chapter\n> 因为这一章的讨论是基于上一章最后一节得到的公式的，所以我们先Recap一下。\n\n上一节中，我们最后得出公式（1）（2）\n$$\n\\rho \\left[  BAD \\quad D \\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2N  \\right) \\\\\n\\tag{$1$}\n$$\n$$\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$2$}\n$$\n\n> 这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$\n\n总结如下表：\n\n-                              | M很小的时候 | M很大的时候 | N很小的时候 | N很大的时候 |\n-                              |:----------:|:----------:|:----------:|:----------:|\n$E_{in}(g) \\approx E_{out}(g)$ |Yes，Bad Data的数量也少了| No，Bad Data的数量也多了         |Yes，Bad Data出现的概率变小了 | No，Bad Data出现的概率变大了\n$E_{in}(g) \\approx 0$          |No，选到低错误率的可能性变小了|Yes，选到低错误率的可能性变大了|没必然联系，样本总数多于少，与错误率无关|没必然联系，样本总数多于少，与错误率无关\n\n>从表格中可以看出，$M$ 太大太小都会对机器学习的有效性造成影响，所以我们要进一步缩小$M$ 的取值范围。\n\n\n>问题：怎么缩小$M$的取值范围\n>\n>解决方案：在上一节中，我们再推导的过程中使用了联合上限（Union Bound)，造成实际的上限被放大了很多。因为在做集合的或运算的时候，我们单纯的把各个集合加起来，但是却没有减去他们的交集部分，所以造成了上限被放大的问题。\n\n关于Union Bound 的推导可以看这个链接[Boole's inequality](https://en.wikipedia.org/wiki/Boole%27s_inequality \"Boole's inequality\")\n\n总的来说就是因为我们推导公式（1）的时候使用了Union Bound，所以导致了不等式右边的值（上限）被放大了，所以现在我们可以把它进行缩减，求出有效的 $M$值(即 $M_H(N)$)，下面我们来推导这个有效值。\n\n## 2. VC Bound - A Upper Bound of Hoeffding Inequity\n### 1) Introduction\n场景：对于不同数量$N$的训练数据，有多少种不同的方法 $effective(N)$ 可以区分他们？\n\n当 $N=1$ 的时候，如图一所示，共有2种方法，$effective(N) = 2 = 2^1$。\n\n![N=1](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-1%20number%3D1.png)\n<center> 图一 N=1 <sup>[1]</sup></center>\n\n\n当 $N=2$ 的时候，如图二所示，共有4种方法，$effective(N) = 4 = 2^2$。\n\n![N=2](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-2%20number%3D2.png)\n<center> 图二 N=2 <sup>[1]</sup></center>\n\n\n当 $N=3$ 的时候，如图三、四所示，最多有8种方法，虽然说在特定的情形下，可能只有6中种方法，$effective(N) = 8 = 2^3$。\n\n![N=3 with error](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-4%20number%3D3%20with%20error.png)\n<center> 图三 N=3 with error <sup>[2]</sup></center>\n\n\n![N=3](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-3%20number%3D3.png)\n<center> 图四 N=3 <sup>[1]</sup></center>\n\n\n\n当 $N=4$ 的时候，如图五所示，无论怎么放着4个点，最多只有14种方法，$effective(N) = 14 < 2^4$。\n\n![N=4](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-5%20number%3D4.png)\n<center> 图五 N=4 <sup>[1]</sup></center>\n\n\n当 $N=5$ 的时候，很显然 $effective(N) = 32 <  2^5$，就不再继续讨论了。\n\n总结如下表：\n\nN|$effctive(N)$\n-  |-          |\n1  |$2 = 2^1$  |\n2  |$4 = 2^2$  |\n3  |$8 = 2^3$  |\n4  |$14 < 2^5$ |\n5  |$32 << 2^6$|\n...|...|\nN|$effctive(N) << 2^N$|\n\n总结如图六，可以看出当 $N>4$的时候，$effective(N) < 2^N$，也就是说我们把 $M和N$ 的关系构建了起来，所以我们可以用 $effective(N)$ 去替换 $M$，得到公式(3)\n\n$$\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2 \\cdot effective(N) \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$3$}\n$$\n\n![Summary](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-6%20summary.png)\n<center> 图六 Summary <sup>[1]</sup></center>\n\n\n\n### 2) Growth function\n上面Binary Clasification的分类方法叫做二分类法（dichotomy)，为了更好地表示 $N和effective(N)$ 的关系，我们引入成长函数（Growth Function) $M_H(N)$ 来表示，具体的数学表达如公式（4）所示。\n$$\nM_H(N) = \\max\\limits_{x_1,x_2,...,x_N ∈ X}  \\lvert H(x_1,x_2,...,x_N) \\rvert\n\\tag{$4$}  \\quad(其中，上限为2^N)\n$$\n\n### 3) Different Types of Growth function\n#### ① Growth Function for Positive Rays\n> Positive Rays 是用一个一维向量作用于一维坐标上，与该向量同方向的值为+1，反方向为-1\n如图七所示，Postives Rays 的成长函数为 $M_H(N) = (N-1)$，当 $N \\geq 2$的时候，$M_H(N) < 2^N = O(N)$\n\n![Growth Function for Positive Rays](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-7%20Growth%20Function%20for%20Positive%20Rays.png)\n<center> 图七 Growth Function for Positive Rays <sup>[2]</sup></center>\n\n\n\n#### ② Growth Function for Positive Interval\n> Positive Interval 是用一个一维“线段”作用于一维坐标上，与在线段里面的值为+1，外面的为-1\n如图八所示，Positive Interval 的成长函数为 $M_H(N) = C_{N+1}^2 + 1 = \\frac{1}{2}N^2 + \\frac{1}{2}N + 1$，当 $N \\geq 3$的时候，$M_H(N) < 2^N = O(N^2)$\n\n![Growth Function for Positive Interval](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-8%20Growth%20Function%20for%20Positive%20Intervals.png)\n<center> 图八 Growth Function for Positive Interval <sup>[2]</sup></center>\n\n\n\n#### ③ Growth Function for Convex Sets\n> Convex Sets 不太好理解。可以理解成在二维坐标上，用凸多边形去把所需要的点串起来。在多边形顶点上的点的值为+1，不在的为-1。因为我们讨论的是最大的可能性，所以当我们把所有的点都放在一个圆上的时候，必定存在一个凸多边形可以连接任意多个点（即可以画出任意多边形），然后再把所有点的组合情况加起来\n如图九所示，Convex Setsl 的成长函数为 $M_H(N) = \\sum\\limits_{i=0}^{N}C_{i}^{N} = 2^N$\n\n![Growth Function for Convex Sets](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-9%20Growth%20Function%20for%20Convex%20Sets.png)\n<center> 图九 Growth Function for Convex Sets <sup>[2]</sup></center>\n\n\n\n### 4) Break Point of Growth function\n我们称能满足完全二分类(出现不同种类的数量为$2^N$)的情况为shattered,能shattered的最大的点为突破点(break point)。\n然后根据上面对N从1-5的尝试，得到的最大可能性如下表\n\nN|$effctive(N)$\n-|-|\n1|$2 = 2^1$|\n2|$4 = 2^2$|\n3|$8 = 2^3$|\n4|$14 < 2^5$|\n5|$32 << 2^6$|\n...|...|\nN|$effctive(N) << 2^N$|\n\n可以推断出公式（3）\n$$\neffctive(N): M_H(N) \\leq \\max( possible \\quad M_H(N) \\quad Given \\quad break- point \\quad(K)) \\leq 2^N\n\\tag{$3$}\n$$\n\n\n上面关于Growth Function讨论的几种情况的Break Point 如图十所示，我们可以看出成长函数的复杂度与Break Point的大小存在一定的关系。\n\n![Break Point of Growth function](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/033cce3063c6d35c7ac55af137821cf97819be44/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-10%20Break%20Point.png)\n<center> 图十 Break Point of Growth function <sup>[3]</sup></center>\n\n\n### 5) Bounding Function\n#### ① Introduction of Bounding Function\n根据上一节的Break Point $K$和样本点 $N$的关系，我们引入一个新概念，上限函数(Bounding Function) $B(N,K)$。这个函数表示有$N$个样本点且成长函数的突破点是$K$的时候，最多有多少种组合情况，比如说$B(3,2) = 3$（这个比较容易想象，这里就不展开讨论了）。并且这个上限函数满足公式（4），因为这是采用而分类的方法来进行的，最大值为$2^N$。\n$$\nB(N,K) \\leq 2^N\n\\tag{$3$}\n$$\n\n但是显然在上面的例子中，我们可以看到$B(N,K) < 2^N \\quad(N \\geq K)$，所以我们下面进一步确定这个上限函数的最大值。\n\n#### ② Proof of Bounding Function\n\n我们下面用表格的方式来表示$B(N,K)$ 表格如下表，我们下面将会填满这个表格来找出相应的规律\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      |                        |                        |                        |                        |                        |                        | ... |\nN=2      |                        |                        |                        |                        |                        |                        | ... |\nN=3      |                        |                        |                        |                        |                        |                        | ... |\nN=4      |                        |                        |                        |                        |                        |                        | ... |\nN=5      |                        |                        |                        |                        |                        |                        | ... |\nN=6      |                        |                        |                        |                        |                        |                        | ... |\n...      |                        |                        |                        |                        |                        |                        | ... |\n\n1.根据上面的规律，我们知道在$N<K$的时候，$B(N,K) = 2^N$，所以表格更新如下\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      |                        | <font color=#FF0000>2</font>  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      |                        |                        | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      |                        |                        |                        | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      |                        |                        |                        |                        | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      |                        |                        |                        |                        |                        | <font color=#FF0000>32 | ... |\nN=6      |                        |                        |                        |                        |                        |                        | ... |\n...      |                        |                        |                        |                        |                        |                        | ... |\n\n2.然后当$K=1$的时候，我们至少有一种分法（全正或者全负），所以第一列全部为1，表格更新如下。\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  |                        | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  |                        |                        | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  |                        |                        |                        | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  |                        |                        |                        |                        | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n...      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n\n3.接着，当$N=K$的时候，我们上面也可以看到，所有的值最大都等于$2^N-1$(因为不能所有情况都出现一次)，所以表格更新如下。\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  | <font color=#FF0000>3  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  |                        | <font color=#FF0000>7  | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  |                        |                        | <font color=#FF0000>15 | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  |                        |                        |                        | <font color=#FF0000>31 | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  |                        |                        |                        |                        | <font color=#FF0000>63 | ... |\n...      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n\n4.在之前的章节，我们也数过$B(3,2) = 4$，其实看到这里我们已经大概有一些规律了：下面一项为上面两项之和， $B(N,K) = B(N-1, K) + B(N-1, K-1)$。当然我们只是猜测，下面我们继续证明。表格更新如下：\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  | <font color=#FF0000>3  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  | <font color=#F0FFF0)>4 | <font color=#FF0000>7  | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  |                        |                        | <font color=#FF0000>15 | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  |                        |                        |                        | <font color=#FF0000>31 | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  |                        |                        |                        |                        | <font color=#FF0000>63 | ... |\n...      | <font color=#0000FF>1  |                        |                        |                        |                        |                        | ... |\n\n\n5.我们证明上面的猜想$B(N,K) = B(N-1, K) + B(N-1, K-1)$\n1）首先我们遍历B(4,3)，可以得到图十一的结果，然后我们整理了一下结果的顺序，可以发现橙色区域 {$x_1,x_2,x_3$}结果分别出现了2次，而紫色区域的{$x_1,x_2,x_3$}结果只出现了1次。\n\n![Reorganized Dichotomies of B(4,3) - 1][11]\n\n[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\n\n<center> 图十一 Reorganized Dichotomies of B(4,3) - 1 <sup>[4]</sup></center>\n\n\n2）所以我们单独把{$x_1,x_2,x_3$}，提出来看，并把橙色区域的个数设为 $\\alpha$，紫色区域的个数为 $\\beta$，那么原来4个点的情况 $B(4,3) = 2 \\alpha + \\beta$，而3个点的情况 $B(3,3) = \\alpha + \\beta$，如下图十二所示。\n\n![Reorganized Dichotomies of B(4,3) - 2][12]\n\n[12]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%202.png\n\n<center> 图十二 Reorganized Dichotomies of B(4,3) - 2 <sup>[4]</sup></center>\n\n3)接着我们单独看 $\\alpha$可以发现这个刚好是 $B(3,2)$ 的最大可能性，也就是说$ \\alpha \\leq B(3,2) = 4 $，如图十三所示。\n\n![Reorganized Dichotomies of B(4,3) - 3][13]\n\n[13]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%203.png\n\n<center> 图十三 Reorganized Dichotomies of B(4,3) - 3 <sup>[4]</sup></center>\n\n\n4） 根据上面的分析，我们目前得到三个公式，如下面的公式（4）（5）（6）。\n$$\nB(4,5) = 2 \\cdot \\alpha + \\beta\n\\tag{$4$}\n$$\n$$\n\\alpha + \\beta \\leq B(3,3)\n\\tag{$5$}\n$$\n$$\n\\alpha \\leq B(3,2)\n\\tag{$6$}\n$$\n\n所以把公式(5)(6)加起来，我们可以更新公式（4）为公式（7）\n$$\nB(4,5) \\leq 2 \\cdot \\alpha + \\beta\n\\tag{$7$}\n$$\n\n5）最后我们用同样的方法来研究$B(N,K)$可以很容易证明到公式（8）（9）（10）\n$$\nB(N - 1,K) \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i}\n\\tag{$8$}\n$$\n$$\nB(N - 1,K - 1) \\leq \\sum\\limits_{i=0}^{k-2} C_{N-1}^{i} = \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i}\n\\tag{$9$}\n$$\n$$\n\\begin{align}\nB(N,K)  & \\leq {B(N-1,K) + B(N-1,K-1)} \\\\\n        & \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i} + \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i} \\\\\n        & = C_{N-1}^0 + \\sum\\limits_{i=1}^{k-1} \\left( C_{N-1}^{i} + C_{N-1}^{i}\\right)  \\\\\n        & = 1 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = C_{N}^0 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = \\sum\\limits_{i=0}^{k-1} C_{N}^{i}\n\\end{align}\n\\tag{$10$}\n$$\n\n所以我们的表格更新如下：\n\n$B(N,K)$ |          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      | <font color=#0000FF>1  | <font color=#FF0000>2  | <font color=#FF0120>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | <font color=#FF0000>2  | ... |\nN=2      | <font color=#0000FF>1  | <font color=#FF0000>3  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | <font color=#FF0000>4  | ... |\nN=3      | <font color=#0000FF>1  | <font color=#F0FFF0)>4 | <font color=#FF0000>7  | <font color=#FF0000>8  | <font color=#FF0000>8  | <font color=#FF0000>8  | ... |\nN=4      | <font color=#0000FF>1  | <font color=#FFA500)>$\\leq5$  | <font color=#FFA500>11  | <font color=#FF0000>15 | <font color=#FF0000>16 | <font color=#FF0000>16 | ... |\nN=5      | <font color=#0000FF>1  | <font color=#FFA500)>$\\leq6$  | <font color=#FFA500)>$\\leq16$  | <font color=#FFA500)>$\\leq15$  | <font color=#FF0000>31 | <font color=#FF0000>32 | ... |\nN=6      | <font color=#0000FF>1  | <font color=#FFA500)>$\\leq7$  | <font color=#FFA500)>$\\leq22$  | <font color=#FFA500)>$\\leq26$  | <font color=#FFA500)>$\\leq57$  | <font color=#FF0000>63 | ... |\n...      | <font color=#0000FF>1  |              ...              |              ...              |              ...              |              ...              |              ...              | ... |\n\n我们再把$N^{K-1}$的表格整理如下：\n\n$N^{N-1}$|          K=1           |           K=2          |           K=3          |           K=4          |           K=5          |           K=6          | ... |\n:-------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:---:|\nN=1      |           1            |           1            |           1            |           1            |           1            |           1            | ... |\nN=2      |           1            |           2            |           4            |           8            |           8            |           16           | ... |\nN=3      |           1            |           3            |           9            |           27           |           27           |           81           | ... |\nN=4      |           1            |           4            |           16           |           64           |           64           |           256          | ... |\nN=5      |           1            |           5            |           25           |           125          |           125          |           625          | ... |\nN=6      |           1            |           6            |           36           |           216          |           216          |           1296         | ... |\n...      |          ...           |          ...           |          ...           |          ...           |          ...           |          ...           | ... |\n\n对比图参考老师上课的PPT，如图十四所示。\n\n![Comparision of B(N,K) and N^(K-1)][14]\n\n[14]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-14%20Comparision%20of%20B(N%2CK)%20and%20N%5E(K-1).png\n\n<center> 图十四 Comparision of B(N,K) and N^(K-1) <sup>[6]</sup></center>\n\n\n总结起来就是：在$N \\geq 2, K \\geq 3$的时候，总有公式（11）的情况。\n$$\nM_H(N) \\leq B(N,K) = \\sum\\limits_{i=0}^{K-1} \\leq N^{K-1}\n\\tag{$11$}\n$$\n\n\n### 6) Vapnik-Chervonenkis (VC) bound\n\n@TODO: 这一节主要是证明从数学的角度上证明VC Bound 并以此更新Hoeffding Inequity。目前听得失一知半解，所以只贴出结论，后面再补充。\n\n\n结论如图十五所示。\n\n![Vapnik-Chervonenkis (VC) bound](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/738603b7f8e8f10505a791140c32f4677d4e7d84/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-13%20VC%20bound.png)\n\n<center> 图十五 Vapnik-Chervonenkis (VC) bound <sup>[5]</sup></center>\n\n这个VC Bound的作用是把之前Hoeffding的参数 $M$替换成这里引入的成长函数 $M_H(N)$，并构建出成长函数与样本数量（N）的关系这样的话，我们就可以容易的得到结论：在样本N足够大时候，发生Bad Data的概率小于 $epsilon$ ($E_{in} \\approx E_{out}$)，可以得出错误率也低($E_{in} \\approx 0$)，说明机器学习是可能的。\n\n也就是说要说机器可以学习必须满足下面的条件：\n1. 假设空间的成长函数 $M_H(N)$ 存在Break Point K （即有一个好的假设空间$H$)\n2. 输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）\n3. 存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ -->也就是我们后面会研究的重点）\n\n其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ $\\Longrightarrow$ Machine Can Learn.\n\n\n\n------------------------------------\n<br><br>\n\n\n## 3. The VC Dimension\n### 1) Definition of VC Dimension\nVC Dimension( $d_{vc}$ )指的是能够使得成长函数可以被shatter的最大值（即 Break Point - 1)，用符号表示为公式（12）。\n$$\nd_{vc} = min(K) -1\n\\tag{$12$}\n$$\n\n上面的Hoeffding Inequity可以变成公式（13）\n$$\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right)\n\\tag{$13$}\n$$\n\n因此，根据这个特点，我们只要确保一个成长函数存在 VC Dimension，我们就可以确定他存在Break Point，是一个好的假设空间。\n\n### 2) Generalization Error\n我们引入泛化误差 $\\delta$ 表示 $E_{in}(g) 和 E_{out}(g)$ 的接近程度，即 $\\delta = E_{in}(g) - E_{out}(g)$ ，根据公式（13），我们稍作化简，如公式（14）。\n$$\n\\begin{align}\n\\delta                           &= 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right) \\\\\n\\frac{4 (2N)^{d_{vc}}}{\\delta}   &= \\exp(\\frac{1}{8} \\epsilon^2 N)  \\\\\n\\epsilon                         &= \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\end{align}\n\\tag{$14$}\n$$\n\n也就是说 $E_{in}(g) - E_{out}(g)$ 的误差会小于等于 $\\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}$。 所以我们可以求得 $E_{out}$ 的范围如公式（15）\n$$\nE_{in}(g) -  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )} \\leq E_{out}(g) \\leq E_{in}(g) + \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )})\n\\tag{$15$}\n$$\n\n### 3) Model Complexity\n上一节，我们求出了 $E_{in}(g) - E_{out}(g)$ 的误差，为了方便引用，我们引入了新的概念：模型复杂度（Model Complexitiy）来表示这个误差值，数学表示如公式（16）\n$$\n\\Omega(N,H,\\delta) =  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\tag{$15$}\n$$\n可以看出，随着VC Dimension的增大，$\\Omega$也会变大，然后 $E_{in}(g)$ 也会随着VC Dimension的增大而变小（因为选择的假设空间大了），但是 $E_{out}(g)$ 却不是一个单调函数，因为公式（15），然后这2个值一个变大一个变小，但是最终的话，$E_{out}$ 的曲线是先下降，然后上升（遍历一边就可以得到结果了），所以找到 $d_{vc}^{*}$ 很重要。(因为 $E_{out}$ 才是我们机器学习最重要的指标）\n结果如图十四所示。\n![Error and VC dimension](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png)\n<center> 图十六 Error and VC dimension <sup>[6]</sup></center>\n\n\n### 4) How much Data We need Theoretically and Practically\n问题：假如现在老板给员工下达了一个任务，要求这个模型的 ${\\epsilon = 0.1，\\delta = 0.1，  d_{vc} = 3}$ ，那样的话，我们需要多少个样本 $N$ 才能满足要求呢？\n回答：根据上面的公式（14），分别代入参数到等式中，可以求得样本数量 $N$ 如图十五的橙色区域所示。但是实际上，我们只需要 $10d_{vc}$就足够了。\n\n![How much Data We need Theoretically and Practically](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png)\n<center> 图十七 How much Data We need Theoretically and Practically <sup>[6]</sup></center>\n<br>\n\n因为我们在计算的时候同样的把上限给放大了，放大的原因如下所示:\n1. Hoeffding Inequity 不需要知道未知的情况，但是VC Bound可以用于各种分布，各种目标函数(因为 VC Bound的推导是基于不同的N和K)；\n2. 在给Binary Classification 强行装上成长函数本身就是一个宽松的上界，但是VC Bound可以用于各种数据样本；\n3. 使用二项式 $N^{d_{vc}}$ 作为成长函数的上界使得约束更加宽松，但是VC Bound可以用于任意具有相同VC维的假设空间；\n4. 联合限制（union bound）并不是一定会选择出现不好事情的假设函数，但是VC Bound可以用于任意算法。\n\n\n---------------------------------------------\n<br>\n<br>\n\n# Summary\n1. 我们首先通过回顾上一节的内容，得到结论是根据Hoeffding Inquity: 要使得机器可以学习的条件是 ① $E_{in} \\approx E_{out}$ ② $E_{in} \\approx 0$\n2. 接着我们讨论了什么情况下才能保证这2个条件满足，进行了讨论，最终我们通过引入① Growth Function ② Break Point ③ VC Bound, VC Dimension 更改Hoeffding Inequity的上限，最终得到我们需要的答案：\n    - 假设空间的成长函数 $M_H(N)$ 存在Break Point $K$ （即有一个好的假设空间 $H$)\n    - 输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）\n    - 存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ -->也就是我们后面会研究的重点）\n    - 其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ ⟹ Machine Can Learn.\n3. 之后我们讨论了理论上 $N \\approx 10000 d_{vc}$ 而实际上只需要 $N \\approx 10 d_{vc}$ 的能使得 $E_{out}$ 最小，并且分析了为什么理论上和实际上差别这么大\n\n\n---------------------------------------------\n<br>\n<br>\n\n\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\5\\5 - 2 - Effective Number of Lines (15-26)\n\n[2]机器学习基石(台湾大学-林轩田)\\5\\5 - 3 - Effective Number of Hypotheses (16-17)\n\n[3]机器学习基石(台湾大学-林轩田)\\5\\5 - 4 - Break Point (07-44)\n\n[4]机器学习基石(台湾大学-林轩田)\\6\\6 - 3 - Bounding Function- Inductive Cases (14-47)\n\n[5]机器学习基石(台湾大学-林轩田)\\6\\6 - 4 - A Pictorial Proof (16-01)\n\n[6]机器学习基石(台湾大学-林轩田)\\7\\7 - 4 - Interpreting VC Dimension (17-13)\n\n<br>\n<br>\n---------------------------------------------\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-08-5.Why Can Machine Learn","published":1,"updated":"2018-10-27T04:30:42.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bm001he0owidmai8wx","content":"<h1 id=\"Why-can-Machine-Learn\"><a href=\"#Why-can-Machine-Learn\" class=\"headerlink\" title=\"Why can Machine Learn?\"></a>Why can Machine Learn?</h1><blockquote>\n<p>这一节我的思路是把老师的第五，六、七节的内容结合起来了，并且思路不完全按照老师的授课来走。</p>\n</blockquote>\n<hr>\n<h2 id=\"1-Preview-of-Last-Chapter\"><a href=\"#1-Preview-of-Last-Chapter\" class=\"headerlink\" title=\"1. Preview of Last Chapter\"></a>1. Preview of Last Chapter</h2><blockquote>\n<p>因为这一章的讨论是基于上一章最后一节得到的公式的，所以我们先Recap一下。</p>\n</blockquote>\n<p>上一节中，我们最后得出公式（1）（2）</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[  BAD \\quad D \\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2N  \\right) \\\\\n\\tag{$1$}</script><script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$2$}</script><blockquote>\n<p>这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$</p>\n</blockquote>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">M很小的时候</th>\n<th style=\"text-align:center\">M很大的时候</th>\n<th style=\"text-align:center\">N很小的时候</th>\n<th style=\"text-align:center\">N很大的时候</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$E_{in}(g) \\approx E_{out}(g)$</td>\n<td style=\"text-align:center\">Yes，Bad Data的数量也少了</td>\n<td style=\"text-align:center\">No，Bad Data的数量也多了</td>\n<td style=\"text-align:center\">Yes，Bad Data出现的概率变小了</td>\n<td style=\"text-align:center\">No，Bad Data出现的概率变大了</td>\n</tr>\n<tr>\n<td>$E_{in}(g) \\approx 0$</td>\n<td style=\"text-align:center\">No，选到低错误率的可能性变小了</td>\n<td style=\"text-align:center\">Yes，选到低错误率的可能性变大了</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>从表格中可以看出，$M$ 太大太小都会对机器学习的有效性造成影响，所以我们要进一步缩小$M$ 的取值范围。</p>\n<p>问题：怎么缩小$M$的取值范围</p>\n<p>解决方案：在上一节中，我们再推导的过程中使用了联合上限（Union Bound)，造成实际的上限被放大了很多。因为在做集合的或运算的时候，我们单纯的把各个集合加起来，但是却没有减去他们的交集部分，所以造成了上限被放大的问题。</p>\n</blockquote>\n<p>关于Union Bound 的推导可以看这个链接<a href=\"https://en.wikipedia.org/wiki/Boole%27s_inequality\" title=\"Boole&#39;s inequality\" target=\"_blank\" rel=\"external\">Boole’s inequality</a></p>\n<p>总的来说就是因为我们推导公式（1）的时候使用了Union Bound，所以导致了不等式右边的值（上限）被放大了，所以现在我们可以把它进行缩减，求出有效的 $M$值(即 $M_H(N)$)，下面我们来推导这个有效值。</p>\n<h2 id=\"2-VC-Bound-A-Upper-Bound-of-Hoeffding-Inequity\"><a href=\"#2-VC-Bound-A-Upper-Bound-of-Hoeffding-Inequity\" class=\"headerlink\" title=\"2. VC Bound - A Upper Bound of Hoeffding Inequity\"></a>2. VC Bound - A Upper Bound of Hoeffding Inequity</h2><h3 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1) Introduction\"></a>1) Introduction</h3><p>场景：对于不同数量$N$的训练数据，有多少种不同的方法 $effective(N)$ 可以区分他们？</p>\n<p>当 $N=1$ 的时候，如图一所示，共有2种方法，$effective(N) = 2 = 2^1$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-1%20number%3D1.png\" alt=\"N=1\"></p>\n<center> 图一 N=1 <sup>[1]</sup></center>\n\n\n<p>当 $N=2$ 的时候，如图二所示，共有4种方法，$effective(N) = 4 = 2^2$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-2%20number%3D2.png\" alt=\"N=2\"></p>\n<center> 图二 N=2 <sup>[1]</sup></center>\n\n\n<p>当 $N=3$ 的时候，如图三、四所示，最多有8种方法，虽然说在特定的情形下，可能只有6中种方法，$effective(N) = 8 = 2^3$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-4%20number%3D3%20with%20error.png\" alt=\"N=3 with error\"></p>\n<center> 图三 N=3 with error <sup>[2]</sup></center>\n\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-3%20number%3D3.png\" alt=\"N=3\"></p>\n<center> 图四 N=3 <sup>[1]</sup></center>\n\n\n\n<p>当 $N=4$ 的时候，如图五所示，无论怎么放着4个点，最多只有14种方法，$effective(N) = 14 &lt; 2^4$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-5%20number%3D4.png\" alt=\"N=4\"></p>\n<center> 图五 N=4 <sup>[1]</sup></center>\n\n\n<p>当 $N=5$ 的时候，很显然 $effective(N) = 32 &lt;  2^5$，就不再继续讨论了。</p>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>N</th>\n<th>$effctive(N)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>$2 = 2^1$</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>$4 = 2^2$</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>$8 = 2^3$</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>$14 &lt; 2^5$</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>$32 &lt;&lt; 2^6$</td>\n<td></td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td></td>\n</tr>\n<tr>\n<td>N</td>\n<td>$effctive(N) &lt;&lt; 2^N$</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>总结如图六，可以看出当 $N&gt;4$的时候，$effective(N) &lt; 2^N$，也就是说我们把 $M和N$ 的关系构建了起来，所以我们可以用 $effective(N)$ 去替换 $M$，得到公式(3)</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2 \\cdot effective(N) \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$3$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-6%20summary.png\" alt=\"Summary\"></p>\n<center> 图六 Summary <sup>[1]</sup></center>\n\n\n\n<h3 id=\"2-Growth-function\"><a href=\"#2-Growth-function\" class=\"headerlink\" title=\"2) Growth function\"></a>2) Growth function</h3><p>上面Binary Clasification的分类方法叫做二分类法（dichotomy)，为了更好地表示 $N和effective(N)$ 的关系，我们引入成长函数（Growth Function) $M_H(N)$ 来表示，具体的数学表达如公式（4）所示。</p>\n<script type=\"math/tex; mode=display\">\nM_H(N) = \\max\\limits_{x_1,x_2,...,x_N ∈ X}  \\lvert H(x_1,x_2,...,x_N) \\rvert\n\\tag{$4$}  \\quad(其中，上限为2^N)</script><h3 id=\"3-Different-Types-of-Growth-function\"><a href=\"#3-Different-Types-of-Growth-function\" class=\"headerlink\" title=\"3) Different Types of Growth function\"></a>3) Different Types of Growth function</h3><h4 id=\"①-Growth-Function-for-Positive-Rays\"><a href=\"#①-Growth-Function-for-Positive-Rays\" class=\"headerlink\" title=\"① Growth Function for Positive Rays\"></a>① Growth Function for Positive Rays</h4><blockquote>\n<p>Positive Rays 是用一个一维向量作用于一维坐标上，与该向量同方向的值为+1，反方向为-1<br>如图七所示，Postives Rays 的成长函数为 $M_H(N) = (N-1)$，当 $N \\geq 2$的时候，$M_H(N) &lt; 2^N = O(N)$</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-7%20Growth%20Function%20for%20Positive%20Rays.png\" alt=\"Growth Function for Positive Rays\"></p>\n<center> 图七 Growth Function for Positive Rays <sup>[2]</sup></center>\n\n\n\n<h4 id=\"②-Growth-Function-for-Positive-Interval\"><a href=\"#②-Growth-Function-for-Positive-Interval\" class=\"headerlink\" title=\"② Growth Function for Positive Interval\"></a>② Growth Function for Positive Interval</h4><blockquote>\n<p>Positive Interval 是用一个一维“线段”作用于一维坐标上，与在线段里面的值为+1，外面的为-1<br>如图八所示，Positive Interval 的成长函数为 $M_H(N) = C_{N+1}^2 + 1 = \\frac{1}{2}N^2 + \\frac{1}{2}N + 1$，当 $N \\geq 3$的时候，$M_H(N) &lt; 2^N = O(N^2)$</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-8%20Growth%20Function%20for%20Positive%20Intervals.png\" alt=\"Growth Function for Positive Interval\"></p>\n<center> 图八 Growth Function for Positive Interval <sup>[2]</sup></center>\n\n\n\n<h4 id=\"③-Growth-Function-for-Convex-Sets\"><a href=\"#③-Growth-Function-for-Convex-Sets\" class=\"headerlink\" title=\"③ Growth Function for Convex Sets\"></a>③ Growth Function for Convex Sets</h4><blockquote>\n<p>Convex Sets 不太好理解。可以理解成在二维坐标上，用凸多边形去把所需要的点串起来。在多边形顶点上的点的值为+1，不在的为-1。因为我们讨论的是最大的可能性，所以当我们把所有的点都放在一个圆上的时候，必定存在一个凸多边形可以连接任意多个点（即可以画出任意多边形），然后再把所有点的组合情况加起来<br>如图九所示，Convex Setsl 的成长函数为 $M_H(N) = \\sum\\limits_{i=0}^{N}C_{i}^{N} = 2^N$</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-9%20Growth%20Function%20for%20Convex%20Sets.png\" alt=\"Growth Function for Convex Sets\"></p>\n<center> 图九 Growth Function for Convex Sets <sup>[2]</sup></center>\n\n\n\n<h3 id=\"4-Break-Point-of-Growth-function\"><a href=\"#4-Break-Point-of-Growth-function\" class=\"headerlink\" title=\"4) Break Point of Growth function\"></a>4) Break Point of Growth function</h3><p>我们称能满足完全二分类(出现不同种类的数量为$2^N$)的情况为shattered,能shattered的最大的点为突破点(break point)。<br>然后根据上面对N从1-5的尝试，得到的最大可能性如下表</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>N</th>\n<th>$effctive(N)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>$2 = 2^1$</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>$4 = 2^2$</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>$8 = 2^3$</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>$14 &lt; 2^5$</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>$32 &lt;&lt; 2^6$</td>\n<td></td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td></td>\n</tr>\n<tr>\n<td>N</td>\n<td>$effctive(N) &lt;&lt; 2^N$</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>可以推断出公式（3）</p>\n<script type=\"math/tex; mode=display\">\neffctive(N): M_H(N) \\leq \\max( possible \\quad M_H(N) \\quad Given \\quad break- point \\quad(K)) \\leq 2^N\n\\tag{$3$}</script><p>上面关于Growth Function讨论的几种情况的Break Point 如图十所示，我们可以看出成长函数的复杂度与Break Point的大小存在一定的关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/033cce3063c6d35c7ac55af137821cf97819be44/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-10%20Break%20Point.png\" alt=\"Break Point of Growth function\"></p>\n<center> 图十 Break Point of Growth function <sup>[3]</sup></center>\n\n\n<h3 id=\"5-Bounding-Function\"><a href=\"#5-Bounding-Function\" class=\"headerlink\" title=\"5) Bounding Function\"></a>5) Bounding Function</h3><h4 id=\"①-Introduction-of-Bounding-Function\"><a href=\"#①-Introduction-of-Bounding-Function\" class=\"headerlink\" title=\"① Introduction of Bounding Function\"></a>① Introduction of Bounding Function</h4><p>根据上一节的Break Point $K$和样本点 $N$的关系，我们引入一个新概念，上限函数(Bounding Function) $B(N,K)$。这个函数表示有$N$个样本点且成长函数的突破点是$K$的时候，最多有多少种组合情况，比如说$B(3,2) = 3$（这个比较容易想象，这里就不展开讨论了）。并且这个上限函数满足公式（4），因为这是采用而分类的方法来进行的，最大值为$2^N$。</p>\n<script type=\"math/tex; mode=display\">\nB(N,K) \\leq 2^N\n\\tag{$3$}</script><p>但是显然在上面的例子中，我们可以看到$B(N,K) &lt; 2^N \\quad(N \\geq K)$，所以我们下面进一步确定这个上限函数的最大值。</p>\n<h4 id=\"②-Proof-of-Bounding-Function\"><a href=\"#②-Proof-of-Bounding-Function\" class=\"headerlink\" title=\"② Proof of Bounding Function\"></a>② Proof of Bounding Function</h4><p>我们下面用表格的方式来表示$B(N,K)$ 表格如下表，我们下面将会填满这个表格来找出相应的规律</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>1.根据上面的规律，我们知道在$N&lt;K$的时候，$B(N,K) = 2^N$，所以表格更新如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>2.然后当$K=1$的时候，我们至少有一种分法（全正或者全负），所以第一列全部为1，表格更新如下。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>3.接着，当$N=K$的时候，我们上面也可以看到，所有的值最大都等于$2^N-1$(因为不能所有情况都出现一次)，所以表格更新如下。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">3</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">7</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">15</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">31</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">63</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>4.在之前的章节，我们也数过$B(3,2) = 4$，其实看到这里我们已经大概有一些规律了：下面一项为上面两项之和， $B(N,K) = B(N-1, K) + B(N-1, K-1)$。当然我们只是猜测，下面我们继续证明。表格更新如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">3</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#F0FFF0)\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">7</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">15</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">31</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">63</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>5.我们证明上面的猜想$B(N,K) = B(N-1, K) + B(N-1, K-1)$<br>1）首先我们遍历B(4,3)，可以得到图十一的结果，然后我们整理了一下结果的顺序，可以发现橙色区域 {$x_1,x_2,x_3$}结果分别出现了2次，而紫色区域的{$x_1,x_2,x_3$}结果只出现了1次。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\" alt=\"Reorganized Dichotomies of B(4,3) - 1\"></p>\n<center> 图十一 Reorganized Dichotomies of B(4,3) - 1 <sup>[4]</sup></center>\n\n\n<p>2）所以我们单独把{$x_1,x_2,x_3$}，提出来看，并把橙色区域的个数设为 $\\alpha$，紫色区域的个数为 $\\beta$，那么原来4个点的情况 $B(4,3) = 2 \\alpha + \\beta$，而3个点的情况 $B(3,3) = \\alpha + \\beta$，如下图十二所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%202.png\" alt=\"Reorganized Dichotomies of B(4,3) - 2\"></p>\n<center> 图十二 Reorganized Dichotomies of B(4,3) - 2 <sup>[4]</sup></center>\n\n<p>3)接着我们单独看 $\\alpha$可以发现这个刚好是 $B(3,2)$ 的最大可能性，也就是说$ \\alpha \\leq B(3,2) = 4 $，如图十三所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%203.png\" alt=\"Reorganized Dichotomies of B(4,3) - 3\"></p>\n<center> 图十三 Reorganized Dichotomies of B(4,3) - 3 <sup>[4]</sup></center>\n\n\n<p>4） 根据上面的分析，我们目前得到三个公式，如下面的公式（4）（5）（6）。</p>\n<script type=\"math/tex; mode=display\">\nB(4,5) = 2 \\cdot \\alpha + \\beta\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\n\\alpha + \\beta \\leq B(3,3)\n\\tag{$5$}</script><script type=\"math/tex; mode=display\">\n\\alpha \\leq B(3,2)\n\\tag{$6$}</script><p>所以把公式(5)(6)加起来，我们可以更新公式（4）为公式（7）</p>\n<script type=\"math/tex; mode=display\">\nB(4,5) \\leq 2 \\cdot \\alpha + \\beta\n\\tag{$7$}</script><p>5）最后我们用同样的方法来研究$B(N,K)$可以很容易证明到公式（8）（9）（10）</p>\n<script type=\"math/tex; mode=display\">\nB(N - 1,K) \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i}\n\\tag{$8$}</script><script type=\"math/tex; mode=display\">\nB(N - 1,K - 1) \\leq \\sum\\limits_{i=0}^{k-2} C_{N-1}^{i} = \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i}\n\\tag{$9$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nB(N,K)  & \\leq {B(N-1,K) + B(N-1,K-1)} \\\\\n        & \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i} + \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i} \\\\\n        & = C_{N-1}^0 + \\sum\\limits_{i=1}^{k-1} \\left( C_{N-1}^{i} + C_{N-1}^{i}\\right)  \\\\\n        & = 1 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = C_{N}^0 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = \\sum\\limits_{i=0}^{k-1} C_{N}^{i}\n\\end{align}\n\\tag{$10$}</script><p>所以我们的表格更新如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">3</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#F0FFF0)\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">7</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq5$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500\">11</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">15</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq6$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq16$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq15$</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">31</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq7$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq22$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq26$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq57$</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">63</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>我们再把$N^{K-1}$的表格整理如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$N^{N-1}$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">81</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">256</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">125</td>\n<td style=\"text-align:center\">125</td>\n<td style=\"text-align:center\">625</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">36</td>\n<td style=\"text-align:center\">216</td>\n<td style=\"text-align:center\">216</td>\n<td style=\"text-align:center\">1296</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对比图参考老师上课的PPT，如图十四所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-14%20Comparision%20of%20B(N%2CK)%20and%20N%5E(K-1).png\" alt=\"Comparision of B(N,K) and N^(K-1)\"></p>\n<center> 图十四 Comparision of B(N,K) and N^(K-1) <sup>[6]</sup></center>\n\n\n<p>总结起来就是：在$N \\geq 2, K \\geq 3$的时候，总有公式（11）的情况。</p>\n<script type=\"math/tex; mode=display\">\nM_H(N) \\leq B(N,K) = \\sum\\limits_{i=0}^{K-1} \\leq N^{K-1}\n\\tag{$11$}</script><h3 id=\"6-Vapnik-Chervonenkis-VC-bound\"><a href=\"#6-Vapnik-Chervonenkis-VC-bound\" class=\"headerlink\" title=\"6) Vapnik-Chervonenkis (VC) bound\"></a>6) Vapnik-Chervonenkis (VC) bound</h3><p>@TODO: 这一节主要是证明从数学的角度上证明VC Bound 并以此更新Hoeffding Inequity。目前听得失一知半解，所以只贴出结论，后面再补充。</p>\n<p>结论如图十五所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/738603b7f8e8f10505a791140c32f4677d4e7d84/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-13%20VC%20bound.png\" alt=\"Vapnik-Chervonenkis (VC) bound\"></p>\n<center> 图十五 Vapnik-Chervonenkis (VC) bound <sup>[5]</sup></center>\n\n<p>这个VC Bound的作用是把之前Hoeffding的参数 $M$替换成这里引入的成长函数 $M_H(N)$，并构建出成长函数与样本数量（N）的关系这样的话，我们就可以容易的得到结论：在样本N足够大时候，发生Bad Data的概率小于 $epsilon$ ($E_{in} \\approx E_{out}$)，可以得出错误率也低($E_{in} \\approx 0$)，说明机器学习是可能的。</p>\n<p>也就是说要说机器可以学习必须满足下面的条件：</p>\n<ol>\n<li>假设空间的成长函数 $M_H(N)$ 存在Break Point K （即有一个好的假设空间$H$)</li>\n<li>输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）</li>\n<li>存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ —&gt;也就是我们后面会研究的重点）</li>\n</ol>\n<p>其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ $\\Longrightarrow$ Machine Can Learn.</p>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-The-VC-Dimension\"><a href=\"#3-The-VC-Dimension\" class=\"headerlink\" title=\"3. The VC Dimension\"></a>3. The VC Dimension</h2><h3 id=\"1-Definition-of-VC-Dimension\"><a href=\"#1-Definition-of-VC-Dimension\" class=\"headerlink\" title=\"1) Definition of VC Dimension\"></a>1) Definition of VC Dimension</h3><p>VC Dimension( $d_{vc}$ )指的是能够使得成长函数可以被shatter的最大值（即 Break Point - 1)，用符号表示为公式（12）。</p>\n<script type=\"math/tex; mode=display\">\nd_{vc} = min(K) -1\n\\tag{$12$}</script><p>上面的Hoeffding Inequity可以变成公式（13）</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right)\n\\tag{$13$}</script><p>因此，根据这个特点，我们只要确保一个成长函数存在 VC Dimension，我们就可以确定他存在Break Point，是一个好的假设空间。</p>\n<h3 id=\"2-Generalization-Error\"><a href=\"#2-Generalization-Error\" class=\"headerlink\" title=\"2) Generalization Error\"></a>2) Generalization Error</h3><p>我们引入泛化误差 $\\delta$ 表示 $E_{in}(g) 和 E_{out}(g)$ 的接近程度，即 $\\delta = E_{in}(g) - E_{out}(g)$ ，根据公式（13），我们稍作化简，如公式（14）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\delta                           &= 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right) \\\\\n\\frac{4 (2N)^{d_{vc}}}{\\delta}   &= \\exp(\\frac{1}{8} \\epsilon^2 N)  \\\\\n\\epsilon                         &= \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\end{align}\n\\tag{$14$}</script><p>也就是说 $E_{in}(g) - E_{out}(g)$ 的误差会小于等于 $\\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}$。 所以我们可以求得 $E_{out}$ 的范围如公式（15）</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(g) -  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )} \\leq E_{out}(g) \\leq E_{in}(g) + \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )})\n\\tag{$15$}</script><h3 id=\"3-Model-Complexity\"><a href=\"#3-Model-Complexity\" class=\"headerlink\" title=\"3) Model Complexity\"></a>3) Model Complexity</h3><p>上一节，我们求出了 $E_{in}(g) - E_{out}(g)$ 的误差，为了方便引用，我们引入了新的概念：模型复杂度（Model Complexitiy）来表示这个误差值，数学表示如公式（16）</p>\n<script type=\"math/tex; mode=display\">\n\\Omega(N,H,\\delta) =  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\tag{$15$}</script><p>可以看出，随着VC Dimension的增大，$\\Omega$也会变大，然后 $E_{in}(g)$ 也会随着VC Dimension的增大而变小（因为选择的假设空间大了），但是 $E_{out}(g)$ 却不是一个单调函数，因为公式（15），然后这2个值一个变大一个变小，但是最终的话，$E_{out}$ 的曲线是先下降，然后上升（遍历一边就可以得到结果了），所以找到 $d_{vc}^{*}$ 很重要。(因为 $E_{out}$ 才是我们机器学习最重要的指标）<br>结果如图十四所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png\" alt=\"Error and VC dimension\"></p>\n<center> 图十六 Error and VC dimension <sup>[6]</sup></center>\n\n\n<h3 id=\"4-How-much-Data-We-need-Theoretically-and-Practically\"><a href=\"#4-How-much-Data-We-need-Theoretically-and-Practically\" class=\"headerlink\" title=\"4) How much Data We need Theoretically and Practically\"></a>4) How much Data We need Theoretically and Practically</h3><p>问题：假如现在老板给员工下达了一个任务，要求这个模型的 ${\\epsilon = 0.1，\\delta = 0.1，  d_{vc} = 3}$ ，那样的话，我们需要多少个样本 $N$ 才能满足要求呢？<br>回答：根据上面的公式（14），分别代入参数到等式中，可以求得样本数量 $N$ 如图十五的橙色区域所示。但是实际上，我们只需要 $10d_{vc}$就足够了。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png\" alt=\"How much Data We need Theoretically and Practically\"></p>\n<p><center> 图十七 How much Data We need Theoretically and Practically <sup>[6]</sup></center><br><br></p>\n<p>因为我们在计算的时候同样的把上限给放大了，放大的原因如下所示:</p>\n<ol>\n<li>Hoeffding Inequity 不需要知道未知的情况，但是VC Bound可以用于各种分布，各种目标函数(因为 VC Bound的推导是基于不同的N和K)；</li>\n<li>在给Binary Classification 强行装上成长函数本身就是一个宽松的上界，但是VC Bound可以用于各种数据样本；</li>\n<li>使用二项式 $N^{d_{vc}}$ 作为成长函数的上界使得约束更加宽松，但是VC Bound可以用于任意具有相同VC维的假设空间；</li>\n<li>联合限制（union bound）并不是一定会选择出现不好事情的假设函数，但是VC Bound可以用于任意算法。</li>\n</ol>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>我们首先通过回顾上一节的内容，得到结论是根据Hoeffding Inquity: 要使得机器可以学习的条件是 ① $E_{in} \\approx E_{out}$ ② $E_{in} \\approx 0$</li>\n<li>接着我们讨论了什么情况下才能保证这2个条件满足，进行了讨论，最终我们通过引入① Growth Function ② Break Point ③ VC Bound, VC Dimension 更改Hoeffding Inequity的上限，最终得到我们需要的答案：<ul>\n<li>假设空间的成长函数 $M_H(N)$ 存在Break Point $K$ （即有一个好的假设空间 $H$)</li>\n<li>输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）</li>\n<li>存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ —&gt;也就是我们后面会研究的重点）</li>\n<li>其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ ⟹ Machine Can Learn.</li>\n</ul>\n</li>\n<li>之后我们讨论了理论上 $N \\approx 10000 d_{vc}$ 而实际上只需要 $N \\approx 10 d_{vc}$ 的能使得 $E_{out}$ 最小，并且分析了为什么理论上和实际上差别这么大</li>\n</ol>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\5\\5 - 2 - Effective Number of Lines (15-26)</p>\n<p>[2]机器学习基石(台湾大学-林轩田)\\5\\5 - 3 - Effective Number of Hypotheses (16-17)</p>\n<p>[3]机器学习基石(台湾大学-林轩田)\\5\\5 - 4 - Break Point (07-44)</p>\n<p>[4]机器学习基石(台湾大学-林轩田)\\6\\6 - 3 - Bounding Function- Inductive Cases (14-47)</p>\n<p>[5]机器学习基石(台湾大学-林轩田)\\6\\6 - 4 - A Pictorial Proof (16-01)</p>\n<p>[6]机器学习基石(台湾大学-林轩田)\\7\\7 - 4 - Interpreting VC Dimension (17-13)</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Why-can-Machine-Learn\"><a href=\"#Why-can-Machine-Learn\" class=\"headerlink\" title=\"Why can Machine Learn?\"></a>Why can Machine Learn?</h1><blockquote>\n<p>这一节我的思路是把老师的第五，六、七节的内容结合起来了，并且思路不完全按照老师的授课来走。</p>\n</blockquote>\n<hr>\n<h2 id=\"1-Preview-of-Last-Chapter\"><a href=\"#1-Preview-of-Last-Chapter\" class=\"headerlink\" title=\"1. Preview of Last Chapter\"></a>1. Preview of Last Chapter</h2><blockquote>\n<p>因为这一章的讨论是基于上一章最后一节得到的公式的，所以我们先Recap一下。</p>\n</blockquote>\n<p>上一节中，我们最后得出公式（1）（2）</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[  BAD \\quad D \\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2N  \\right) \\\\\n\\tag{$1$}</script><script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2M \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$2$}</script><blockquote>\n<p>这里的M是一个有限的数，所以当训练样本 $N$ 越大，那么Bad Data出现的概率越低，$E_{in} \\approx E_{out}$；如果训练样本 $N$一定的情况下，M越大，也就是说Hypothesis越多，那样可以供我们用算法 $A$进行选择的越多，那么越有可能选到一个好的样本，使得 $E_{in} \\approx 0$</p>\n</blockquote>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">M很小的时候</th>\n<th style=\"text-align:center\">M很大的时候</th>\n<th style=\"text-align:center\">N很小的时候</th>\n<th style=\"text-align:center\">N很大的时候</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$E_{in}(g) \\approx E_{out}(g)$</td>\n<td style=\"text-align:center\">Yes，Bad Data的数量也少了</td>\n<td style=\"text-align:center\">No，Bad Data的数量也多了</td>\n<td style=\"text-align:center\">Yes，Bad Data出现的概率变小了</td>\n<td style=\"text-align:center\">No，Bad Data出现的概率变大了</td>\n</tr>\n<tr>\n<td>$E_{in}(g) \\approx 0$</td>\n<td style=\"text-align:center\">No，选到低错误率的可能性变小了</td>\n<td style=\"text-align:center\">Yes，选到低错误率的可能性变大了</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n<td style=\"text-align:center\">没必然联系，样本总数多于少，与错误率无关</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>从表格中可以看出，$M$ 太大太小都会对机器学习的有效性造成影响，所以我们要进一步缩小$M$ 的取值范围。</p>\n<p>问题：怎么缩小$M$的取值范围</p>\n<p>解决方案：在上一节中，我们再推导的过程中使用了联合上限（Union Bound)，造成实际的上限被放大了很多。因为在做集合的或运算的时候，我们单纯的把各个集合加起来，但是却没有减去他们的交集部分，所以造成了上限被放大的问题。</p>\n</blockquote>\n<p>关于Union Bound 的推导可以看这个链接<a href=\"https://en.wikipedia.org/wiki/Boole%27s_inequality\" title=\"Boole&#39;s inequality\" target=\"_blank\" rel=\"external\">Boole’s inequality</a></p>\n<p>总的来说就是因为我们推导公式（1）的时候使用了Union Bound，所以导致了不等式右边的值（上限）被放大了，所以现在我们可以把它进行缩减，求出有效的 $M$值(即 $M_H(N)$)，下面我们来推导这个有效值。</p>\n<h2 id=\"2-VC-Bound-A-Upper-Bound-of-Hoeffding-Inequity\"><a href=\"#2-VC-Bound-A-Upper-Bound-of-Hoeffding-Inequity\" class=\"headerlink\" title=\"2. VC Bound - A Upper Bound of Hoeffding Inequity\"></a>2. VC Bound - A Upper Bound of Hoeffding Inequity</h2><h3 id=\"1-Introduction\"><a href=\"#1-Introduction\" class=\"headerlink\" title=\"1) Introduction\"></a>1) Introduction</h3><p>场景：对于不同数量$N$的训练数据，有多少种不同的方法 $effective(N)$ 可以区分他们？</p>\n<p>当 $N=1$ 的时候，如图一所示，共有2种方法，$effective(N) = 2 = 2^1$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-1%20number%3D1.png\" alt=\"N=1\"></p>\n<center> 图一 N=1 <sup>[1]</sup></center>\n\n\n<p>当 $N=2$ 的时候，如图二所示，共有4种方法，$effective(N) = 4 = 2^2$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-2%20number%3D2.png\" alt=\"N=2\"></p>\n<center> 图二 N=2 <sup>[1]</sup></center>\n\n\n<p>当 $N=3$ 的时候，如图三、四所示，最多有8种方法，虽然说在特定的情形下，可能只有6中种方法，$effective(N) = 8 = 2^3$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-4%20number%3D3%20with%20error.png\" alt=\"N=3 with error\"></p>\n<center> 图三 N=3 with error <sup>[2]</sup></center>\n\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-3%20number%3D3.png\" alt=\"N=3\"></p>\n<center> 图四 N=3 <sup>[1]</sup></center>\n\n\n\n<p>当 $N=4$ 的时候，如图五所示，无论怎么放着4个点，最多只有14种方法，$effective(N) = 14 &lt; 2^4$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-5%20number%3D4.png\" alt=\"N=4\"></p>\n<center> 图五 N=4 <sup>[1]</sup></center>\n\n\n<p>当 $N=5$ 的时候，很显然 $effective(N) = 32 &lt;  2^5$，就不再继续讨论了。</p>\n<p>总结如下表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>N</th>\n<th>$effctive(N)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>$2 = 2^1$</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>$4 = 2^2$</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>$8 = 2^3$</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>$14 &lt; 2^5$</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>$32 &lt;&lt; 2^6$</td>\n<td></td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td></td>\n</tr>\n<tr>\n<td>N</td>\n<td>$effctive(N) &lt;&lt; 2^N$</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>总结如图六，可以看出当 $N&gt;4$的时候，$effective(N) &lt; 2^N$，也就是说我们把 $M和N$ 的关系构建了起来，所以我们可以用 $effective(N)$ 去替换 $M$，得到公式(3)</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 2 \\cdot effective(N) \\cdot \\exp \\left( -2 \\epsilon^2 N \\right)\n\\tag{$3$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c26b572d17e970051568f6781b5420330ce9892e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-6%20summary.png\" alt=\"Summary\"></p>\n<center> 图六 Summary <sup>[1]</sup></center>\n\n\n\n<h3 id=\"2-Growth-function\"><a href=\"#2-Growth-function\" class=\"headerlink\" title=\"2) Growth function\"></a>2) Growth function</h3><p>上面Binary Clasification的分类方法叫做二分类法（dichotomy)，为了更好地表示 $N和effective(N)$ 的关系，我们引入成长函数（Growth Function) $M_H(N)$ 来表示，具体的数学表达如公式（4）所示。</p>\n<script type=\"math/tex; mode=display\">\nM_H(N) = \\max\\limits_{x_1,x_2,...,x_N ∈ X}  \\lvert H(x_1,x_2,...,x_N) \\rvert\n\\tag{$4$}  \\quad(其中，上限为2^N)</script><h3 id=\"3-Different-Types-of-Growth-function\"><a href=\"#3-Different-Types-of-Growth-function\" class=\"headerlink\" title=\"3) Different Types of Growth function\"></a>3) Different Types of Growth function</h3><h4 id=\"①-Growth-Function-for-Positive-Rays\"><a href=\"#①-Growth-Function-for-Positive-Rays\" class=\"headerlink\" title=\"① Growth Function for Positive Rays\"></a>① Growth Function for Positive Rays</h4><blockquote>\n<p>Positive Rays 是用一个一维向量作用于一维坐标上，与该向量同方向的值为+1，反方向为-1<br>如图七所示，Postives Rays 的成长函数为 $M_H(N) = (N-1)$，当 $N \\geq 2$的时候，$M_H(N) &lt; 2^N = O(N)$</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-7%20Growth%20Function%20for%20Positive%20Rays.png\" alt=\"Growth Function for Positive Rays\"></p>\n<center> 图七 Growth Function for Positive Rays <sup>[2]</sup></center>\n\n\n\n<h4 id=\"②-Growth-Function-for-Positive-Interval\"><a href=\"#②-Growth-Function-for-Positive-Interval\" class=\"headerlink\" title=\"② Growth Function for Positive Interval\"></a>② Growth Function for Positive Interval</h4><blockquote>\n<p>Positive Interval 是用一个一维“线段”作用于一维坐标上，与在线段里面的值为+1，外面的为-1<br>如图八所示，Positive Interval 的成长函数为 $M_H(N) = C_{N+1}^2 + 1 = \\frac{1}{2}N^2 + \\frac{1}{2}N + 1$，当 $N \\geq 3$的时候，$M_H(N) &lt; 2^N = O(N^2)$</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-8%20Growth%20Function%20for%20Positive%20Intervals.png\" alt=\"Growth Function for Positive Interval\"></p>\n<center> 图八 Growth Function for Positive Interval <sup>[2]</sup></center>\n\n\n\n<h4 id=\"③-Growth-Function-for-Convex-Sets\"><a href=\"#③-Growth-Function-for-Convex-Sets\" class=\"headerlink\" title=\"③ Growth Function for Convex Sets\"></a>③ Growth Function for Convex Sets</h4><blockquote>\n<p>Convex Sets 不太好理解。可以理解成在二维坐标上，用凸多边形去把所需要的点串起来。在多边形顶点上的点的值为+1，不在的为-1。因为我们讨论的是最大的可能性，所以当我们把所有的点都放在一个圆上的时候，必定存在一个凸多边形可以连接任意多个点（即可以画出任意多边形），然后再把所有点的组合情况加起来<br>如图九所示，Convex Setsl 的成长函数为 $M_H(N) = \\sum\\limits_{i=0}^{N}C_{i}^{N} = 2^N$</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/5e76112bcd38118a6046de5b5a666dff2b5eedee/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-9%20Growth%20Function%20for%20Convex%20Sets.png\" alt=\"Growth Function for Convex Sets\"></p>\n<center> 图九 Growth Function for Convex Sets <sup>[2]</sup></center>\n\n\n\n<h3 id=\"4-Break-Point-of-Growth-function\"><a href=\"#4-Break-Point-of-Growth-function\" class=\"headerlink\" title=\"4) Break Point of Growth function\"></a>4) Break Point of Growth function</h3><p>我们称能满足完全二分类(出现不同种类的数量为$2^N$)的情况为shattered,能shattered的最大的点为突破点(break point)。<br>然后根据上面对N从1-5的尝试，得到的最大可能性如下表</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>N</th>\n<th>$effctive(N)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>$2 = 2^1$</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>$4 = 2^2$</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>$8 = 2^3$</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>$14 &lt; 2^5$</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>$32 &lt;&lt; 2^6$</td>\n<td></td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td></td>\n</tr>\n<tr>\n<td>N</td>\n<td>$effctive(N) &lt;&lt; 2^N$</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>可以推断出公式（3）</p>\n<script type=\"math/tex; mode=display\">\neffctive(N): M_H(N) \\leq \\max( possible \\quad M_H(N) \\quad Given \\quad break- point \\quad(K)) \\leq 2^N\n\\tag{$3$}</script><p>上面关于Growth Function讨论的几种情况的Break Point 如图十所示，我们可以看出成长函数的复杂度与Break Point的大小存在一定的关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/033cce3063c6d35c7ac55af137821cf97819be44/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-10%20Break%20Point.png\" alt=\"Break Point of Growth function\"></p>\n<center> 图十 Break Point of Growth function <sup>[3]</sup></center>\n\n\n<h3 id=\"5-Bounding-Function\"><a href=\"#5-Bounding-Function\" class=\"headerlink\" title=\"5) Bounding Function\"></a>5) Bounding Function</h3><h4 id=\"①-Introduction-of-Bounding-Function\"><a href=\"#①-Introduction-of-Bounding-Function\" class=\"headerlink\" title=\"① Introduction of Bounding Function\"></a>① Introduction of Bounding Function</h4><p>根据上一节的Break Point $K$和样本点 $N$的关系，我们引入一个新概念，上限函数(Bounding Function) $B(N,K)$。这个函数表示有$N$个样本点且成长函数的突破点是$K$的时候，最多有多少种组合情况，比如说$B(3,2) = 3$（这个比较容易想象，这里就不展开讨论了）。并且这个上限函数满足公式（4），因为这是采用而分类的方法来进行的，最大值为$2^N$。</p>\n<script type=\"math/tex; mode=display\">\nB(N,K) \\leq 2^N\n\\tag{$3$}</script><p>但是显然在上面的例子中，我们可以看到$B(N,K) &lt; 2^N \\quad(N \\geq K)$，所以我们下面进一步确定这个上限函数的最大值。</p>\n<h4 id=\"②-Proof-of-Bounding-Function\"><a href=\"#②-Proof-of-Bounding-Function\" class=\"headerlink\" title=\"② Proof of Bounding Function\"></a>② Proof of Bounding Function</h4><p>我们下面用表格的方式来表示$B(N,K)$ 表格如下表，我们下面将会填满这个表格来找出相应的规律</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>1.根据上面的规律，我们知道在$N&lt;K$的时候，$B(N,K) = 2^N$，所以表格更新如下</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>2.然后当$K=1$的时候，我们至少有一种分法（全正或者全负），所以第一列全部为1，表格更新如下。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>3.接着，当$N=K$的时候，我们上面也可以看到，所有的值最大都等于$2^N-1$(因为不能所有情况都出现一次)，所以表格更新如下。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">3</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">7</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">15</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">31</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">63</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>4.在之前的章节，我们也数过$B(3,2) = 4$，其实看到这里我们已经大概有一些规律了：下面一项为上面两项之和， $B(N,K) = B(N-1, K) + B(N-1, K-1)$。当然我们只是猜测，下面我们继续证明。表格更新如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">3</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#F0FFF0)\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">7</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">15</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">31</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">63</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>5.我们证明上面的猜想$B(N,K) = B(N-1, K) + B(N-1, K-1)$<br>1）首先我们遍历B(4,3)，可以得到图十一的结果，然后我们整理了一下结果的顺序，可以发现橙色区域 {$x_1,x_2,x_3$}结果分别出现了2次，而紫色区域的{$x_1,x_2,x_3$}结果只出现了1次。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\" alt=\"Reorganized Dichotomies of B(4,3) - 1\"></p>\n<center> 图十一 Reorganized Dichotomies of B(4,3) - 1 <sup>[4]</sup></center>\n\n\n<p>2）所以我们单独把{$x_1,x_2,x_3$}，提出来看，并把橙色区域的个数设为 $\\alpha$，紫色区域的个数为 $\\beta$，那么原来4个点的情况 $B(4,3) = 2 \\alpha + \\beta$，而3个点的情况 $B(3,3) = \\alpha + \\beta$，如下图十二所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%202.png\" alt=\"Reorganized Dichotomies of B(4,3) - 2\"></p>\n<center> 图十二 Reorganized Dichotomies of B(4,3) - 2 <sup>[4]</sup></center>\n\n<p>3)接着我们单独看 $\\alpha$可以发现这个刚好是 $B(3,2)$ 的最大可能性，也就是说$ \\alpha \\leq B(3,2) = 4 $，如图十三所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%203.png\" alt=\"Reorganized Dichotomies of B(4,3) - 3\"></p>\n<center> 图十三 Reorganized Dichotomies of B(4,3) - 3 <sup>[4]</sup></center>\n\n\n<p>4） 根据上面的分析，我们目前得到三个公式，如下面的公式（4）（5）（6）。</p>\n<script type=\"math/tex; mode=display\">\nB(4,5) = 2 \\cdot \\alpha + \\beta\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\n\\alpha + \\beta \\leq B(3,3)\n\\tag{$5$}</script><script type=\"math/tex; mode=display\">\n\\alpha \\leq B(3,2)\n\\tag{$6$}</script><p>所以把公式(5)(6)加起来，我们可以更新公式（4）为公式（7）</p>\n<script type=\"math/tex; mode=display\">\nB(4,5) \\leq 2 \\cdot \\alpha + \\beta\n\\tag{$7$}</script><p>5）最后我们用同样的方法来研究$B(N,K)$可以很容易证明到公式（8）（9）（10）</p>\n<script type=\"math/tex; mode=display\">\nB(N - 1,K) \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i}\n\\tag{$8$}</script><script type=\"math/tex; mode=display\">\nB(N - 1,K - 1) \\leq \\sum\\limits_{i=0}^{k-2} C_{N-1}^{i} = \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i}\n\\tag{$9$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nB(N,K)  & \\leq {B(N-1,K) + B(N-1,K-1)} \\\\\n        & \\leq \\sum\\limits_{i=0}^{k-1} C_{N-1}^{i} + \\sum\\limits_{i=1}^{k-1} C_{N-1}^{i} \\\\\n        & = C_{N-1}^0 + \\sum\\limits_{i=1}^{k-1} \\left( C_{N-1}^{i} + C_{N-1}^{i}\\right)  \\\\\n        & = 1 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = C_{N}^0 + \\sum\\limits_{i=1}^{k-1} C_{N}^{i}  \\\\\n        & = \\sum\\limits_{i=0}^{k-1} C_{N}^{i}\n\\end{align}\n\\tag{$10$}</script><p>所以我们的表格更新如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$B(N,K)$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0120\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">2</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">3</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">4</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#F0FFF0)\">4</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">7</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">8</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq5$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500\">11</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">15</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">16</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq6$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq16$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq15$</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">31</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">32</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq7$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq22$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq26$</font></td>\n<td style=\"text-align:center\"><font color=\"#FFA500)\">$\\leq57$</font></td>\n<td style=\"text-align:center\"><font color=\"#FF0000\">63</font></td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\"><font color=\"#0000FF\">1</font></td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>我们再把$N^{K-1}$的表格整理如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">$N^{N-1}$</th>\n<th style=\"text-align:center\">K=1</th>\n<th style=\"text-align:center\">K=2</th>\n<th style=\"text-align:center\">K=3</th>\n<th style=\"text-align:center\">K=4</th>\n<th style=\"text-align:center\">K=5</th>\n<th style=\"text-align:center\">K=6</th>\n<th style=\"text-align:center\">…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">N=1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=3</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">81</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=4</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">64</td>\n<td style=\"text-align:center\">256</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=5</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">125</td>\n<td style=\"text-align:center\">125</td>\n<td style=\"text-align:center\">625</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">N=6</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">36</td>\n<td style=\"text-align:center\">216</td>\n<td style=\"text-align:center\">216</td>\n<td style=\"text-align:center\">1296</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td style=\"text-align:center\">…</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对比图参考老师上课的PPT，如图十四所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-14%20Comparision%20of%20B(N%2CK)%20and%20N%5E(K-1).png\" alt=\"Comparision of B(N,K) and N^(K-1)\"></p>\n<center> 图十四 Comparision of B(N,K) and N^(K-1) <sup>[6]</sup></center>\n\n\n<p>总结起来就是：在$N \\geq 2, K \\geq 3$的时候，总有公式（11）的情况。</p>\n<script type=\"math/tex; mode=display\">\nM_H(N) \\leq B(N,K) = \\sum\\limits_{i=0}^{K-1} \\leq N^{K-1}\n\\tag{$11$}</script><h3 id=\"6-Vapnik-Chervonenkis-VC-bound\"><a href=\"#6-Vapnik-Chervonenkis-VC-bound\" class=\"headerlink\" title=\"6) Vapnik-Chervonenkis (VC) bound\"></a>6) Vapnik-Chervonenkis (VC) bound</h3><p>@TODO: 这一节主要是证明从数学的角度上证明VC Bound 并以此更新Hoeffding Inequity。目前听得失一知半解，所以只贴出结论，后面再补充。</p>\n<p>结论如图十五所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/738603b7f8e8f10505a791140c32f4677d4e7d84/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-13%20VC%20bound.png\" alt=\"Vapnik-Chervonenkis (VC) bound\"></p>\n<center> 图十五 Vapnik-Chervonenkis (VC) bound <sup>[5]</sup></center>\n\n<p>这个VC Bound的作用是把之前Hoeffding的参数 $M$替换成这里引入的成长函数 $M_H(N)$，并构建出成长函数与样本数量（N）的关系这样的话，我们就可以容易的得到结论：在样本N足够大时候，发生Bad Data的概率小于 $epsilon$ ($E_{in} \\approx E_{out}$)，可以得出错误率也低($E_{in} \\approx 0$)，说明机器学习是可能的。</p>\n<p>也就是说要说机器可以学习必须满足下面的条件：</p>\n<ol>\n<li>假设空间的成长函数 $M_H(N)$ 存在Break Point K （即有一个好的假设空间$H$)</li>\n<li>输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）</li>\n<li>存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ —&gt;也就是我们后面会研究的重点）</li>\n</ol>\n<p>其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ $\\Longrightarrow$ Machine Can Learn.</p>\n<hr>\n<p><br><br></p>\n<h2 id=\"3-The-VC-Dimension\"><a href=\"#3-The-VC-Dimension\" class=\"headerlink\" title=\"3. The VC Dimension\"></a>3. The VC Dimension</h2><h3 id=\"1-Definition-of-VC-Dimension\"><a href=\"#1-Definition-of-VC-Dimension\" class=\"headerlink\" title=\"1) Definition of VC Dimension\"></a>1) Definition of VC Dimension</h3><p>VC Dimension( $d_{vc}$ )指的是能够使得成长函数可以被shatter的最大值（即 Break Point - 1)，用符号表示为公式（12）。</p>\n<script type=\"math/tex; mode=display\">\nd_{vc} = min(K) -1\n\\tag{$12$}</script><p>上面的Hoeffding Inequity可以变成公式（13）</p>\n<script type=\"math/tex; mode=display\">\n\\rho \\left[ \\lvert E_{in}(g) - E_{out}(g) \\rvert  > \\epsilon\\right] \\leq 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right)\n\\tag{$13$}</script><p>因此，根据这个特点，我们只要确保一个成长函数存在 VC Dimension，我们就可以确定他存在Break Point，是一个好的假设空间。</p>\n<h3 id=\"2-Generalization-Error\"><a href=\"#2-Generalization-Error\" class=\"headerlink\" title=\"2) Generalization Error\"></a>2) Generalization Error</h3><p>我们引入泛化误差 $\\delta$ 表示 $E_{in}(g) 和 E_{out}(g)$ 的接近程度，即 $\\delta = E_{in}(g) - E_{out}(g)$ ，根据公式（13），我们稍作化简，如公式（14）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\delta                           &= 4 \\cdot (2N)^{d_{vc}} \\cdot \\exp \\left( -\\frac{1}{8} \\epsilon^2 N \\right) \\\\\n\\frac{4 (2N)^{d_{vc}}}{\\delta}   &= \\exp(\\frac{1}{8} \\epsilon^2 N)  \\\\\n\\epsilon                         &= \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\end{align}\n\\tag{$14$}</script><p>也就是说 $E_{in}(g) - E_{out}(g)$ 的误差会小于等于 $\\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}$。 所以我们可以求得 $E_{out}$ 的范围如公式（15）</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(g) -  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )} \\leq E_{out}(g) \\leq E_{in}(g) + \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )})\n\\tag{$15$}</script><h3 id=\"3-Model-Complexity\"><a href=\"#3-Model-Complexity\" class=\"headerlink\" title=\"3) Model Complexity\"></a>3) Model Complexity</h3><p>上一节，我们求出了 $E_{in}(g) - E_{out}(g)$ 的误差，为了方便引用，我们引入了新的概念：模型复杂度（Model Complexitiy）来表示这个误差值，数学表示如公式（16）</p>\n<script type=\"math/tex; mode=display\">\n\\Omega(N,H,\\delta) =  \\sqrt{\\frac{8}{N} \\cdot \\ln( \\frac{4(2N)^{d_{vc}}}{\\delta} )}\n\\tag{$15$}</script><p>可以看出，随着VC Dimension的增大，$\\Omega$也会变大，然后 $E_{in}(g)$ 也会随着VC Dimension的增大而变小（因为选择的假设空间大了），但是 $E_{out}(g)$ 却不是一个单调函数，因为公式（15），然后这2个值一个变大一个变小，但是最终的话，$E_{out}$ 的曲线是先下降，然后上升（遍历一边就可以得到结果了），所以找到 $d_{vc}^{*}$ 很重要。(因为 $E_{out}$ 才是我们机器学习最重要的指标）<br>结果如图十四所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png\" alt=\"Error and VC dimension\"></p>\n<center> 图十六 Error and VC dimension <sup>[6]</sup></center>\n\n\n<h3 id=\"4-How-much-Data-We-need-Theoretically-and-Practically\"><a href=\"#4-How-much-Data-We-need-Theoretically-and-Practically\" class=\"headerlink\" title=\"4) How much Data We need Theoretically and Practically\"></a>4) How much Data We need Theoretically and Practically</h3><p>问题：假如现在老板给员工下达了一个任务，要求这个模型的 ${\\epsilon = 0.1，\\delta = 0.1，  d_{vc} = 3}$ ，那样的话，我们需要多少个样本 $N$ 才能满足要求呢？<br>回答：根据上面的公式（14），分别代入参数到等式中，可以求得样本数量 $N$ 如图十五的橙色区域所示。但是实际上，我们只需要 $10d_{vc}$就足够了。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bab59f769a00e4a303287ff809ff1df7a2916f55/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-15%20Error%20and%20VC%20dimension.png\" alt=\"How much Data We need Theoretically and Practically\"></p>\n<p><center> 图十七 How much Data We need Theoretically and Practically <sup>[6]</sup></center><br><br></p>\n<p>因为我们在计算的时候同样的把上限给放大了，放大的原因如下所示:</p>\n<ol>\n<li>Hoeffding Inequity 不需要知道未知的情况，但是VC Bound可以用于各种分布，各种目标函数(因为 VC Bound的推导是基于不同的N和K)；</li>\n<li>在给Binary Classification 强行装上成长函数本身就是一个宽松的上界，但是VC Bound可以用于各种数据样本；</li>\n<li>使用二项式 $N^{d_{vc}}$ 作为成长函数的上界使得约束更加宽松，但是VC Bound可以用于任意具有相同VC维的假设空间；</li>\n<li>联合限制（union bound）并不是一定会选择出现不好事情的假设函数，但是VC Bound可以用于任意算法。</li>\n</ol>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>我们首先通过回顾上一节的内容，得到结论是根据Hoeffding Inquity: 要使得机器可以学习的条件是 ① $E_{in} \\approx E_{out}$ ② $E_{in} \\approx 0$</li>\n<li>接着我们讨论了什么情况下才能保证这2个条件满足，进行了讨论，最终我们通过引入① Growth Function ② Break Point ③ VC Bound, VC Dimension 更改Hoeffding Inequity的上限，最终得到我们需要的答案：<ul>\n<li>假设空间的成长函数 $M_H(N)$ 存在Break Point $K$ （即有一个好的假设空间 $H$)</li>\n<li>输入数据的样本 $N$ 足够大（有一个好的数据集 $D$）</li>\n<li>存在一个算法，能够找出能在假设空间 $H$ 中找到一个值使得错误率 $E_{in}$ 足够小 （有一个好的算法 $A$ —&gt;也就是我们后面会研究的重点）</li>\n<li>其中：条件1和2通过VC Bound保证了 $E_{in} \\approx E_{out}$，条件3保证了 $E_{in} \\approx 0$ ⟹ Machine Can Learn.</li>\n</ul>\n</li>\n<li>之后我们讨论了理论上 $N \\approx 10000 d_{vc}$ 而实际上只需要 $N \\approx 10 d_{vc}$ 的能使得 $E_{out}$ 最小，并且分析了为什么理论上和实际上差别这么大</li>\n</ol>\n<hr>\n<p><br><br><br></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\5\\5 - 2 - Effective Number of Lines (15-26)</p>\n<p>[2]机器学习基石(台湾大学-林轩田)\\5\\5 - 3 - Effective Number of Hypotheses (16-17)</p>\n<p>[3]机器学习基石(台湾大学-林轩田)\\5\\5 - 4 - Break Point (07-44)</p>\n<p>[4]机器学习基石(台湾大学-林轩田)\\6\\6 - 3 - Bounding Function- Inductive Cases (14-47)</p>\n<p>[5]机器学习基石(台湾大学-林轩田)\\6\\6 - 4 - A Pictorial Proof (16-01)</p>\n<p>[6]机器学习基石(台湾大学-林轩田)\\7\\7 - 4 - Interpreting VC Dimension (17-13)</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"6.How can Machine Learn? - Noice and Error","date":"2017-10-09T08:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# How can Machine Learn? - Noice and Error\n\n> 这一节主要讨论存在噪音的情况下，上一节中讨论的VC Bound 还能否适用，我们能不能相信机器能学到东西。\n\n## 1. Noise\n### 1) Introduction of Noise\n噪音数据指的是：在实际情况中，与所希望的值不一样的数据。\n\n噪声有几种错误：\n1. noise in y: mislabeled data;\n2. noise in y: different labels for same x;\n3. noise in x: error x.\n4. ...\n\n造成噪声的原因也有很多种，比如：\n1. 数据在测量时产生误差\n2. 数据录入错误\n3. 数据在处理过程中处理不当\n4. ...\n\n\n### 2) The Influence of Noise\n继续以之前抽球的例子来说明，在一个罐子中有很多小球，要么是绿色，要么是橙色，假设存在一个会不断变色的小球，颜色不停的快速变化着（即噪音），我们称之为概率性小球（Probabilitic Ball），其他的小球颜色都固定，我们称为确定性小球（Deterministic Ball）。那么确定性的小球满足公式（1）的概率，然后我们再假设这个概率性小球为+1的概率为0.7，那么满足下面公式（2）。\n$$\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 1   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$1$}\n$$\n\n$$\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 0.7   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0.3  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$2$}\n$$\n\n两个分布函数 $\\rho(x)$ 和 $\\rho(y|x)$ ，其中 $\\rho(x)$ 越大意味着 $x$ 被选为中的概率越大，$\\rho(y|x)$越大意味着该样本属于某一类的概率越大，所以联合概率指的是样本点上分类尽量正确的可能性。这种含有噪音的输入样本以及标记分别服从 $\\rho(x)$ 和 $\\rho(y|x)$，即 $(x,y)$ 服从 $\\rho(x,y)$ 的联合概率分布。所以VC限制依然适用。\n\n所以我们的流程图更新为图一所示。\n\n![Learning Flow](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a4a0aeb4e07f1c860787df98a08d247319527acf/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-1%20Noice.png)\n<center>图一 Learning Flow<sup>[1]</sup></center>\n<br>\n\n## 2. Error\n这里主要介绍 Pointwise Error Measure的方法\n### 1) Pointwise Error Measure\n我们用每个点的误差衡量来衡量整体误差，用 $err()$ 表示。\n对应 $E_{in}(g), E_{out}(g)$可以用下面公式（3）和（4）表示。\n\n$$\nE_{in}(g) = \\frac{1}{N} \\cdot \\sum\\limits_{n=1}^N err(g(x_n), f(x_n))\n\\tag{$3$}\n$$\n\n$$\nE_{out}(g) = \\epsilon \\cdot err(g(x), f(x))\n\\tag{$4$}\n$$\n\n\n### 2) Two Important Pointwise Error Measures\n我们用0/1错误来衡量分类问题，用平方错误来衡量回归问题。其数学表达式，如公式（5）（6）所示\n$$\nerr( \\tilde{y}, y) = \\left[\\left[ \\tilde{y} \\neq y \\right]\\right]\n\\tag{$5$}\n$$\n\n$$\nerr( \\tilde{y}, y) = \\left( \\tilde{y} - y \\right)^2\n\\tag{$6$}\n$$\n\n### 3) Choice of Error Measures\n对于二元分类问题错误的类型也分为两类，如图二所示。\n\n![Error Types of Binary Classification](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/82fc93d617c6aec7addbbc0bcff9207f127e42f9/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-2%20Error.png)\n<center>图二 Error Types of Binary Classification<sup>[2]</sup></center>\n<br>\n\n在目标函数f为+1时，假设函数g却给出了-1，这种错误叫做错误的拒绝（false reject），另一种是在目标函数f为-1时，假设函数g却给出了+1，这种错误叫做错误的接受（false accept）。\n\n然后在不同的应用场合下，如果我们要给错误加上权重，那么这个权重会不一样。比如说：\n\n> 1. 超市指纹识别的例子\n\n如果在超市中通过指纹识别来进行打折活动，如果是vip用户，之前有指纹录入的话，就应该有优惠活动，否则没有。\n如果发生false reject的情况，那么顾客可能会不高兴，这样就会损失了一部分未来的生意；而如果发生false accept的话，超市只不过损失了一点小钱。\n所以对于超市的成本表如图三所示，false reject会牺牲成本比较大，而false accept牺牲的成本会较小。所以，我们应该尽量避免false reject的情形。\n\n![Finger Verification for Supermarket](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-3%20example-supermarket.png)\n<center>图三 Finger Verification for Supermarket<sup>[3]</sup></center>\n<br>\n\n\n> 2. CIA指纹识别的例子\n\n如果美国中情局，用指纹识别来判断该人是否有权限进入系统查看重要资料。\n那么，发生false accept的情况会导致很严重的后果，而false reject的话，就不会有太大的影响。\n所以对于CIA的成本表如图四所示，应该尽量避免false accept的情形。\n\n![Finger Verification for CIA](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-4%20example-cia.png)\n<center>图四 Finger Verification for CIA<sup>[3]</sup></center>\n<br>\n\n<br><br>\n----------------------------------\n# Summary\n1. 首先介绍了Noise，并且讨论了Noise对我们的VC Bound不会产生影响，即Noise不影响机器学习的可行性。\n2. 然后介绍了Error，然后讨论了0/1错误来衡量二元分类问题，以及用平方错误来衡量回归问题。\n3. 最后讨论了不同应用场景下的Error应该加上不同的权重，比如超市和CIA的指纹识别系统的侧重点不同。\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\8\\8 - 1 - Noise and Probabilistic Target (17-01)\n\n[2]机器学习基石(台湾大学-林轩田)\\8\\8 - 2 - Error Measure (15-10)\n\n[3]机器学习基石(台湾大学-林轩田)\\8\\8 - 3 - Algorithmic Error Measure (13-46)\n\n<br>\n<br>\n---------------------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-09-6.How can Machine Learn - Noice and Error.md","raw":"---\ntitle: 6.How can Machine Learn? - Noice and Error\ndate: 2017-10-09 16:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# How can Machine Learn? - Noice and Error\n\n> 这一节主要讨论存在噪音的情况下，上一节中讨论的VC Bound 还能否适用，我们能不能相信机器能学到东西。\n\n## 1. Noise\n### 1) Introduction of Noise\n噪音数据指的是：在实际情况中，与所希望的值不一样的数据。\n\n噪声有几种错误：\n1. noise in y: mislabeled data;\n2. noise in y: different labels for same x;\n3. noise in x: error x.\n4. ...\n\n造成噪声的原因也有很多种，比如：\n1. 数据在测量时产生误差\n2. 数据录入错误\n3. 数据在处理过程中处理不当\n4. ...\n\n\n### 2) The Influence of Noise\n继续以之前抽球的例子来说明，在一个罐子中有很多小球，要么是绿色，要么是橙色，假设存在一个会不断变色的小球，颜色不停的快速变化着（即噪音），我们称之为概率性小球（Probabilitic Ball），其他的小球颜色都固定，我们称为确定性小球（Deterministic Ball）。那么确定性的小球满足公式（1）的概率，然后我们再假设这个概率性小球为+1的概率为0.7，那么满足下面公式（2）。\n$$\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 1   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$1$}\n$$\n\n$$\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 0.7   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0.3  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$2$}\n$$\n\n两个分布函数 $\\rho(x)$ 和 $\\rho(y|x)$ ，其中 $\\rho(x)$ 越大意味着 $x$ 被选为中的概率越大，$\\rho(y|x)$越大意味着该样本属于某一类的概率越大，所以联合概率指的是样本点上分类尽量正确的可能性。这种含有噪音的输入样本以及标记分别服从 $\\rho(x)$ 和 $\\rho(y|x)$，即 $(x,y)$ 服从 $\\rho(x,y)$ 的联合概率分布。所以VC限制依然适用。\n\n所以我们的流程图更新为图一所示。\n\n![Learning Flow](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a4a0aeb4e07f1c860787df98a08d247319527acf/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-1%20Noice.png)\n<center>图一 Learning Flow<sup>[1]</sup></center>\n<br>\n\n## 2. Error\n这里主要介绍 Pointwise Error Measure的方法\n### 1) Pointwise Error Measure\n我们用每个点的误差衡量来衡量整体误差，用 $err()$ 表示。\n对应 $E_{in}(g), E_{out}(g)$可以用下面公式（3）和（4）表示。\n\n$$\nE_{in}(g) = \\frac{1}{N} \\cdot \\sum\\limits_{n=1}^N err(g(x_n), f(x_n))\n\\tag{$3$}\n$$\n\n$$\nE_{out}(g) = \\epsilon \\cdot err(g(x), f(x))\n\\tag{$4$}\n$$\n\n\n### 2) Two Important Pointwise Error Measures\n我们用0/1错误来衡量分类问题，用平方错误来衡量回归问题。其数学表达式，如公式（5）（6）所示\n$$\nerr( \\tilde{y}, y) = \\left[\\left[ \\tilde{y} \\neq y \\right]\\right]\n\\tag{$5$}\n$$\n\n$$\nerr( \\tilde{y}, y) = \\left( \\tilde{y} - y \\right)^2\n\\tag{$6$}\n$$\n\n### 3) Choice of Error Measures\n对于二元分类问题错误的类型也分为两类，如图二所示。\n\n![Error Types of Binary Classification](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/82fc93d617c6aec7addbbc0bcff9207f127e42f9/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-2%20Error.png)\n<center>图二 Error Types of Binary Classification<sup>[2]</sup></center>\n<br>\n\n在目标函数f为+1时，假设函数g却给出了-1，这种错误叫做错误的拒绝（false reject），另一种是在目标函数f为-1时，假设函数g却给出了+1，这种错误叫做错误的接受（false accept）。\n\n然后在不同的应用场合下，如果我们要给错误加上权重，那么这个权重会不一样。比如说：\n\n> 1. 超市指纹识别的例子\n\n如果在超市中通过指纹识别来进行打折活动，如果是vip用户，之前有指纹录入的话，就应该有优惠活动，否则没有。\n如果发生false reject的情况，那么顾客可能会不高兴，这样就会损失了一部分未来的生意；而如果发生false accept的话，超市只不过损失了一点小钱。\n所以对于超市的成本表如图三所示，false reject会牺牲成本比较大，而false accept牺牲的成本会较小。所以，我们应该尽量避免false reject的情形。\n\n![Finger Verification for Supermarket](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-3%20example-supermarket.png)\n<center>图三 Finger Verification for Supermarket<sup>[3]</sup></center>\n<br>\n\n\n> 2. CIA指纹识别的例子\n\n如果美国中情局，用指纹识别来判断该人是否有权限进入系统查看重要资料。\n那么，发生false accept的情况会导致很严重的后果，而false reject的话，就不会有太大的影响。\n所以对于CIA的成本表如图四所示，应该尽量避免false accept的情形。\n\n![Finger Verification for CIA](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-4%20example-cia.png)\n<center>图四 Finger Verification for CIA<sup>[3]</sup></center>\n<br>\n\n<br><br>\n----------------------------------\n# Summary\n1. 首先介绍了Noise，并且讨论了Noise对我们的VC Bound不会产生影响，即Noise不影响机器学习的可行性。\n2. 然后介绍了Error，然后讨论了0/1错误来衡量二元分类问题，以及用平方错误来衡量回归问题。\n3. 最后讨论了不同应用场景下的Error应该加上不同的权重，比如超市和CIA的指纹识别系统的侧重点不同。\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1]机器学习基石(台湾大学-林轩田)\\8\\8 - 1 - Noise and Probabilistic Target (17-01)\n\n[2]机器学习基石(台湾大学-林轩田)\\8\\8 - 2 - Error Measure (15-10)\n\n[3]机器学习基石(台湾大学-林轩田)\\8\\8 - 3 - Algorithmic Error Measure (13-46)\n\n<br>\n<br>\n---------------------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-09-6.How can Machine Learn - Noice and Error","published":1,"updated":"2018-10-27T04:30:42.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bn001le0ow19w5btxs","content":"<h1 id=\"How-can-Machine-Learn-Noice-and-Error\"><a href=\"#How-can-Machine-Learn-Noice-and-Error\" class=\"headerlink\" title=\"How can Machine Learn? - Noice and Error\"></a>How can Machine Learn? - Noice and Error</h1><blockquote>\n<p>这一节主要讨论存在噪音的情况下，上一节中讨论的VC Bound 还能否适用，我们能不能相信机器能学到东西。</p>\n</blockquote>\n<h2 id=\"1-Noise\"><a href=\"#1-Noise\" class=\"headerlink\" title=\"1. Noise\"></a>1. Noise</h2><h3 id=\"1-Introduction-of-Noise\"><a href=\"#1-Introduction-of-Noise\" class=\"headerlink\" title=\"1) Introduction of Noise\"></a>1) Introduction of Noise</h3><p>噪音数据指的是：在实际情况中，与所希望的值不一样的数据。</p>\n<p>噪声有几种错误：</p>\n<ol>\n<li>noise in y: mislabeled data;</li>\n<li>noise in y: different labels for same x;</li>\n<li>noise in x: error x.</li>\n<li>…</li>\n</ol>\n<p>造成噪声的原因也有很多种，比如：</p>\n<ol>\n<li>数据在测量时产生误差</li>\n<li>数据录入错误</li>\n<li>数据在处理过程中处理不当</li>\n<li>…</li>\n</ol>\n<h3 id=\"2-The-Influence-of-Noise\"><a href=\"#2-The-Influence-of-Noise\" class=\"headerlink\" title=\"2) The Influence of Noise\"></a>2) The Influence of Noise</h3><p>继续以之前抽球的例子来说明，在一个罐子中有很多小球，要么是绿色，要么是橙色，假设存在一个会不断变色的小球，颜色不停的快速变化着（即噪音），我们称之为概率性小球（Probabilitic Ball），其他的小球颜色都固定，我们称为确定性小球（Deterministic Ball）。那么确定性的小球满足公式（1）的概率，然后我们再假设这个概率性小球为+1的概率为0.7，那么满足下面公式（2）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 1   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$1$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 0.7   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0.3  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$2$}</script><p>两个分布函数 $\\rho(x)$ 和 $\\rho(y|x)$ ，其中 $\\rho(x)$ 越大意味着 $x$ 被选为中的概率越大，$\\rho(y|x)$越大意味着该样本属于某一类的概率越大，所以联合概率指的是样本点上分类尽量正确的可能性。这种含有噪音的输入样本以及标记分别服从 $\\rho(x)$ 和 $\\rho(y|x)$，即 $(x,y)$ 服从 $\\rho(x,y)$ 的联合概率分布。所以VC限制依然适用。</p>\n<p>所以我们的流程图更新为图一所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a4a0aeb4e07f1c860787df98a08d247319527acf/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-1%20Noice.png\" alt=\"Learning Flow\"></p>\n<p><center>图一 Learning Flow<sup>[1]</sup></center><br><br></p>\n<h2 id=\"2-Error\"><a href=\"#2-Error\" class=\"headerlink\" title=\"2. Error\"></a>2. Error</h2><p>这里主要介绍 Pointwise Error Measure的方法</p>\n<h3 id=\"1-Pointwise-Error-Measure\"><a href=\"#1-Pointwise-Error-Measure\" class=\"headerlink\" title=\"1) Pointwise Error Measure\"></a>1) Pointwise Error Measure</h3><p>我们用每个点的误差衡量来衡量整体误差，用 $err()$ 表示。<br>对应 $E_{in}(g), E_{out}(g)$可以用下面公式（3）和（4）表示。</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(g) = \\frac{1}{N} \\cdot \\sum\\limits_{n=1}^N err(g(x_n), f(x_n))\n\\tag{$3$}</script><script type=\"math/tex; mode=display\">\nE_{out}(g) = \\epsilon \\cdot err(g(x), f(x))\n\\tag{$4$}</script><h3 id=\"2-Two-Important-Pointwise-Error-Measures\"><a href=\"#2-Two-Important-Pointwise-Error-Measures\" class=\"headerlink\" title=\"2) Two Important Pointwise Error Measures\"></a>2) Two Important Pointwise Error Measures</h3><p>我们用0/1错误来衡量分类问题，用平方错误来衡量回归问题。其数学表达式，如公式（5）（6）所示</p>\n<script type=\"math/tex; mode=display\">\nerr( \\tilde{y}, y) = \\left[\\left[ \\tilde{y} \\neq y \\right]\\right]\n\\tag{$5$}</script><script type=\"math/tex; mode=display\">\nerr( \\tilde{y}, y) = \\left( \\tilde{y} - y \\right)^2\n\\tag{$6$}</script><h3 id=\"3-Choice-of-Error-Measures\"><a href=\"#3-Choice-of-Error-Measures\" class=\"headerlink\" title=\"3) Choice of Error Measures\"></a>3) Choice of Error Measures</h3><p>对于二元分类问题错误的类型也分为两类，如图二所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/82fc93d617c6aec7addbbc0bcff9207f127e42f9/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-2%20Error.png\" alt=\"Error Types of Binary Classification\"></p>\n<p><center>图二 Error Types of Binary Classification<sup>[2]</sup></center><br><br></p>\n<p>在目标函数f为+1时，假设函数g却给出了-1，这种错误叫做错误的拒绝（false reject），另一种是在目标函数f为-1时，假设函数g却给出了+1，这种错误叫做错误的接受（false accept）。</p>\n<p>然后在不同的应用场合下，如果我们要给错误加上权重，那么这个权重会不一样。比如说：</p>\n<blockquote>\n<ol>\n<li>超市指纹识别的例子</li>\n</ol>\n</blockquote>\n<p>如果在超市中通过指纹识别来进行打折活动，如果是vip用户，之前有指纹录入的话，就应该有优惠活动，否则没有。<br>如果发生false reject的情况，那么顾客可能会不高兴，这样就会损失了一部分未来的生意；而如果发生false accept的话，超市只不过损失了一点小钱。<br>所以对于超市的成本表如图三所示，false reject会牺牲成本比较大，而false accept牺牲的成本会较小。所以，我们应该尽量避免false reject的情形。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-3%20example-supermarket.png\" alt=\"Finger Verification for Supermarket\"></p>\n<p><center>图三 Finger Verification for Supermarket<sup>[3]</sup></center><br><br></p>\n<blockquote>\n<ol>\n<li>CIA指纹识别的例子</li>\n</ol>\n</blockquote>\n<p>如果美国中情局，用指纹识别来判断该人是否有权限进入系统查看重要资料。<br>那么，发生false accept的情况会导致很严重的后果，而false reject的话，就不会有太大的影响。<br>所以对于CIA的成本表如图四所示，应该尽量避免false accept的情形。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-4%20example-cia.png\" alt=\"Finger Verification for CIA\"></p>\n<p><center>图四 Finger Verification for CIA<sup>[3]</sup></center><br><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Noise，并且讨论了Noise对我们的VC Bound不会产生影响，即Noise不影响机器学习的可行性。</li>\n<li>然后介绍了Error，然后讨论了0/1错误来衡量二元分类问题，以及用平方错误来衡量回归问题。</li>\n<li>最后讨论了不同应用场景下的Error应该加上不同的权重，比如超市和CIA的指纹识别系统的侧重点不同。</li>\n</ol>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\8\\8 - 1 - Noise and Probabilistic Target (17-01)</p>\n<p>[2]机器学习基石(台湾大学-林轩田)\\8\\8 - 2 - Error Measure (15-10)</p>\n<p>[3]机器学习基石(台湾大学-林轩田)\\8\\8 - 3 - Algorithmic Error Measure (13-46)</p>\n<p><br></p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Noice-and-Error\"><a href=\"#How-can-Machine-Learn-Noice-and-Error\" class=\"headerlink\" title=\"How can Machine Learn? - Noice and Error\"></a>How can Machine Learn? - Noice and Error</h1><blockquote>\n<p>这一节主要讨论存在噪音的情况下，上一节中讨论的VC Bound 还能否适用，我们能不能相信机器能学到东西。</p>\n</blockquote>\n<h2 id=\"1-Noise\"><a href=\"#1-Noise\" class=\"headerlink\" title=\"1. Noise\"></a>1. Noise</h2><h3 id=\"1-Introduction-of-Noise\"><a href=\"#1-Introduction-of-Noise\" class=\"headerlink\" title=\"1) Introduction of Noise\"></a>1) Introduction of Noise</h3><p>噪音数据指的是：在实际情况中，与所希望的值不一样的数据。</p>\n<p>噪声有几种错误：</p>\n<ol>\n<li>noise in y: mislabeled data;</li>\n<li>noise in y: different labels for same x;</li>\n<li>noise in x: error x.</li>\n<li>…</li>\n</ol>\n<p>造成噪声的原因也有很多种，比如：</p>\n<ol>\n<li>数据在测量时产生误差</li>\n<li>数据录入错误</li>\n<li>数据在处理过程中处理不当</li>\n<li>…</li>\n</ol>\n<h3 id=\"2-The-Influence-of-Noise\"><a href=\"#2-The-Influence-of-Noise\" class=\"headerlink\" title=\"2) The Influence of Noise\"></a>2) The Influence of Noise</h3><p>继续以之前抽球的例子来说明，在一个罐子中有很多小球，要么是绿色，要么是橙色，假设存在一个会不断变色的小球，颜色不停的快速变化着（即噪音），我们称之为概率性小球（Probabilitic Ball），其他的小球颜色都固定，我们称为确定性小球（Deterministic Ball）。那么确定性的小球满足公式（1）的概率，然后我们再假设这个概率性小球为+1的概率为0.7，那么满足下面公式（2）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 1   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$1$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\n&\\rho \\left( +1|x \\right) = 0.7   &\\quad(当 y = f(x)) \\\\\n&\\rho \\left( -1|x \\right) = 0.3  &\\quad(当 y \\neq f(x))\n\\end{align}\n\\tag{$2$}</script><p>两个分布函数 $\\rho(x)$ 和 $\\rho(y|x)$ ，其中 $\\rho(x)$ 越大意味着 $x$ 被选为中的概率越大，$\\rho(y|x)$越大意味着该样本属于某一类的概率越大，所以联合概率指的是样本点上分类尽量正确的可能性。这种含有噪音的输入样本以及标记分别服从 $\\rho(x)$ 和 $\\rho(y|x)$，即 $(x,y)$ 服从 $\\rho(x,y)$ 的联合概率分布。所以VC限制依然适用。</p>\n<p>所以我们的流程图更新为图一所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a4a0aeb4e07f1c860787df98a08d247319527acf/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-1%20Noice.png\" alt=\"Learning Flow\"></p>\n<p><center>图一 Learning Flow<sup>[1]</sup></center><br><br></p>\n<h2 id=\"2-Error\"><a href=\"#2-Error\" class=\"headerlink\" title=\"2. Error\"></a>2. Error</h2><p>这里主要介绍 Pointwise Error Measure的方法</p>\n<h3 id=\"1-Pointwise-Error-Measure\"><a href=\"#1-Pointwise-Error-Measure\" class=\"headerlink\" title=\"1) Pointwise Error Measure\"></a>1) Pointwise Error Measure</h3><p>我们用每个点的误差衡量来衡量整体误差，用 $err()$ 表示。<br>对应 $E_{in}(g), E_{out}(g)$可以用下面公式（3）和（4）表示。</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(g) = \\frac{1}{N} \\cdot \\sum\\limits_{n=1}^N err(g(x_n), f(x_n))\n\\tag{$3$}</script><script type=\"math/tex; mode=display\">\nE_{out}(g) = \\epsilon \\cdot err(g(x), f(x))\n\\tag{$4$}</script><h3 id=\"2-Two-Important-Pointwise-Error-Measures\"><a href=\"#2-Two-Important-Pointwise-Error-Measures\" class=\"headerlink\" title=\"2) Two Important Pointwise Error Measures\"></a>2) Two Important Pointwise Error Measures</h3><p>我们用0/1错误来衡量分类问题，用平方错误来衡量回归问题。其数学表达式，如公式（5）（6）所示</p>\n<script type=\"math/tex; mode=display\">\nerr( \\tilde{y}, y) = \\left[\\left[ \\tilde{y} \\neq y \\right]\\right]\n\\tag{$5$}</script><script type=\"math/tex; mode=display\">\nerr( \\tilde{y}, y) = \\left( \\tilde{y} - y \\right)^2\n\\tag{$6$}</script><h3 id=\"3-Choice-of-Error-Measures\"><a href=\"#3-Choice-of-Error-Measures\" class=\"headerlink\" title=\"3) Choice of Error Measures\"></a>3) Choice of Error Measures</h3><p>对于二元分类问题错误的类型也分为两类，如图二所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/82fc93d617c6aec7addbbc0bcff9207f127e42f9/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-2%20Error.png\" alt=\"Error Types of Binary Classification\"></p>\n<p><center>图二 Error Types of Binary Classification<sup>[2]</sup></center><br><br></p>\n<p>在目标函数f为+1时，假设函数g却给出了-1，这种错误叫做错误的拒绝（false reject），另一种是在目标函数f为-1时，假设函数g却给出了+1，这种错误叫做错误的接受（false accept）。</p>\n<p>然后在不同的应用场合下，如果我们要给错误加上权重，那么这个权重会不一样。比如说：</p>\n<blockquote>\n<ol>\n<li>超市指纹识别的例子</li>\n</ol>\n</blockquote>\n<p>如果在超市中通过指纹识别来进行打折活动，如果是vip用户，之前有指纹录入的话，就应该有优惠活动，否则没有。<br>如果发生false reject的情况，那么顾客可能会不高兴，这样就会损失了一部分未来的生意；而如果发生false accept的话，超市只不过损失了一点小钱。<br>所以对于超市的成本表如图三所示，false reject会牺牲成本比较大，而false accept牺牲的成本会较小。所以，我们应该尽量避免false reject的情形。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-3%20example-supermarket.png\" alt=\"Finger Verification for Supermarket\"></p>\n<p><center>图三 Finger Verification for Supermarket<sup>[3]</sup></center><br><br></p>\n<blockquote>\n<ol>\n<li>CIA指纹识别的例子</li>\n</ol>\n</blockquote>\n<p>如果美国中情局，用指纹识别来判断该人是否有权限进入系统查看重要资料。<br>那么，发生false accept的情况会导致很严重的后果，而false reject的话，就不会有太大的影响。<br>所以对于CIA的成本表如图四所示，应该尽量避免false accept的情形。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/055e02432ef3bf9402663249ae71198c78ecca15/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter6-4%20example-cia.png\" alt=\"Finger Verification for CIA\"></p>\n<p><center>图四 Finger Verification for CIA<sup>[3]</sup></center><br><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Noise，并且讨论了Noise对我们的VC Bound不会产生影响，即Noise不影响机器学习的可行性。</li>\n<li>然后介绍了Error，然后讨论了0/1错误来衡量二元分类问题，以及用平方错误来衡量回归问题。</li>\n<li>最后讨论了不同应用场景下的Error应该加上不同的权重，比如超市和CIA的指纹识别系统的侧重点不同。</li>\n</ol>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1]机器学习基石(台湾大学-林轩田)\\8\\8 - 1 - Noise and Probabilistic Target (17-01)</p>\n<p>[2]机器学习基石(台湾大学-林轩田)\\8\\8 - 2 - Error Measure (15-10)</p>\n<p>[3]机器学习基石(台湾大学-林轩田)\\8\\8 - 3 - Algorithmic Error Measure (13-46)</p>\n<p><br></p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"7.How can Machine Learn? - Linear Regression","date":"2017-10-11T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# How can Machine Learn? - Linear Regression\n\n\n## 1. What is Regression\n\n\n机器学习算法一般是这样一个步骤：\n\n1. 对于一个问题，用数学语言来描述它，然后建立模型，e.g., 回归模型或者分类模型；\n\n2. 建立代价函数: Cost Function, 用最大似然、最大后验概率或者最小化分类误差等等数，也就是一个最优化问题。找到最优化问题的解，也就是能拟合我们的数据的最好的模型参数；\n\n3. 求解这个代价函数，找到最优解。求解也就分很多种情况了：\n\n   1). 如果这个优化函数存在解析解。例如我们求最值一般是对代价函数求导，找到导数为0的点，也就是最大值或者最小值的地方了。如果代价函数能简单求导，并且求导后为0的式子存在解析解，那么我们就可以直接得到最优的参数了: Gradient Descent。\n\n   2). 如果式子很难求导，例如函数里面存在隐含的变量或者变量相互间存在耦合，也就互相依赖的情况。或者求导后式子得不到解释解，例如未知参数的个数大于已知方程组的个数等。这时候我们就需要借助迭代算法来一步一步找到最有解了。\n\n   3). 另外需要考虑的情况是，如果代价函数是凸函数，那么就存在全局最优解。\n\n\n回归(Regression)问题与分类(Classification)问题类似，关键的区别在于，Regression的输出是实数,是一个范围，所以不能提前确定所有输出值；而Classification的输出是确定的值。换个角度说，假如输出足够多的数据的时候：如果输出的值是连续的，这个问题叫做Regression，而如果输出的值是离散的，那么这个问题叫做Classification\n\n\n用数学符号表示如果公式（1）所示。\n\n$$\n\\begin{align}\nRegression : &f(x) = \\left[ value1, value2 \\right]  \\\\\nClassification: &f(x) = \\{ value_1, value_2, ..., value_n \\}\n\\end{align}\n\\tag{$1$}\n$$\n\n<br><br>\n----------------------------------\n\n## 2. Linear Regression\n### 1) Introduction of Linear Regression\n线性回归问题同样的表示各个属性（Attribution）对最终结果的贡献：也就是说每个属性乘以对应的权值，最后再加上一定的偏移，如公式（2）所示\n\n$$\ny = w_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n\n\\tag{$2$}\n$$\n\n如果给第一项的偏移 $w_0$ 加上属性值 $x_0$，并把单独的输出点$y$用向量进行表示，那么公式（2）就变成了公式（3）（这一步纯粹是为了表示方便）。\n\nHypothesis h(x):\n$$\n\\begin{align}\nh(x) &= w_0 \\cdot x_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n  \\quad(x_0 = 1) \\\\\n     &= w^T \\cdot x_i \\\\\n     &= W^T \\cdot X\n\\end{align}\n\\tag{$3$}\n$$\n从公式(3)的可以看出，与二元分类假设函数的表示只差了一个取正负号的函数 $sign()$。\n\n\n### 2) Error Measurement of Linear Regression\n线性回归问题的错误如图一所示。\n![Error Measurement](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/de4c8798497f08b40cbe86cf0cc665ceaa6d54ff/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-1%20Linear%20Regression.png)\n<center> 图一 Error Measurement <sup>[1]</sup></center>\n\n\n上一章中，提到了回归问题我们用平方误差来表示（其实还有RMSE， R2等方法，老师上课只讲了平方误差，为了说明方便，我们只写这个）\n根据图一的信息，很明显得到公式（4）（5）。\n\n$$\nE_{in}(w)) = \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$4$}\n$$\n\n$$\nE_{out}(w)) = \\epsilon \\cdot \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$5$}\n$$\nVC Bound可以约束各种情况的学习模型，当然回归类型的模型也被也受此约束，只需要寻找足够小 $E_{in}(w)$ 便可以满足 $E_{out}(w)$ 小的需求。\n\n\n\n### 3) Linear Regression Algorithm\n刚刚上面的Error Meansurement中，我们提到了VC Bound中，在训练样本足够的情况下，我们要用特定的算法，来找到最小的 $E_{in}(w)$，所以把上面公式（4）的pointwise error measurement 通过矩阵做调整得到公式（6）。\n\n$$\n\\begin{align}\nE_{in}(w)) &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2 \\\\\n           &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(x_n^Tw - y_n)^2   \\quad\\quad (向量内积，符合交换率) \\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                x_1^Tw - y_1 & \\\\\n                x_2^Tw - y_2 & \\\\\n                ...            \\\\\n                x_N^Tw - y_N &\n           \\end{array}\n           \\right|\n           \\right|^2               \\quad\\quad(平方求和)\\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{bmatrix}\n                -x_1^T-\\\\\n                -x_1^T-\\\\\n                ...    \\\\\n                -x_1^T-\\\\\n           \\end{bmatrix}\n           \\cdot w\n           \\begin{bmatrix}\n                y_1\\\\\n                y_2\\\\\n                ...\\\\\n                y_n\\\\\n           \\end{bmatrix}\n           \\right|\n           \\right|^2                \\quad\\quad(矩阵平方)\\\\\n\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                \\underbrace{X^T}_{N \\times (d+1)}\n                \\underbrace{w}_{(d+1)\\times 1}\n                -\n                \\underbrace{y}_{N \\times 1}\n           \\end{array}\n           \\right|\n           \\right|^2 \\\\\n\\end{align}\n\\tag{$6$}\n$$\n\n根据公式（6），那么 $E_{in}(w)$的最小值如公式（7）所示。\n\n$$\nmin_w E_{in}(w) = min_w \\frac{1}{N} \\left|\\left| X^Tw - y \\right|\\right|^2\n\\tag{$7$}\n$$\n\n$E_{in}(w)$的变化图如图二所示，可以看出这是一个连续（continuous）、可微（differentiable）的凸（convex）函数。最小值就是山谷的点（即转折点），并且对这个点求导的值为0。\n\n![Ein Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/edb6705ac1e3e9565cb69b9b170c1de25f86f987/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-2%20Linear%20Regression%20Ein.png)\n\n<center> 图二 Ein Curve <sup>[1]</sup></center>\n\n所以接下来，我们需要对$E_{in}(w)$求导并且找到一个值 $W_{LIN}$，使得 $\\nabla E_{in}(w)$ 的值为0。\n1. 首先我们需要考虑两种情况：①只有一个w； ②w为向量\n2. 首先我们把公式（6）平方去掉\n3. 只有一个w的时候，就按照正常的求导方式求导即可，得到公式（7）\n4. 当w为向量的时候，我们需要对其中一个进行转置，然后再求导，得到公式（8）\n5. 根据公式（7）（8）可以看出，两种情况的求导的结果非常相似，可以用公式（9）表示\n6. 最后我们令公式（9）的值为0，得到我们需要的 $W_{LIN}$ 如公式（10）所示,其中 $X^\\dagger$ 叫做[矩阵X的伪逆矩阵（pseudo-inverse）](http://blog.sina.com.cn/s/blog_890c6aa30101cn6t.html)\n\n$$\n\\begin{align}\none \\quad w : E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^2 - 2 \\cdot X^T yw  + y^2 \\right) \\\\\n       \\nabla E_{in}(w) &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$7$}\n$$\n\n$$\n\\begin{align}\nvector \\quad w :  E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^T w - 2 \\cdot X^T y w^T  + y^2 \\right) \\\\\n          \\nabla E_{in}(w)  &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$8$}\n$$\n\n$$\n\\nabla E_{in}(w)  = \\frac{2}{N} \\left( (X^T)X w - X^T y \\right)\n\\tag{$9$}\n$$\n\n$$\n\\begin{align}\nW_{LIN} &= \\underbrace{(X^T X) ^ {-1} X^T }_{X^\\dagger} y \\\\\n        &= \\underbrace{X ^\\dagger }_{(d+1)\\times N)}\n           \\underbrace{y}_{N \\times 1}\n\\end{align}\n\\tag{$10$}\n$$\n\n### 4) Generalization Issue\n上一节中，我们得到了最佳的 w 的解，但是，哪个是最小的 $E_{in}$， 实际上我们最需要的是使得 $E_{out}$最小，而我们这一节就是要讨论之前关于VC Bound保证了 $E_{in} \\approx E_{out}$ 是否依然适用于线性回归问题。（中间解释过程较复杂，后续补充。）\n\n结论就是得到了 $E_{in} E_{out}$关于 noise level的方程，如公式（11）（12），曲线图如图三所示。\n\n$$\nE_{in}(w)  = noise \\quad level  \\cdot (1- \\frac{d+1}{N})\n\\tag{$11$}\n$$\n\n$$\nE_{out}(w)  = noise \\quad level  \\cdot (1+ \\frac{d+1}{N})\n\\tag{$12$}\n$$\n\n![Ein Eout Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/01235bfa1a94084fee01577e205a27839be75228/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-3%20Ein%20Eout.png)\n<center> 图三 Ein Eout Curve<sup>[2]</sup></center>\n\n\n可以看出在N趋于无穷大时，与两者都会趋近于noise level的值，即 $\\sigma^2$ 泛化错误之间的差距：$\\frac{2(d+1)}{N}$ 。\n\n至此可以表明在线性回归中可以寻找到很好的 $E_{out}$，因此线性回归可以学习。\n\n\n\n\n\n### 5) Linear Regression for Binary Classification\n这一节，我们主要讨论能否通过求解线性回归的方式求二元分类问题\n\n首先对比Linear Classification 和 Linear Regression， 如图四\n\n![Linear Classification and Linear Regression](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d4a67d82122ef663fb09d41c3b1862d897536e2a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-4%20Linear%20Regression%20for%20Binary%20Classification.png)\n<center> 图四 Linear Classification and Linear Regression<sup>[3]</sup></center>\n<br>\n\n从求解问题的难度考虑，二元分类的求解是一个NP难问题，只能近似求解，而线性回归求解方便，程序编写也简单。\n\n直觉告诉我们:因为二元分类的输出空间{-1，+1}属于线性回归的输出空间，即 $\\{-1, +1\\}∈ R$。其中数据集的标记大于零的表示+1，小于零的表示-1，通过线性回归求得的解析解 $W_{LIN}$，直接得出最优假设 $g(x) = sign( W_{LIN} x)$ 。\n\n下面给出证明：\n> 入手点：误差大小\n\n首先对比两种方法的曲线图，如图五所示。\n![Relations of Two Errors](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/341baa79de829072a35424870d65421a0bc9f9ba/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-5%20Relation%20of%20Two%20Errors.png)\n<center> 图五 Relations of Two Errors<sup>[3]</sup></center>\n<br>\n\n可以发现，无论期望的y为-1还是+1， $err_{sqr}$ 始终大于 $err_{0/1}$，即公式（13），加上我们之前有的 $E_{out} \\approx E_{in}$，那么我们可以得到公式（14）。\n\n\n$$\nerr_{0/1} \\leq err_{sqr}\n\\tag{$13$}\n$$\n\n\n$$\n\\begin{align}\nClassification \\quad E_{out}(w)\n&\\leq Classification \\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)} \\\\\n&\\leq Regression \\quad\\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)}\n\\end{align}\n\\tag{$14$}\n$$\n\n\n所以我们可以通过使用 Linear Regression 的方法来求解Linear Classification的问题，虽然通过这种方法，得到的误差可能更大，但却是一种更有效率的求解方式。在实际运用中，一般都将通过线性回归求得的解析解作为PLA或者pocket的初始值，达到快速求解的目的 。\n<br><br>\n----------------------------------\n\n\n# Summary\n1. 首先介绍了Regression。\n2. 然后通过例子引入Linear Regression，分别介绍Linear Regression的误差方程，算法流程。\n3. 接着我们引入VC Bound 解释了Linear Regression为什么可以实现学习。\n4. 最后我们应用Linear Regression的算法到Classification的问题中：虽然会损失一定的准确度，但是效率提升很大。\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\9\\9 - 1 - Linear Regression Problem (10-08)\n\n[2] 机器学习基石(台湾大学-林轩田)\\9\\9 - 3 - Generalization Issue (20-34)\n\n[3] 机器学习基石(台湾大学-林轩田)\\9\\9 - 4 - Linear Regression for Binary Classification (11-23)\n\n\n<br>\n<br>\n---------------------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-11-7.How can Machine Learn - Linear Regression.md","raw":"---\ntitle: 7.How can Machine Learn? - Linear Regression\ndate: 2017-10-11 12:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# How can Machine Learn? - Linear Regression\n\n\n## 1. What is Regression\n\n\n机器学习算法一般是这样一个步骤：\n\n1. 对于一个问题，用数学语言来描述它，然后建立模型，e.g., 回归模型或者分类模型；\n\n2. 建立代价函数: Cost Function, 用最大似然、最大后验概率或者最小化分类误差等等数，也就是一个最优化问题。找到最优化问题的解，也就是能拟合我们的数据的最好的模型参数；\n\n3. 求解这个代价函数，找到最优解。求解也就分很多种情况了：\n\n   1). 如果这个优化函数存在解析解。例如我们求最值一般是对代价函数求导，找到导数为0的点，也就是最大值或者最小值的地方了。如果代价函数能简单求导，并且求导后为0的式子存在解析解，那么我们就可以直接得到最优的参数了: Gradient Descent。\n\n   2). 如果式子很难求导，例如函数里面存在隐含的变量或者变量相互间存在耦合，也就互相依赖的情况。或者求导后式子得不到解释解，例如未知参数的个数大于已知方程组的个数等。这时候我们就需要借助迭代算法来一步一步找到最有解了。\n\n   3). 另外需要考虑的情况是，如果代价函数是凸函数，那么就存在全局最优解。\n\n\n回归(Regression)问题与分类(Classification)问题类似，关键的区别在于，Regression的输出是实数,是一个范围，所以不能提前确定所有输出值；而Classification的输出是确定的值。换个角度说，假如输出足够多的数据的时候：如果输出的值是连续的，这个问题叫做Regression，而如果输出的值是离散的，那么这个问题叫做Classification\n\n\n用数学符号表示如果公式（1）所示。\n\n$$\n\\begin{align}\nRegression : &f(x) = \\left[ value1, value2 \\right]  \\\\\nClassification: &f(x) = \\{ value_1, value_2, ..., value_n \\}\n\\end{align}\n\\tag{$1$}\n$$\n\n<br><br>\n----------------------------------\n\n## 2. Linear Regression\n### 1) Introduction of Linear Regression\n线性回归问题同样的表示各个属性（Attribution）对最终结果的贡献：也就是说每个属性乘以对应的权值，最后再加上一定的偏移，如公式（2）所示\n\n$$\ny = w_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n\n\\tag{$2$}\n$$\n\n如果给第一项的偏移 $w_0$ 加上属性值 $x_0$，并把单独的输出点$y$用向量进行表示，那么公式（2）就变成了公式（3）（这一步纯粹是为了表示方便）。\n\nHypothesis h(x):\n$$\n\\begin{align}\nh(x) &= w_0 \\cdot x_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n  \\quad(x_0 = 1) \\\\\n     &= w^T \\cdot x_i \\\\\n     &= W^T \\cdot X\n\\end{align}\n\\tag{$3$}\n$$\n从公式(3)的可以看出，与二元分类假设函数的表示只差了一个取正负号的函数 $sign()$。\n\n\n### 2) Error Measurement of Linear Regression\n线性回归问题的错误如图一所示。\n![Error Measurement](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/de4c8798497f08b40cbe86cf0cc665ceaa6d54ff/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-1%20Linear%20Regression.png)\n<center> 图一 Error Measurement <sup>[1]</sup></center>\n\n\n上一章中，提到了回归问题我们用平方误差来表示（其实还有RMSE， R2等方法，老师上课只讲了平方误差，为了说明方便，我们只写这个）\n根据图一的信息，很明显得到公式（4）（5）。\n\n$$\nE_{in}(w)) = \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$4$}\n$$\n\n$$\nE_{out}(w)) = \\epsilon \\cdot \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$5$}\n$$\nVC Bound可以约束各种情况的学习模型，当然回归类型的模型也被也受此约束，只需要寻找足够小 $E_{in}(w)$ 便可以满足 $E_{out}(w)$ 小的需求。\n\n\n\n### 3) Linear Regression Algorithm\n刚刚上面的Error Meansurement中，我们提到了VC Bound中，在训练样本足够的情况下，我们要用特定的算法，来找到最小的 $E_{in}(w)$，所以把上面公式（4）的pointwise error measurement 通过矩阵做调整得到公式（6）。\n\n$$\n\\begin{align}\nE_{in}(w)) &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2 \\\\\n           &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(x_n^Tw - y_n)^2   \\quad\\quad (向量内积，符合交换率) \\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                x_1^Tw - y_1 & \\\\\n                x_2^Tw - y_2 & \\\\\n                ...            \\\\\n                x_N^Tw - y_N &\n           \\end{array}\n           \\right|\n           \\right|^2               \\quad\\quad(平方求和)\\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{bmatrix}\n                -x_1^T-\\\\\n                -x_1^T-\\\\\n                ...    \\\\\n                -x_1^T-\\\\\n           \\end{bmatrix}\n           \\cdot w\n           \\begin{bmatrix}\n                y_1\\\\\n                y_2\\\\\n                ...\\\\\n                y_n\\\\\n           \\end{bmatrix}\n           \\right|\n           \\right|^2                \\quad\\quad(矩阵平方)\\\\\n\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                \\underbrace{X^T}_{N \\times (d+1)}\n                \\underbrace{w}_{(d+1)\\times 1}\n                -\n                \\underbrace{y}_{N \\times 1}\n           \\end{array}\n           \\right|\n           \\right|^2 \\\\\n\\end{align}\n\\tag{$6$}\n$$\n\n根据公式（6），那么 $E_{in}(w)$的最小值如公式（7）所示。\n\n$$\nmin_w E_{in}(w) = min_w \\frac{1}{N} \\left|\\left| X^Tw - y \\right|\\right|^2\n\\tag{$7$}\n$$\n\n$E_{in}(w)$的变化图如图二所示，可以看出这是一个连续（continuous）、可微（differentiable）的凸（convex）函数。最小值就是山谷的点（即转折点），并且对这个点求导的值为0。\n\n![Ein Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/edb6705ac1e3e9565cb69b9b170c1de25f86f987/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-2%20Linear%20Regression%20Ein.png)\n\n<center> 图二 Ein Curve <sup>[1]</sup></center>\n\n所以接下来，我们需要对$E_{in}(w)$求导并且找到一个值 $W_{LIN}$，使得 $\\nabla E_{in}(w)$ 的值为0。\n1. 首先我们需要考虑两种情况：①只有一个w； ②w为向量\n2. 首先我们把公式（6）平方去掉\n3. 只有一个w的时候，就按照正常的求导方式求导即可，得到公式（7）\n4. 当w为向量的时候，我们需要对其中一个进行转置，然后再求导，得到公式（8）\n5. 根据公式（7）（8）可以看出，两种情况的求导的结果非常相似，可以用公式（9）表示\n6. 最后我们令公式（9）的值为0，得到我们需要的 $W_{LIN}$ 如公式（10）所示,其中 $X^\\dagger$ 叫做[矩阵X的伪逆矩阵（pseudo-inverse）](http://blog.sina.com.cn/s/blog_890c6aa30101cn6t.html)\n\n$$\n\\begin{align}\none \\quad w : E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^2 - 2 \\cdot X^T yw  + y^2 \\right) \\\\\n       \\nabla E_{in}(w) &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$7$}\n$$\n\n$$\n\\begin{align}\nvector \\quad w :  E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^T w - 2 \\cdot X^T y w^T  + y^2 \\right) \\\\\n          \\nabla E_{in}(w)  &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$8$}\n$$\n\n$$\n\\nabla E_{in}(w)  = \\frac{2}{N} \\left( (X^T)X w - X^T y \\right)\n\\tag{$9$}\n$$\n\n$$\n\\begin{align}\nW_{LIN} &= \\underbrace{(X^T X) ^ {-1} X^T }_{X^\\dagger} y \\\\\n        &= \\underbrace{X ^\\dagger }_{(d+1)\\times N)}\n           \\underbrace{y}_{N \\times 1}\n\\end{align}\n\\tag{$10$}\n$$\n\n### 4) Generalization Issue\n上一节中，我们得到了最佳的 w 的解，但是，哪个是最小的 $E_{in}$， 实际上我们最需要的是使得 $E_{out}$最小，而我们这一节就是要讨论之前关于VC Bound保证了 $E_{in} \\approx E_{out}$ 是否依然适用于线性回归问题。（中间解释过程较复杂，后续补充。）\n\n结论就是得到了 $E_{in} E_{out}$关于 noise level的方程，如公式（11）（12），曲线图如图三所示。\n\n$$\nE_{in}(w)  = noise \\quad level  \\cdot (1- \\frac{d+1}{N})\n\\tag{$11$}\n$$\n\n$$\nE_{out}(w)  = noise \\quad level  \\cdot (1+ \\frac{d+1}{N})\n\\tag{$12$}\n$$\n\n![Ein Eout Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/01235bfa1a94084fee01577e205a27839be75228/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-3%20Ein%20Eout.png)\n<center> 图三 Ein Eout Curve<sup>[2]</sup></center>\n\n\n可以看出在N趋于无穷大时，与两者都会趋近于noise level的值，即 $\\sigma^2$ 泛化错误之间的差距：$\\frac{2(d+1)}{N}$ 。\n\n至此可以表明在线性回归中可以寻找到很好的 $E_{out}$，因此线性回归可以学习。\n\n\n\n\n\n### 5) Linear Regression for Binary Classification\n这一节，我们主要讨论能否通过求解线性回归的方式求二元分类问题\n\n首先对比Linear Classification 和 Linear Regression， 如图四\n\n![Linear Classification and Linear Regression](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d4a67d82122ef663fb09d41c3b1862d897536e2a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-4%20Linear%20Regression%20for%20Binary%20Classification.png)\n<center> 图四 Linear Classification and Linear Regression<sup>[3]</sup></center>\n<br>\n\n从求解问题的难度考虑，二元分类的求解是一个NP难问题，只能近似求解，而线性回归求解方便，程序编写也简单。\n\n直觉告诉我们:因为二元分类的输出空间{-1，+1}属于线性回归的输出空间，即 $\\{-1, +1\\}∈ R$。其中数据集的标记大于零的表示+1，小于零的表示-1，通过线性回归求得的解析解 $W_{LIN}$，直接得出最优假设 $g(x) = sign( W_{LIN} x)$ 。\n\n下面给出证明：\n> 入手点：误差大小\n\n首先对比两种方法的曲线图，如图五所示。\n![Relations of Two Errors](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/341baa79de829072a35424870d65421a0bc9f9ba/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-5%20Relation%20of%20Two%20Errors.png)\n<center> 图五 Relations of Two Errors<sup>[3]</sup></center>\n<br>\n\n可以发现，无论期望的y为-1还是+1， $err_{sqr}$ 始终大于 $err_{0/1}$，即公式（13），加上我们之前有的 $E_{out} \\approx E_{in}$，那么我们可以得到公式（14）。\n\n\n$$\nerr_{0/1} \\leq err_{sqr}\n\\tag{$13$}\n$$\n\n\n$$\n\\begin{align}\nClassification \\quad E_{out}(w)\n&\\leq Classification \\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)} \\\\\n&\\leq Regression \\quad\\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)}\n\\end{align}\n\\tag{$14$}\n$$\n\n\n所以我们可以通过使用 Linear Regression 的方法来求解Linear Classification的问题，虽然通过这种方法，得到的误差可能更大，但却是一种更有效率的求解方式。在实际运用中，一般都将通过线性回归求得的解析解作为PLA或者pocket的初始值，达到快速求解的目的 。\n<br><br>\n----------------------------------\n\n\n# Summary\n1. 首先介绍了Regression。\n2. 然后通过例子引入Linear Regression，分别介绍Linear Regression的误差方程，算法流程。\n3. 接着我们引入VC Bound 解释了Linear Regression为什么可以实现学习。\n4. 最后我们应用Linear Regression的算法到Classification的问题中：虽然会损失一定的准确度，但是效率提升很大。\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\9\\9 - 1 - Linear Regression Problem (10-08)\n\n[2] 机器学习基石(台湾大学-林轩田)\\9\\9 - 3 - Generalization Issue (20-34)\n\n[3] 机器学习基石(台湾大学-林轩田)\\9\\9 - 4 - Linear Regression for Binary Classification (11-23)\n\n\n<br>\n<br>\n---------------------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-11-7.How can Machine Learn - Linear Regression","published":1,"updated":"2018-10-27T04:30:42.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bp001pe0ow87oyxsty","content":"<h1 id=\"How-can-Machine-Learn-Linear-Regression\"><a href=\"#How-can-Machine-Learn-Linear-Regression\" class=\"headerlink\" title=\"How can Machine Learn? - Linear Regression\"></a>How can Machine Learn? - Linear Regression</h1><h2 id=\"1-What-is-Regression\"><a href=\"#1-What-is-Regression\" class=\"headerlink\" title=\"1. What is Regression\"></a>1. What is Regression</h2><p>机器学习算法一般是这样一个步骤：</p>\n<ol>\n<li><p>对于一个问题，用数学语言来描述它，然后建立模型，e.g., 回归模型或者分类模型；</p>\n</li>\n<li><p>建立代价函数: Cost Function, 用最大似然、最大后验概率或者最小化分类误差等等数，也就是一个最优化问题。找到最优化问题的解，也就是能拟合我们的数据的最好的模型参数；</p>\n</li>\n<li><p>求解这个代价函数，找到最优解。求解也就分很多种情况了：</p>\n<p>1). 如果这个优化函数存在解析解。例如我们求最值一般是对代价函数求导，找到导数为0的点，也就是最大值或者最小值的地方了。如果代价函数能简单求导，并且求导后为0的式子存在解析解，那么我们就可以直接得到最优的参数了: Gradient Descent。</p>\n<p>2). 如果式子很难求导，例如函数里面存在隐含的变量或者变量相互间存在耦合，也就互相依赖的情况。或者求导后式子得不到解释解，例如未知参数的个数大于已知方程组的个数等。这时候我们就需要借助迭代算法来一步一步找到最有解了。</p>\n<p>3). 另外需要考虑的情况是，如果代价函数是凸函数，那么就存在全局最优解。</p>\n</li>\n</ol>\n<p>回归(Regression)问题与分类(Classification)问题类似，关键的区别在于，Regression的输出是实数,是一个范围，所以不能提前确定所有输出值；而Classification的输出是确定的值。换个角度说，假如输出足够多的数据的时候：如果输出的值是连续的，这个问题叫做Regression，而如果输出的值是离散的，那么这个问题叫做Classification</p>\n<p>用数学符号表示如果公式（1）所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nRegression : &f(x) = \\left[ value1, value2 \\right]  \\\\\nClassification: &f(x) = \\{ value_1, value_2, ..., value_n \\}\n\\end{align}\n\\tag{$1$}</script><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Linear-Regression\"><a href=\"#2-Linear-Regression\" class=\"headerlink\" title=\"2. Linear Regression\"></a>2. Linear Regression</h2><h3 id=\"1-Introduction-of-Linear-Regression\"><a href=\"#1-Introduction-of-Linear-Regression\" class=\"headerlink\" title=\"1) Introduction of Linear Regression\"></a>1) Introduction of Linear Regression</h3><p>线性回归问题同样的表示各个属性（Attribution）对最终结果的贡献：也就是说每个属性乘以对应的权值，最后再加上一定的偏移，如公式（2）所示</p>\n<script type=\"math/tex; mode=display\">\ny = w_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n\n\\tag{$2$}</script><p>如果给第一项的偏移 $w_0$ 加上属性值 $x_0$，并把单独的输出点$y$用向量进行表示，那么公式（2）就变成了公式（3）（这一步纯粹是为了表示方便）。</p>\n<p>Hypothesis h(x):</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh(x) &= w_0 \\cdot x_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n  \\quad(x_0 = 1) \\\\\n     &= w^T \\cdot x_i \\\\\n     &= W^T \\cdot X\n\\end{align}\n\\tag{$3$}</script><p>从公式(3)的可以看出，与二元分类假设函数的表示只差了一个取正负号的函数 $sign()$。</p>\n<h3 id=\"2-Error-Measurement-of-Linear-Regression\"><a href=\"#2-Error-Measurement-of-Linear-Regression\" class=\"headerlink\" title=\"2) Error Measurement of Linear Regression\"></a>2) Error Measurement of Linear Regression</h3><p>线性回归问题的错误如图一所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/de4c8798497f08b40cbe86cf0cc665ceaa6d54ff/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-1%20Linear%20Regression.png\" alt=\"Error Measurement\"></p>\n<center> 图一 Error Measurement <sup>[1]</sup></center>\n\n\n<p>上一章中，提到了回归问题我们用平方误差来表示（其实还有RMSE， R2等方法，老师上课只讲了平方误差，为了说明方便，我们只写这个）<br>根据图一的信息，很明显得到公式（4）（5）。</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(w)) = \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\nE_{out}(w)) = \\epsilon \\cdot \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$5$}</script><p>VC Bound可以约束各种情况的学习模型，当然回归类型的模型也被也受此约束，只需要寻找足够小 $E_{in}(w)$ 便可以满足 $E_{out}(w)$ 小的需求。</p>\n<h3 id=\"3-Linear-Regression-Algorithm\"><a href=\"#3-Linear-Regression-Algorithm\" class=\"headerlink\" title=\"3) Linear Regression Algorithm\"></a>3) Linear Regression Algorithm</h3><p>刚刚上面的Error Meansurement中，我们提到了VC Bound中，在训练样本足够的情况下，我们要用特定的算法，来找到最小的 $E_{in}(w)$，所以把上面公式（4）的pointwise error measurement 通过矩阵做调整得到公式（6）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nE_{in}(w)) &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2 \\\\\n           &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(x_n^Tw - y_n)^2   \\quad\\quad (向量内积，符合交换率) \\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                x_1^Tw - y_1 & \\\\\n                x_2^Tw - y_2 & \\\\\n                ...            \\\\\n                x_N^Tw - y_N &\n           \\end{array}\n           \\right|\n           \\right|^2               \\quad\\quad(平方求和)\\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{bmatrix}\n                -x_1^T-\\\\\n                -x_1^T-\\\\\n                ...    \\\\\n                -x_1^T-\\\\\n           \\end{bmatrix}\n           \\cdot w\n           \\begin{bmatrix}\n                y_1\\\\\n                y_2\\\\\n                ...\\\\\n                y_n\\\\\n           \\end{bmatrix}\n           \\right|\n           \\right|^2                \\quad\\quad(矩阵平方)\\\\\n\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                \\underbrace{X^T}_{N \\times (d+1)}\n                \\underbrace{w}_{(d+1)\\times 1}\n                -\n                \\underbrace{y}_{N \\times 1}\n           \\end{array}\n           \\right|\n           \\right|^2 \\\\\n\\end{align}\n\\tag{$6$}</script><p>根据公式（6），那么 $E_{in}(w)$的最小值如公式（7）所示。</p>\n<script type=\"math/tex; mode=display\">\nmin_w E_{in}(w) = min_w \\frac{1}{N} \\left|\\left| X^Tw - y \\right|\\right|^2\n\\tag{$7$}</script><p>$E_{in}(w)$的变化图如图二所示，可以看出这是一个连续（continuous）、可微（differentiable）的凸（convex）函数。最小值就是山谷的点（即转折点），并且对这个点求导的值为0。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/edb6705ac1e3e9565cb69b9b170c1de25f86f987/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-2%20Linear%20Regression%20Ein.png\" alt=\"Ein Curve\"></p>\n<center> 图二 Ein Curve <sup>[1]</sup></center>\n\n<p>所以接下来，我们需要对$E_{in}(w)$求导并且找到一个值 $W_{LIN}$，使得 $\\nabla E_{in}(w)$ 的值为0。</p>\n<ol>\n<li>首先我们需要考虑两种情况：①只有一个w； ②w为向量</li>\n<li>首先我们把公式（6）平方去掉</li>\n<li>只有一个w的时候，就按照正常的求导方式求导即可，得到公式（7）</li>\n<li>当w为向量的时候，我们需要对其中一个进行转置，然后再求导，得到公式（8）</li>\n<li>根据公式（7）（8）可以看出，两种情况的求导的结果非常相似，可以用公式（9）表示</li>\n<li>最后我们令公式（9）的值为0，得到我们需要的 $W_{LIN}$ 如公式（10）所示,其中 $X^\\dagger$ 叫做<a href=\"http://blog.sina.com.cn/s/blog_890c6aa30101cn6t.html\" target=\"_blank\" rel=\"external\">矩阵X的伪逆矩阵（pseudo-inverse）</a></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\none \\quad w : E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^2 - 2 \\cdot X^T yw  + y^2 \\right) \\\\\n       \\nabla E_{in}(w) &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$7$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nvector \\quad w :  E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^T w - 2 \\cdot X^T y w^T  + y^2 \\right) \\\\\n          \\nabla E_{in}(w)  &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$8$}</script><script type=\"math/tex; mode=display\">\n\\nabla E_{in}(w)  = \\frac{2}{N} \\left( (X^T)X w - X^T y \\right)\n\\tag{$9$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nW_{LIN} &= \\underbrace{(X^T X) ^ {-1} X^T }_{X^\\dagger} y \\\\\n        &= \\underbrace{X ^\\dagger }_{(d+1)\\times N)}\n           \\underbrace{y}_{N \\times 1}\n\\end{align}\n\\tag{$10$}</script><h3 id=\"4-Generalization-Issue\"><a href=\"#4-Generalization-Issue\" class=\"headerlink\" title=\"4) Generalization Issue\"></a>4) Generalization Issue</h3><p>上一节中，我们得到了最佳的 w 的解，但是，哪个是最小的 $E_{in}$， 实际上我们最需要的是使得 $E_{out}$最小，而我们这一节就是要讨论之前关于VC Bound保证了 $E_{in} \\approx E_{out}$ 是否依然适用于线性回归问题。（中间解释过程较复杂，后续补充。）</p>\n<p>结论就是得到了 $E_{in} E_{out}$关于 noise level的方程，如公式（11）（12），曲线图如图三所示。</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(w)  = noise \\quad level  \\cdot (1- \\frac{d+1}{N})\n\\tag{$11$}</script><script type=\"math/tex; mode=display\">\nE_{out}(w)  = noise \\quad level  \\cdot (1+ \\frac{d+1}{N})\n\\tag{$12$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/01235bfa1a94084fee01577e205a27839be75228/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-3%20Ein%20Eout.png\" alt=\"Ein Eout Curve\"></p>\n<center> 图三 Ein Eout Curve<sup>[2]</sup></center>\n\n\n<p>可以看出在N趋于无穷大时，与两者都会趋近于noise level的值，即 $\\sigma^2$ 泛化错误之间的差距：$\\frac{2(d+1)}{N}$ 。</p>\n<p>至此可以表明在线性回归中可以寻找到很好的 $E_{out}$，因此线性回归可以学习。</p>\n<h3 id=\"5-Linear-Regression-for-Binary-Classification\"><a href=\"#5-Linear-Regression-for-Binary-Classification\" class=\"headerlink\" title=\"5) Linear Regression for Binary Classification\"></a>5) Linear Regression for Binary Classification</h3><p>这一节，我们主要讨论能否通过求解线性回归的方式求二元分类问题</p>\n<p>首先对比Linear Classification 和 Linear Regression， 如图四</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d4a67d82122ef663fb09d41c3b1862d897536e2a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-4%20Linear%20Regression%20for%20Binary%20Classification.png\" alt=\"Linear Classification and Linear Regression\"></p>\n<p><center> 图四 Linear Classification and Linear Regression<sup>[3]</sup></center><br><br></p>\n<p>从求解问题的难度考虑，二元分类的求解是一个NP难问题，只能近似求解，而线性回归求解方便，程序编写也简单。</p>\n<p>直觉告诉我们:因为二元分类的输出空间{-1，+1}属于线性回归的输出空间，即 $\\{-1, +1\\}∈ R$。其中数据集的标记大于零的表示+1，小于零的表示-1，通过线性回归求得的解析解 $W_{LIN}$，直接得出最优假设 $g(x) = sign( W_{LIN} x)$ 。</p>\n<p>下面给出证明：</p>\n<blockquote>\n<p>入手点：误差大小</p>\n</blockquote>\n<p>首先对比两种方法的曲线图，如图五所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/341baa79de829072a35424870d65421a0bc9f9ba/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-5%20Relation%20of%20Two%20Errors.png\" alt=\"Relations of Two Errors\"></p>\n<p><center> 图五 Relations of Two Errors<sup>[3]</sup></center><br><br></p>\n<p>可以发现，无论期望的y为-1还是+1， $err_{sqr}$ 始终大于 $err_{0/1}$，即公式（13），加上我们之前有的 $E_{out} \\approx E_{in}$，那么我们可以得到公式（14）。</p>\n<script type=\"math/tex; mode=display\">\nerr_{0/1} \\leq err_{sqr}\n\\tag{$13$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nClassification \\quad E_{out}(w)\n&\\leq Classification \\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)} \\\\\n&\\leq Regression \\quad\\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)}\n\\end{align}\n\\tag{$14$}</script><p>所以我们可以通过使用 Linear Regression 的方法来求解Linear Classification的问题，虽然通过这种方法，得到的误差可能更大，但却是一种更有效率的求解方式。在实际运用中，一般都将通过线性回归求得的解析解作为PLA或者pocket的初始值，达到快速求解的目的 。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Regression。</li>\n<li>然后通过例子引入Linear Regression，分别介绍Linear Regression的误差方程，算法流程。</li>\n<li>接着我们引入VC Bound 解释了Linear Regression为什么可以实现学习。</li>\n<li>最后我们应用Linear Regression的算法到Classification的问题中：虽然会损失一定的准确度，但是效率提升很大。</li>\n</ol>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\9\\9 - 1 - Linear Regression Problem (10-08)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\9\\9 - 3 - Generalization Issue (20-34)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\9\\9 - 4 - Linear Regression for Binary Classification (11-23)</p>\n<p><br></p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Linear-Regression\"><a href=\"#How-can-Machine-Learn-Linear-Regression\" class=\"headerlink\" title=\"How can Machine Learn? - Linear Regression\"></a>How can Machine Learn? - Linear Regression</h1><h2 id=\"1-What-is-Regression\"><a href=\"#1-What-is-Regression\" class=\"headerlink\" title=\"1. What is Regression\"></a>1. What is Regression</h2><p>机器学习算法一般是这样一个步骤：</p>\n<ol>\n<li><p>对于一个问题，用数学语言来描述它，然后建立模型，e.g., 回归模型或者分类模型；</p>\n</li>\n<li><p>建立代价函数: Cost Function, 用最大似然、最大后验概率或者最小化分类误差等等数，也就是一个最优化问题。找到最优化问题的解，也就是能拟合我们的数据的最好的模型参数；</p>\n</li>\n<li><p>求解这个代价函数，找到最优解。求解也就分很多种情况了：</p>\n<p>1). 如果这个优化函数存在解析解。例如我们求最值一般是对代价函数求导，找到导数为0的点，也就是最大值或者最小值的地方了。如果代价函数能简单求导，并且求导后为0的式子存在解析解，那么我们就可以直接得到最优的参数了: Gradient Descent。</p>\n<p>2). 如果式子很难求导，例如函数里面存在隐含的变量或者变量相互间存在耦合，也就互相依赖的情况。或者求导后式子得不到解释解，例如未知参数的个数大于已知方程组的个数等。这时候我们就需要借助迭代算法来一步一步找到最有解了。</p>\n<p>3). 另外需要考虑的情况是，如果代价函数是凸函数，那么就存在全局最优解。</p>\n</li>\n</ol>\n<p>回归(Regression)问题与分类(Classification)问题类似，关键的区别在于，Regression的输出是实数,是一个范围，所以不能提前确定所有输出值；而Classification的输出是确定的值。换个角度说，假如输出足够多的数据的时候：如果输出的值是连续的，这个问题叫做Regression，而如果输出的值是离散的，那么这个问题叫做Classification</p>\n<p>用数学符号表示如果公式（1）所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nRegression : &f(x) = \\left[ value1, value2 \\right]  \\\\\nClassification: &f(x) = \\{ value_1, value_2, ..., value_n \\}\n\\end{align}\n\\tag{$1$}</script><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Linear-Regression\"><a href=\"#2-Linear-Regression\" class=\"headerlink\" title=\"2. Linear Regression\"></a>2. Linear Regression</h2><h3 id=\"1-Introduction-of-Linear-Regression\"><a href=\"#1-Introduction-of-Linear-Regression\" class=\"headerlink\" title=\"1) Introduction of Linear Regression\"></a>1) Introduction of Linear Regression</h3><p>线性回归问题同样的表示各个属性（Attribution）对最终结果的贡献：也就是说每个属性乘以对应的权值，最后再加上一定的偏移，如公式（2）所示</p>\n<script type=\"math/tex; mode=display\">\ny = w_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n\n\\tag{$2$}</script><p>如果给第一项的偏移 $w_0$ 加上属性值 $x_0$，并把单独的输出点$y$用向量进行表示，那么公式（2）就变成了公式（3）（这一步纯粹是为了表示方便）。</p>\n<p>Hypothesis h(x):</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh(x) &= w_0 \\cdot x_0 + w_1 \\cdot x_1 + w_2 \\cdot x_2 + ... + w_n \\cdot x_n  \\quad(x_0 = 1) \\\\\n     &= w^T \\cdot x_i \\\\\n     &= W^T \\cdot X\n\\end{align}\n\\tag{$3$}</script><p>从公式(3)的可以看出，与二元分类假设函数的表示只差了一个取正负号的函数 $sign()$。</p>\n<h3 id=\"2-Error-Measurement-of-Linear-Regression\"><a href=\"#2-Error-Measurement-of-Linear-Regression\" class=\"headerlink\" title=\"2) Error Measurement of Linear Regression\"></a>2) Error Measurement of Linear Regression</h3><p>线性回归问题的错误如图一所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/de4c8798497f08b40cbe86cf0cc665ceaa6d54ff/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-1%20Linear%20Regression.png\" alt=\"Error Measurement\"></p>\n<center> 图一 Error Measurement <sup>[1]</sup></center>\n\n\n<p>上一章中，提到了回归问题我们用平方误差来表示（其实还有RMSE， R2等方法，老师上课只讲了平方误差，为了说明方便，我们只写这个）<br>根据图一的信息，很明显得到公式（4）（5）。</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(w)) = \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\nE_{out}(w)) = \\epsilon \\cdot \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2\n\\tag{$5$}</script><p>VC Bound可以约束各种情况的学习模型，当然回归类型的模型也被也受此约束，只需要寻找足够小 $E_{in}(w)$ 便可以满足 $E_{out}(w)$ 小的需求。</p>\n<h3 id=\"3-Linear-Regression-Algorithm\"><a href=\"#3-Linear-Regression-Algorithm\" class=\"headerlink\" title=\"3) Linear Regression Algorithm\"></a>3) Linear Regression Algorithm</h3><p>刚刚上面的Error Meansurement中，我们提到了VC Bound中，在训练样本足够的情况下，我们要用特定的算法，来找到最小的 $E_{in}(w)$，所以把上面公式（4）的pointwise error measurement 通过矩阵做调整得到公式（6）。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nE_{in}(w)) &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(w^Tx_n - y_n)^2 \\\\\n           &= \\frac{1}{N} \\sum\\limits_{n=1}^{N}(x_n^Tw - y_n)^2   \\quad\\quad (向量内积，符合交换率) \\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                x_1^Tw - y_1 & \\\\\n                x_2^Tw - y_2 & \\\\\n                ...            \\\\\n                x_N^Tw - y_N &\n           \\end{array}\n           \\right|\n           \\right|^2               \\quad\\quad(平方求和)\\\\\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{bmatrix}\n                -x_1^T-\\\\\n                -x_1^T-\\\\\n                ...    \\\\\n                -x_1^T-\\\\\n           \\end{bmatrix}\n           \\cdot w\n           \\begin{bmatrix}\n                y_1\\\\\n                y_2\\\\\n                ...\\\\\n                y_n\\\\\n           \\end{bmatrix}\n           \\right|\n           \\right|^2                \\quad\\quad(矩阵平方)\\\\\n\n           &= \\frac{1}{N}\n           \\left|\n           \\left|\n           \\begin{array}{ccc}\n                \\underbrace{X^T}_{N \\times (d+1)}\n                \\underbrace{w}_{(d+1)\\times 1}\n                -\n                \\underbrace{y}_{N \\times 1}\n           \\end{array}\n           \\right|\n           \\right|^2 \\\\\n\\end{align}\n\\tag{$6$}</script><p>根据公式（6），那么 $E_{in}(w)$的最小值如公式（7）所示。</p>\n<script type=\"math/tex; mode=display\">\nmin_w E_{in}(w) = min_w \\frac{1}{N} \\left|\\left| X^Tw - y \\right|\\right|^2\n\\tag{$7$}</script><p>$E_{in}(w)$的变化图如图二所示，可以看出这是一个连续（continuous）、可微（differentiable）的凸（convex）函数。最小值就是山谷的点（即转折点），并且对这个点求导的值为0。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/edb6705ac1e3e9565cb69b9b170c1de25f86f987/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-2%20Linear%20Regression%20Ein.png\" alt=\"Ein Curve\"></p>\n<center> 图二 Ein Curve <sup>[1]</sup></center>\n\n<p>所以接下来，我们需要对$E_{in}(w)$求导并且找到一个值 $W_{LIN}$，使得 $\\nabla E_{in}(w)$ 的值为0。</p>\n<ol>\n<li>首先我们需要考虑两种情况：①只有一个w； ②w为向量</li>\n<li>首先我们把公式（6）平方去掉</li>\n<li>只有一个w的时候，就按照正常的求导方式求导即可，得到公式（7）</li>\n<li>当w为向量的时候，我们需要对其中一个进行转置，然后再求导，得到公式（8）</li>\n<li>根据公式（7）（8）可以看出，两种情况的求导的结果非常相似，可以用公式（9）表示</li>\n<li>最后我们令公式（9）的值为0，得到我们需要的 $W_{LIN}$ 如公式（10）所示,其中 $X^\\dagger$ 叫做<a href=\"http://blog.sina.com.cn/s/blog_890c6aa30101cn6t.html\" target=\"_blank\" rel=\"external\">矩阵X的伪逆矩阵（pseudo-inverse）</a></li>\n</ol>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\none \\quad w : E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^2 - 2 \\cdot X^T yw  + y^2 \\right) \\\\\n       \\nabla E_{in}(w) &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$7$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nvector \\quad w :  E_{in}(w) &= \\frac{1}{N} \\left( (X^T)X w^T w - 2 \\cdot X^T y w^T  + y^2 \\right) \\\\\n          \\nabla E_{in}(w)  &= \\frac{1}{N} \\left( 2(X^T)X w - 2 \\cdot X^T y \\right)\n\\end{align}\n\\tag{$8$}</script><script type=\"math/tex; mode=display\">\n\\nabla E_{in}(w)  = \\frac{2}{N} \\left( (X^T)X w - X^T y \\right)\n\\tag{$9$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nW_{LIN} &= \\underbrace{(X^T X) ^ {-1} X^T }_{X^\\dagger} y \\\\\n        &= \\underbrace{X ^\\dagger }_{(d+1)\\times N)}\n           \\underbrace{y}_{N \\times 1}\n\\end{align}\n\\tag{$10$}</script><h3 id=\"4-Generalization-Issue\"><a href=\"#4-Generalization-Issue\" class=\"headerlink\" title=\"4) Generalization Issue\"></a>4) Generalization Issue</h3><p>上一节中，我们得到了最佳的 w 的解，但是，哪个是最小的 $E_{in}$， 实际上我们最需要的是使得 $E_{out}$最小，而我们这一节就是要讨论之前关于VC Bound保证了 $E_{in} \\approx E_{out}$ 是否依然适用于线性回归问题。（中间解释过程较复杂，后续补充。）</p>\n<p>结论就是得到了 $E_{in} E_{out}$关于 noise level的方程，如公式（11）（12），曲线图如图三所示。</p>\n<script type=\"math/tex; mode=display\">\nE_{in}(w)  = noise \\quad level  \\cdot (1- \\frac{d+1}{N})\n\\tag{$11$}</script><script type=\"math/tex; mode=display\">\nE_{out}(w)  = noise \\quad level  \\cdot (1+ \\frac{d+1}{N})\n\\tag{$12$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/01235bfa1a94084fee01577e205a27839be75228/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-3%20Ein%20Eout.png\" alt=\"Ein Eout Curve\"></p>\n<center> 图三 Ein Eout Curve<sup>[2]</sup></center>\n\n\n<p>可以看出在N趋于无穷大时，与两者都会趋近于noise level的值，即 $\\sigma^2$ 泛化错误之间的差距：$\\frac{2(d+1)}{N}$ 。</p>\n<p>至此可以表明在线性回归中可以寻找到很好的 $E_{out}$，因此线性回归可以学习。</p>\n<h3 id=\"5-Linear-Regression-for-Binary-Classification\"><a href=\"#5-Linear-Regression-for-Binary-Classification\" class=\"headerlink\" title=\"5) Linear Regression for Binary Classification\"></a>5) Linear Regression for Binary Classification</h3><p>这一节，我们主要讨论能否通过求解线性回归的方式求二元分类问题</p>\n<p>首先对比Linear Classification 和 Linear Regression， 如图四</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d4a67d82122ef663fb09d41c3b1862d897536e2a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-4%20Linear%20Regression%20for%20Binary%20Classification.png\" alt=\"Linear Classification and Linear Regression\"></p>\n<p><center> 图四 Linear Classification and Linear Regression<sup>[3]</sup></center><br><br></p>\n<p>从求解问题的难度考虑，二元分类的求解是一个NP难问题，只能近似求解，而线性回归求解方便，程序编写也简单。</p>\n<p>直觉告诉我们:因为二元分类的输出空间{-1，+1}属于线性回归的输出空间，即 $\\{-1, +1\\}∈ R$。其中数据集的标记大于零的表示+1，小于零的表示-1，通过线性回归求得的解析解 $W_{LIN}$，直接得出最优假设 $g(x) = sign( W_{LIN} x)$ 。</p>\n<p>下面给出证明：</p>\n<blockquote>\n<p>入手点：误差大小</p>\n</blockquote>\n<p>首先对比两种方法的曲线图，如图五所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/341baa79de829072a35424870d65421a0bc9f9ba/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter7-5%20Relation%20of%20Two%20Errors.png\" alt=\"Relations of Two Errors\"></p>\n<p><center> 图五 Relations of Two Errors<sup>[3]</sup></center><br><br></p>\n<p>可以发现，无论期望的y为-1还是+1， $err_{sqr}$ 始终大于 $err_{0/1}$，即公式（13），加上我们之前有的 $E_{out} \\approx E_{in}$，那么我们可以得到公式（14）。</p>\n<script type=\"math/tex; mode=display\">\nerr_{0/1} \\leq err_{sqr}\n\\tag{$13$}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\nClassification \\quad E_{out}(w)\n&\\leq Classification \\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)} \\\\\n&\\leq Regression \\quad\\quad E_{in}(w)  + \\sqrt{\\frac{8}{N} \\ln\\left( \\frac{4 (2N)^{d_{vc}}}{\\delta} \\right)}\n\\end{align}\n\\tag{$14$}</script><p>所以我们可以通过使用 Linear Regression 的方法来求解Linear Classification的问题，虽然通过这种方法，得到的误差可能更大，但却是一种更有效率的求解方式。在实际运用中，一般都将通过线性回归求得的解析解作为PLA或者pocket的初始值，达到快速求解的目的 。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Regression。</li>\n<li>然后通过例子引入Linear Regression，分别介绍Linear Regression的误差方程，算法流程。</li>\n<li>接着我们引入VC Bound 解释了Linear Regression为什么可以实现学习。</li>\n<li>最后我们应用Linear Regression的算法到Classification的问题中：虽然会损失一定的准确度，但是效率提升很大。</li>\n</ol>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\9\\9 - 1 - Linear Regression Problem (10-08)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\9\\9 - 3 - Generalization Issue (20-34)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\9\\9 - 4 - Linear Regression for Binary Classification (11-23)</p>\n<p><br></p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"8.How can Machine Learn? - Logistic Regression","date":"2017-10-13T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# How can Machine Learn? - Logistic Regression\n\n\n>这一节讨论与 Linear Regression 非常类似的Logistic Regression\n\n## 1. Introduction of Logistic Regression\n使用二元分类分析心脏病复发问题，其输出空间只含有两项{+1，-1}，分别表示复发和不发复发。在含有噪音的情况下，目标函数f可以使用目标分布P来表示，如公式（1）所示\n\n$$\nf(x) = sign \\left( P(+1|x) - \\frac{1}{2} \\right) ∈ \\{ +1,-1 \\}\n\\tag{1}\n$$\n\n但是实际情况，医生往往不会直接告诉病人说是否会心脏病复发，而是用概率，例如说有80%的可能性会复发，此种情况被称为软二元分类（soft binary classification），目标函数f的表达如公式（2）所示，其输出以概率的形式，在0~1之间。\n\n$$\nf(x) =  P(+1|x)  ∈ [ +1,-1 ]\n\\tag{2}\n$$\n\n但是病人的病历里面不可能记录以前有多少多少的几率复发/不复发，而是真实的记录病人是否复发。所以概率的情况来说，复发/不复发的情况就像是噪音了(因为偏离中间的概率值大)，所以我们把实际的训练数据看成是含有噪音的理想训练数据。这种问题如何求解呢？我们可以通过输入各属性 $x=(x_0,x_1, x_2, ..., x_n)$ 的加权总分数（weighted scores），如公式（3）所示\n\n$$\ns = \\sum\\limits_{i=0}^n w_ix_i = w^Tx\n\\tag{3}\n$$\n\n这里的s的值不在 0~1之间，所以我们还需要将他进行归一化处理，那就可以使用Logistic Regression。函数用表示 $\\theta(s)$，叫做Logistic Function 或者 Sigmoid Function，如公式（4）所示。分数s越大风险越高，分数s越小风险越低。假设函数h如公式(5)所示，函数曲线的示意图如图一所示。\n\n\n$$\n\\theta( s ) = \\frac{ e } {e + e^z} = \\frac{1}{1+e^{-z}}\n\\tag{4}\n$$\n$$\nh(x) = \\theta( w^T x ) = \\frac{ 1 } {1+e^{-w^Tx}}\n\\tag{5}\n$$\n\n![Logistic Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/57938b7a7b126af2ff2d5abdbea1a2fa0f6a4e1f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-1%20Logistic%20Curve.png)\n<center> 图一 Logistic Curve <sup>[1]</sup></center>\n\n\n观察函数的图形，该函数是一个平滑（处处可微分），单调（monotonic）的S形（sigmoid）函数，因此又被称为sigmoid函数。\n\nLogistic Regression 是当前业界比较常用的机器学习方法，用于估计某种事物的可能性，应用场合如：广告预测，购物推荐，患病可能性判断等。 Logistic Regression既可以做回归，也可以做分类（二分类为主）。\n\n\n\n<br><br>\n----------------------------------\n## 2. Comparison of Linear Regression, Logistic Classification and Logistic Regression\n将logisitic回归与之前学习的二元分类和线性回归做一对比，如图二所示。\n\n![Comparison of Three Linear Models](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a2cbd54aa0efe3a8f2f2f539a2fd595c4075971e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-2%20Comparison%20of%20Three%20Linear%20Models.png)\n<center> 图二 Comparison of Three Linear Models <sup>[2]</sup></center>\n\n其中分数s是在每个假设函数中都会出现的，前两个学习模型的错误衡量分别对应着0/1错误和平方错误，而logistic回归所使用的err函数应如何表示则是本节要介绍的内容。\n\n\n\n<br><br>\n----------------------------------\n## 3. Error Measurement of Logistic Regression - cross-entropy error\n这一节的推导需要对最大似然法和条件概率求解有一定的了解。\n\n>TODO:最大似然法 和 条件概率\n\n1.首先从 Logistic Function 可以推导出下面的公式（6），花括号上半部分不难理解，是将目标函数等式左右对调的结果，而下半部分的推导也很简单，因为+1与-1的总概率为1。\n$$\nf(x) = P(+1|x) \\Leftrightarrow P(y|x) = \\left\\{\n\\begin{aligned}\n& f(x)  \\quad   &for \\quad y = +1\\\\\n& 1-f(x)        &for \\quad y = -1\n\\end{aligned}\n\\right.\n\\tag{6}\n$$\n\n2.假设存在一个数据集 $D={(x_1, \\circ), (x_2, \\times), \\cdots, (x_n, \\times)}$,则通过目标函数产生此种数据集样本的概率可以用公式（7）表示。\n$$\nP(D) = P\\{ x_1 \\} P\\{ \\circ|x_1 \\} \\times P\\{ x_2 \\}P\\{ \\times|x_2 \\} \\times \\dots \\times P\\{ x_n \\} P\\{ \\times|x_n \\}\n\\tag{7}\n$$\n\n3.把公式（6）的公式带入公式（7)中，可以得到公式（8）。\n\n$$\nP(D) = P\\{ x_1 \\} f(x_1) \\times P\\{ x_2 \\} (1-f(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-f(x_n))\n\\tag{7}\n$$\n\n4.f(x)是理想的函数，而我们实际训练得到的是hypothesis h(x)，所以我们还得想办法用h(x)代替f(x)，但是这样的前提是我们假设函数h(x)对数据集与f(x)产生的可能性很大，即likelihood(似然)，即我们在之前在VC Bound的推论中，知道在数据量足够大的情况下g(x)是会接近于f(x)的，如公式（8）所示\n\n$$\nP(D) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (1-h(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-h(x_n))\n\\tag{8}\n$$\n\n\n5.那么最大似然我们表示为 likelihood(h)，在代入simoid函数的特性 $1-h(x) = h(-x)$，可以得到公式（9）\n\n$$\nlikelihood(h) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n))\n\\tag{9}\n$$\n\n6.那么最大的likelihood(h)如公式（10）所示，在计算最大的likelihood(h)时，所有$P(x_i)$的对大小没有影响，因为所有的假设函数都会乘以同样的$P(x_i)$，所以在表示的时候可以只考虑h(x)。\n\n$$\n\\begin{align}\n\\max \\limits_h \\quad likelihood(logistic \\quad h)\n&\\propto P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n)) \\\\\n&\\propto  \\prod \\limits_{i=1}^n h(y_ix_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto  \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto\\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\end{align}\n\\tag{10}\n$$\n\n\n7.连乘公式不容易求解最大问题，因此求其对数，此处以自然对数e为底，并代入sigmoid 方程，令$err(w,y_i,x_i) = ln(1+exp(-yw^Tx))$，如公式（11）所示，误差方程 $E_{in}$ 如公式（12)所示。\n\n$$\n\\begin{align}\n\\max \\limits_w \\quad likelihood(w)\n&\\propto \\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\frac{1}{N} \\sum\\limits_{i=1}^{n} -ln \\theta (y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\underbrace{ \\frac{1}{N} \\sum\\limits_{i=1}^{n} err(w,y_i,x_i) }_{E_{in}(w)}  \\quad \\quad\n\\end{align}\n\\tag{11}\n$$\n\n$$\nE_{in}(w) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln(1+exp(-yw^Tx))\n\\tag{12}\n$$\n\n\n\n<br><br>\n----------------------------------\n## 4. Gradient of Logistic Regression Error\n上一节中，推导出logistic回归的 ，下一步的工作是寻找使得最小的权值向量w。\n对公式（12）进行求导，可以得到公式（13），推导过程参考老师用的方法：用圈圈代替exp里面的数，用正方形代替ln里面的表达式，这样可以使得推导过程看起来更加明白\n$$\n\\begin{align}\n\nE_{in}(w) &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln \\underbrace{(1+exp \\underbrace{(-yw^Tx)}_\\bigcirc)}_\\Box \\\\\n\n\n\\frac{\\partial E_{in}(w)}{\\partial w_i} &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left(\\frac{\\partial ln(\\Box)}{\\partial \\Box}\\right) \\left( \\frac{\\partial (1+exp(\\bigcirc))}{\\partial \\bigcirc} \\right) \\left( \\frac{\\partial - y_iw^Tx_i}{\\partial w_i} \\right) \\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\frac{1}{\\Box} \\right) \\left( exp(\\bigcirc) \\right) \\left( -y_i x_i \\right) \\\\\n\n                  \t\t\t\t\t\t&= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( exp(\\bigcirc) \\right) \\left(-y_i x_i \\right) \\quad \\because(\\frac{1}{\\Box}) \\approx 1\\\\\n\t\t\t\t\t\t\t\t\t\t&= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(\\bigcirc) \\right) \\left( -y_i x_i \\right)  \\\\\n\t\t\t\t\t\t\t\t\t\t&= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(-y_iw^Tx_n) \\right) \\left( -y_i x_i \\right)  \\\\\n\\end{align}\n\\tag{13}\n$$\n\n 从公式（13）可以看出，该函数是一个 $\\theta$ 函数作为权值，关于 $(-y_nx_n)$ 的加权求和函数。如果函数的所有权值为零，，可以看出 $y_i$与所有的对应的 $w^Tx_n$ 的同号，即线性可分。\n\n但是，求该问题的解不能使用类似求解线性回归时使用的闭式解的求解方式，此最小值又该如何计算？我们可以借鉴之前PLA的方法进行迭代求解，如公式（14）\n\n$$\nw_{t+1} = w_t + \\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i\n\\tag{14}\n$$\n\n从公式（14）可以看出，当 $sign(w_t^Tx_i)=y_n$ 的时候，向量不改变，当 $sign(w_t^Tx_i) \\neq y_n$ 的时候 要加上 $y_ix_i$，然后我们把公式（14)做一定的调整得到公式（15），其中多乘以一个1作为更新的步长，用 $\\eta$表示，PLA中更新的部分用 $\\nu$ 来代表，表示更新的方向。该算法被称为迭代优化方法（iterative optimization approach）\n\n$$\n\\begin{align}\nw_{t+1} &= w_t + \\underbrace{1}_\\eta \\cdot\n                 \\underbrace{\\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i}_\\nu \\\\\n\t    &= w_t + \\eta \\cdot \\nu\n\\end{align}\n\\tag{15}\n$$\n\n\n<br><br>\n----------------------------------\n## 5. Use Gradient Descent to Minimize the Error of Logistic Regression\n上面我们根据PLA的方法求得针对Logistic回归问题的误差方程，现在我们就需要找到最佳的参数 $\\eta$ 和 $\\nu$。首先误差方程的曲线图如图三所示。$E-{in}$ 是关于权值向量 $w$ 的示意图为一个平滑且可微的凸函数，其中图像谷底的点对应着最佳 $w$。\n\n![Iterative Optimization](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/efb59327c4bf9ddccb57959dcc04f7801267f667/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-3%20Iterative%20Optimization.png)\n<center> 图三 Iterative Optimization <sup>[3]</sup></center>\n\n为了分工明确，设 $\\nu$ 作为单位向量仅代表方向， $\\eta$ 代表步长表示每次更新改变的大小。在 $\\eta$ 固定的情况下，$\\nu$ 按照最陡峭的方向更改。即在 $\\eta$ 固定 $|\\nu| = 1$ 的情况下，有最快的速度找出使得 $E_{in}$ 最小的 $w$，得到公式（16）\n\n$$\n\\min\\limits_{|\\nu|=1} E_{in} \\underbrace{(w_i + \\eta \\nu)}_{w_{t+1}}\n\\tag{16}\n$$\n\n但是公式（16）依然很难求得最小的 $w$，当 $\\eta$ 很小时，我们通过泰勒展开公式（17）可以得到公式（18），其中 $w_t$ 对应 $x_0$\n\nTylor Expansion\n$$\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f^{(2)}(x_0)}{2!}(x-x_0)^2 + \\dots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)\n\\tag{17}\n$$\n\n$$\n\\begin{align}\n\\min\\limits_{|\\nu|=1} E_{in} (w_i + \\eta \\nu ^ T) &\\approx   E_{in}(w_t) + \\left(\\left( w_t + \\eta\\nu^T  \\right) - w_t \\right) \\frac{\\nabla E_{in}(w_t)}{1!} \\\\\n\n                                                  &= E_in(w_t) + \\eta\\nu^T \\nabla E_{in}(w_t)\n\n\\end{align}\n\\tag{18}\n$$\n\n\n接着我们继续分析公式（18），其中 $E_in{w_t}$ 我们是知道的， $\\eta$ 是给定的步长， $\\nabla E_{in}(w_t)$ 也是知道的，所以求解公式（18）的最小值问题，可以转换成求解 $\\nu^T nabla E_{in}(w_t)$ 的最小值，即公式（19）\n\n$$\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t)\n\\tag{19}\n$$\n\n两个向量最小的情况为其方向相反，即内积为负，得到公式（20）,这种情况下 $\\nu$ 是一个单位向量\n\n$$\n\\begin{align}\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t) &= -1 \\\\\n                                           \\nu &= - \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{20}\n$$\n\n所以把公式（20）带入公式（15），可以得到公式（21）\n$$\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{21}\n$$\n\n从公式（21）可以看出，每次更新权值，w都是减少一点（具体多少要看我们谁的哪个的步长，已经误差大小），按照此种方式更新可以找到使得最小的w。此种方式称作梯度下降（gradient descent）。\n\n\n\n<br><br>\n----------------------------------\n## 6. Choose Step Length for Gradient Descent\n由上面的公式（21）可以看出，w受 步长大小 $\\eta$ 和 误差大小的影响。在一定的 $\\eta$ 下，越接近谷底，纠正的也越来越小；但是如果选择的 $\\eta$ 太大，一个新就更新到对面的山峰上面去了（可能会导致纠正后误差更大），或者  $\\eta$ 太小，更新好久还没有更新到需要的准确度。所以选择适当的 $\\eta$ 很重要。如图四所示。\n![Choice of Step Length](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/09288541bf7cddb805bd091f25cf104e438fc179/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-4%20Choice%20of%20eta.png)\n<center> 图四 Choice of Step Length <sup>[3]</sup></center>\n\n因为 $\\eta$ 与 梯度大小 ${||\\nabla E_{in}(w_t)||}$ 正比，所以我们可以得到公式（22）\n$$\n\\eta_{new} = \\frac{ \\eta_{old}}{||\\nabla E_{in}(w_t)||}\n\\tag{22}\n$$\n\n结合公式（21）（22），我们调整的公式（21）为（23）\n\n$$\n\\begin{align}\nw_{t+1} &= w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}\n\\end{align}\n\\tag{21}\n$$\n\n此时的 $\\eta$ 被称作固定的学习速率（fixed learning rate）。最终得到Logstic Regression 的步骤如下：\n1. 设置权值w为 $w_0$，迭代次数他，并计算梯度 $\\nabla E_{in}(w_t) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\theta \\left( -y_iw_t^Tx_i \\right)\\left( -y_ix_i \\right)$\n2. 不断迭代，并更新权值向量w，$w_{t+1} = w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}$，直到误差函数的导数近似于0，或者迭代一定的次数。\n\n\nGradient Descent 劣势分析：\n1. 不稳定:如果选择的步长太大太小，都会对算法有影响\n2. 局部最优：如果函数不是凸函数的话，可能存在多个局部最优点，那样的话，Gradient Descent只能找到最近的局部最优。\n3. 计算复杂度大，为O(N)，因为导数需要对所有的点进行一次遍历\n\n\n<br><br>\n----------------------------------\n## 7. Stochastic Gradient Descent - Another Approach of Gradient Descent\n上面讨论了 Gradient Descent,以及计算复杂度大的问题，这一节我们讨论另一种方法，可以将计算复杂度降成O(1)级别。这种方法就是Stochastic Gradient Descent（随机梯度），用符号 $\\nabla_w err(w, w_i, y_i)$ 表示， 核心思想是：通过N个样本中随机抽取一个样本点求出的梯度取代原来的期望梯度。 随机梯度值可以看做真实的梯度值加上一个噪音，使用随机梯度取代真实梯度做梯度下降的算法称作随机梯度下降 stochastic gradient descent(SGD)。在迭代次数足够多的情况下，平均的随机梯度和平均的真实梯度相差不大。真实梯度与随机梯度的关系如公式（22）所示\n\n$$\n\\nabla_w E_{in}(w_t) = \\varepsilon_{i} \\cdot \\nabla_w err( w, x_i, y_i)\n\\tag{22}\n$$\n\nLogistic Regression 的SGD的迭代如公式(23)所示。\n\n$$\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot( \\nabla_w err( w, x_i, y_i) )(y_ix_i) \\\\\n        &= w_t + \\eta  \\underbrace{\\theta (-y_i w_t^T x_i)(y_i x_i)}_{- \\nabla_w err( w, x_i, y_i)}(y_ix_i)\n\\end{align}\n\\tag{23}\n$$\n\n对比之前的PLA算法的公式（如公式（24）），容易发现两个公式很类似，因此logistic Regession 的SGD算法又叫\"软\"PLA，因为权值并没有那么绝对不是1就是0，而是一个在0~1之间的值。如果 $\\eta = 1$ 且 $w_t^T x_i \\approx \\infty$ 始终是一个很大的值，则logistic Regession 的SGD相当于是PLA算法。\n\n$$\nw_{t+1} = w_t + \\underbrace{1}_\\eta  \\underbrace{ \\left[\\left[ sign(w_tTx_i) \\neq y_i\\right]\\right]}_{\\nu}(y_ix_i)\n\\tag{24}\n$$\n\n\nSGD算法关键是找出两个最佳的参数: 迭代次数 $t$ 和学习步长 $\\eta$。\n1. 对于迭代次数 $t$ 只能假设足够步数后是已经做到足够好，即通常设置一个大的数值即可；\n2. 学习步长 $\\eta$通常也很难选定(老师推荐：0.1126)。\n\n\nSGD算法的优缺点：\n1. 优点：计算简单快速，适用于大数据或者流式数据；\n2. 缺点：不稳定，需要一定的调试时间。\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先引入了 Logistic Regression\n2. 然后对比了 Logistic Regression 和 Linear Regression, Linear Classification。\n3. 接着分析Logistic Regression 的误差方程，梯度方程，并用Gradient Descent 来最小化误差，并分析如何选择步长。\n\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\10\\10 - 1 - Logistic Regression Problem (14-33)\n\n[2] 机器学习基石(台湾大学-林轩田)\\10\\10 - 2 - Logistic Regression Error (15-58)\n\n[3] 机器学习基石(台湾大学-林轩田)\\10\\10 - 4 - Gradient Descent (19-18)\n\n\n<br>\n<br>\n---------------------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-13-8.How can Machine Learn - Logistic Regression.md","raw":"---\ntitle: 8.How can Machine Learn? - Logistic Regression\ndate: 2017-10-13 12:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# How can Machine Learn? - Logistic Regression\n\n\n>这一节讨论与 Linear Regression 非常类似的Logistic Regression\n\n## 1. Introduction of Logistic Regression\n使用二元分类分析心脏病复发问题，其输出空间只含有两项{+1，-1}，分别表示复发和不发复发。在含有噪音的情况下，目标函数f可以使用目标分布P来表示，如公式（1）所示\n\n$$\nf(x) = sign \\left( P(+1|x) - \\frac{1}{2} \\right) ∈ \\{ +1,-1 \\}\n\\tag{1}\n$$\n\n但是实际情况，医生往往不会直接告诉病人说是否会心脏病复发，而是用概率，例如说有80%的可能性会复发，此种情况被称为软二元分类（soft binary classification），目标函数f的表达如公式（2）所示，其输出以概率的形式，在0~1之间。\n\n$$\nf(x) =  P(+1|x)  ∈ [ +1,-1 ]\n\\tag{2}\n$$\n\n但是病人的病历里面不可能记录以前有多少多少的几率复发/不复发，而是真实的记录病人是否复发。所以概率的情况来说，复发/不复发的情况就像是噪音了(因为偏离中间的概率值大)，所以我们把实际的训练数据看成是含有噪音的理想训练数据。这种问题如何求解呢？我们可以通过输入各属性 $x=(x_0,x_1, x_2, ..., x_n)$ 的加权总分数（weighted scores），如公式（3）所示\n\n$$\ns = \\sum\\limits_{i=0}^n w_ix_i = w^Tx\n\\tag{3}\n$$\n\n这里的s的值不在 0~1之间，所以我们还需要将他进行归一化处理，那就可以使用Logistic Regression。函数用表示 $\\theta(s)$，叫做Logistic Function 或者 Sigmoid Function，如公式（4）所示。分数s越大风险越高，分数s越小风险越低。假设函数h如公式(5)所示，函数曲线的示意图如图一所示。\n\n\n$$\n\\theta( s ) = \\frac{ e } {e + e^z} = \\frac{1}{1+e^{-z}}\n\\tag{4}\n$$\n$$\nh(x) = \\theta( w^T x ) = \\frac{ 1 } {1+e^{-w^Tx}}\n\\tag{5}\n$$\n\n![Logistic Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/57938b7a7b126af2ff2d5abdbea1a2fa0f6a4e1f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-1%20Logistic%20Curve.png)\n<center> 图一 Logistic Curve <sup>[1]</sup></center>\n\n\n观察函数的图形，该函数是一个平滑（处处可微分），单调（monotonic）的S形（sigmoid）函数，因此又被称为sigmoid函数。\n\nLogistic Regression 是当前业界比较常用的机器学习方法，用于估计某种事物的可能性，应用场合如：广告预测，购物推荐，患病可能性判断等。 Logistic Regression既可以做回归，也可以做分类（二分类为主）。\n\n\n\n<br><br>\n----------------------------------\n## 2. Comparison of Linear Regression, Logistic Classification and Logistic Regression\n将logisitic回归与之前学习的二元分类和线性回归做一对比，如图二所示。\n\n![Comparison of Three Linear Models](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a2cbd54aa0efe3a8f2f2f539a2fd595c4075971e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-2%20Comparison%20of%20Three%20Linear%20Models.png)\n<center> 图二 Comparison of Three Linear Models <sup>[2]</sup></center>\n\n其中分数s是在每个假设函数中都会出现的，前两个学习模型的错误衡量分别对应着0/1错误和平方错误，而logistic回归所使用的err函数应如何表示则是本节要介绍的内容。\n\n\n\n<br><br>\n----------------------------------\n## 3. Error Measurement of Logistic Regression - cross-entropy error\n这一节的推导需要对最大似然法和条件概率求解有一定的了解。\n\n>TODO:最大似然法 和 条件概率\n\n1.首先从 Logistic Function 可以推导出下面的公式（6），花括号上半部分不难理解，是将目标函数等式左右对调的结果，而下半部分的推导也很简单，因为+1与-1的总概率为1。\n$$\nf(x) = P(+1|x) \\Leftrightarrow P(y|x) = \\left\\{\n\\begin{aligned}\n& f(x)  \\quad   &for \\quad y = +1\\\\\n& 1-f(x)        &for \\quad y = -1\n\\end{aligned}\n\\right.\n\\tag{6}\n$$\n\n2.假设存在一个数据集 $D={(x_1, \\circ), (x_2, \\times), \\cdots, (x_n, \\times)}$,则通过目标函数产生此种数据集样本的概率可以用公式（7）表示。\n$$\nP(D) = P\\{ x_1 \\} P\\{ \\circ|x_1 \\} \\times P\\{ x_2 \\}P\\{ \\times|x_2 \\} \\times \\dots \\times P\\{ x_n \\} P\\{ \\times|x_n \\}\n\\tag{7}\n$$\n\n3.把公式（6）的公式带入公式（7)中，可以得到公式（8）。\n\n$$\nP(D) = P\\{ x_1 \\} f(x_1) \\times P\\{ x_2 \\} (1-f(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-f(x_n))\n\\tag{7}\n$$\n\n4.f(x)是理想的函数，而我们实际训练得到的是hypothesis h(x)，所以我们还得想办法用h(x)代替f(x)，但是这样的前提是我们假设函数h(x)对数据集与f(x)产生的可能性很大，即likelihood(似然)，即我们在之前在VC Bound的推论中，知道在数据量足够大的情况下g(x)是会接近于f(x)的，如公式（8）所示\n\n$$\nP(D) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (1-h(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-h(x_n))\n\\tag{8}\n$$\n\n\n5.那么最大似然我们表示为 likelihood(h)，在代入simoid函数的特性 $1-h(x) = h(-x)$，可以得到公式（9）\n\n$$\nlikelihood(h) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n))\n\\tag{9}\n$$\n\n6.那么最大的likelihood(h)如公式（10）所示，在计算最大的likelihood(h)时，所有$P(x_i)$的对大小没有影响，因为所有的假设函数都会乘以同样的$P(x_i)$，所以在表示的时候可以只考虑h(x)。\n\n$$\n\\begin{align}\n\\max \\limits_h \\quad likelihood(logistic \\quad h)\n&\\propto P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n)) \\\\\n&\\propto  \\prod \\limits_{i=1}^n h(y_ix_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto  \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto\\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\end{align}\n\\tag{10}\n$$\n\n\n7.连乘公式不容易求解最大问题，因此求其对数，此处以自然对数e为底，并代入sigmoid 方程，令$err(w,y_i,x_i) = ln(1+exp(-yw^Tx))$，如公式（11）所示，误差方程 $E_{in}$ 如公式（12)所示。\n\n$$\n\\begin{align}\n\\max \\limits_w \\quad likelihood(w)\n&\\propto \\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\frac{1}{N} \\sum\\limits_{i=1}^{n} -ln \\theta (y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\underbrace{ \\frac{1}{N} \\sum\\limits_{i=1}^{n} err(w,y_i,x_i) }_{E_{in}(w)}  \\quad \\quad\n\\end{align}\n\\tag{11}\n$$\n\n$$\nE_{in}(w) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln(1+exp(-yw^Tx))\n\\tag{12}\n$$\n\n\n\n<br><br>\n----------------------------------\n## 4. Gradient of Logistic Regression Error\n上一节中，推导出logistic回归的 ，下一步的工作是寻找使得最小的权值向量w。\n对公式（12）进行求导，可以得到公式（13），推导过程参考老师用的方法：用圈圈代替exp里面的数，用正方形代替ln里面的表达式，这样可以使得推导过程看起来更加明白\n$$\n\\begin{align}\n\nE_{in}(w) &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln \\underbrace{(1+exp \\underbrace{(-yw^Tx)}_\\bigcirc)}_\\Box \\\\\n\n\n\\frac{\\partial E_{in}(w)}{\\partial w_i} &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left(\\frac{\\partial ln(\\Box)}{\\partial \\Box}\\right) \\left( \\frac{\\partial (1+exp(\\bigcirc))}{\\partial \\bigcirc} \\right) \\left( \\frac{\\partial - y_iw^Tx_i}{\\partial w_i} \\right) \\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\frac{1}{\\Box} \\right) \\left( exp(\\bigcirc) \\right) \\left( -y_i x_i \\right) \\\\\n\n                  \t\t\t\t\t\t&= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( exp(\\bigcirc) \\right) \\left(-y_i x_i \\right) \\quad \\because(\\frac{1}{\\Box}) \\approx 1\\\\\n\t\t\t\t\t\t\t\t\t\t&= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(\\bigcirc) \\right) \\left( -y_i x_i \\right)  \\\\\n\t\t\t\t\t\t\t\t\t\t&= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(-y_iw^Tx_n) \\right) \\left( -y_i x_i \\right)  \\\\\n\\end{align}\n\\tag{13}\n$$\n\n 从公式（13）可以看出，该函数是一个 $\\theta$ 函数作为权值，关于 $(-y_nx_n)$ 的加权求和函数。如果函数的所有权值为零，，可以看出 $y_i$与所有的对应的 $w^Tx_n$ 的同号，即线性可分。\n\n但是，求该问题的解不能使用类似求解线性回归时使用的闭式解的求解方式，此最小值又该如何计算？我们可以借鉴之前PLA的方法进行迭代求解，如公式（14）\n\n$$\nw_{t+1} = w_t + \\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i\n\\tag{14}\n$$\n\n从公式（14）可以看出，当 $sign(w_t^Tx_i)=y_n$ 的时候，向量不改变，当 $sign(w_t^Tx_i) \\neq y_n$ 的时候 要加上 $y_ix_i$，然后我们把公式（14)做一定的调整得到公式（15），其中多乘以一个1作为更新的步长，用 $\\eta$表示，PLA中更新的部分用 $\\nu$ 来代表，表示更新的方向。该算法被称为迭代优化方法（iterative optimization approach）\n\n$$\n\\begin{align}\nw_{t+1} &= w_t + \\underbrace{1}_\\eta \\cdot\n                 \\underbrace{\\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i}_\\nu \\\\\n\t    &= w_t + \\eta \\cdot \\nu\n\\end{align}\n\\tag{15}\n$$\n\n\n<br><br>\n----------------------------------\n## 5. Use Gradient Descent to Minimize the Error of Logistic Regression\n上面我们根据PLA的方法求得针对Logistic回归问题的误差方程，现在我们就需要找到最佳的参数 $\\eta$ 和 $\\nu$。首先误差方程的曲线图如图三所示。$E-{in}$ 是关于权值向量 $w$ 的示意图为一个平滑且可微的凸函数，其中图像谷底的点对应着最佳 $w$。\n\n![Iterative Optimization](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/efb59327c4bf9ddccb57959dcc04f7801267f667/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-3%20Iterative%20Optimization.png)\n<center> 图三 Iterative Optimization <sup>[3]</sup></center>\n\n为了分工明确，设 $\\nu$ 作为单位向量仅代表方向， $\\eta$ 代表步长表示每次更新改变的大小。在 $\\eta$ 固定的情况下，$\\nu$ 按照最陡峭的方向更改。即在 $\\eta$ 固定 $|\\nu| = 1$ 的情况下，有最快的速度找出使得 $E_{in}$ 最小的 $w$，得到公式（16）\n\n$$\n\\min\\limits_{|\\nu|=1} E_{in} \\underbrace{(w_i + \\eta \\nu)}_{w_{t+1}}\n\\tag{16}\n$$\n\n但是公式（16）依然很难求得最小的 $w$，当 $\\eta$ 很小时，我们通过泰勒展开公式（17）可以得到公式（18），其中 $w_t$ 对应 $x_0$\n\nTylor Expansion\n$$\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f^{(2)}(x_0)}{2!}(x-x_0)^2 + \\dots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)\n\\tag{17}\n$$\n\n$$\n\\begin{align}\n\\min\\limits_{|\\nu|=1} E_{in} (w_i + \\eta \\nu ^ T) &\\approx   E_{in}(w_t) + \\left(\\left( w_t + \\eta\\nu^T  \\right) - w_t \\right) \\frac{\\nabla E_{in}(w_t)}{1!} \\\\\n\n                                                  &= E_in(w_t) + \\eta\\nu^T \\nabla E_{in}(w_t)\n\n\\end{align}\n\\tag{18}\n$$\n\n\n接着我们继续分析公式（18），其中 $E_in{w_t}$ 我们是知道的， $\\eta$ 是给定的步长， $\\nabla E_{in}(w_t)$ 也是知道的，所以求解公式（18）的最小值问题，可以转换成求解 $\\nu^T nabla E_{in}(w_t)$ 的最小值，即公式（19）\n\n$$\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t)\n\\tag{19}\n$$\n\n两个向量最小的情况为其方向相反，即内积为负，得到公式（20）,这种情况下 $\\nu$ 是一个单位向量\n\n$$\n\\begin{align}\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t) &= -1 \\\\\n                                           \\nu &= - \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{20}\n$$\n\n所以把公式（20）带入公式（15），可以得到公式（21）\n$$\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{21}\n$$\n\n从公式（21）可以看出，每次更新权值，w都是减少一点（具体多少要看我们谁的哪个的步长，已经误差大小），按照此种方式更新可以找到使得最小的w。此种方式称作梯度下降（gradient descent）。\n\n\n\n<br><br>\n----------------------------------\n## 6. Choose Step Length for Gradient Descent\n由上面的公式（21）可以看出，w受 步长大小 $\\eta$ 和 误差大小的影响。在一定的 $\\eta$ 下，越接近谷底，纠正的也越来越小；但是如果选择的 $\\eta$ 太大，一个新就更新到对面的山峰上面去了（可能会导致纠正后误差更大），或者  $\\eta$ 太小，更新好久还没有更新到需要的准确度。所以选择适当的 $\\eta$ 很重要。如图四所示。\n![Choice of Step Length](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/09288541bf7cddb805bd091f25cf104e438fc179/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-4%20Choice%20of%20eta.png)\n<center> 图四 Choice of Step Length <sup>[3]</sup></center>\n\n因为 $\\eta$ 与 梯度大小 ${||\\nabla E_{in}(w_t)||}$ 正比，所以我们可以得到公式（22）\n$$\n\\eta_{new} = \\frac{ \\eta_{old}}{||\\nabla E_{in}(w_t)||}\n\\tag{22}\n$$\n\n结合公式（21）（22），我们调整的公式（21）为（23）\n\n$$\n\\begin{align}\nw_{t+1} &= w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}\n\\end{align}\n\\tag{21}\n$$\n\n此时的 $\\eta$ 被称作固定的学习速率（fixed learning rate）。最终得到Logstic Regression 的步骤如下：\n1. 设置权值w为 $w_0$，迭代次数他，并计算梯度 $\\nabla E_{in}(w_t) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\theta \\left( -y_iw_t^Tx_i \\right)\\left( -y_ix_i \\right)$\n2. 不断迭代，并更新权值向量w，$w_{t+1} = w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}$，直到误差函数的导数近似于0，或者迭代一定的次数。\n\n\nGradient Descent 劣势分析：\n1. 不稳定:如果选择的步长太大太小，都会对算法有影响\n2. 局部最优：如果函数不是凸函数的话，可能存在多个局部最优点，那样的话，Gradient Descent只能找到最近的局部最优。\n3. 计算复杂度大，为O(N)，因为导数需要对所有的点进行一次遍历\n\n\n<br><br>\n----------------------------------\n## 7. Stochastic Gradient Descent - Another Approach of Gradient Descent\n上面讨论了 Gradient Descent,以及计算复杂度大的问题，这一节我们讨论另一种方法，可以将计算复杂度降成O(1)级别。这种方法就是Stochastic Gradient Descent（随机梯度），用符号 $\\nabla_w err(w, w_i, y_i)$ 表示， 核心思想是：通过N个样本中随机抽取一个样本点求出的梯度取代原来的期望梯度。 随机梯度值可以看做真实的梯度值加上一个噪音，使用随机梯度取代真实梯度做梯度下降的算法称作随机梯度下降 stochastic gradient descent(SGD)。在迭代次数足够多的情况下，平均的随机梯度和平均的真实梯度相差不大。真实梯度与随机梯度的关系如公式（22）所示\n\n$$\n\\nabla_w E_{in}(w_t) = \\varepsilon_{i} \\cdot \\nabla_w err( w, x_i, y_i)\n\\tag{22}\n$$\n\nLogistic Regression 的SGD的迭代如公式(23)所示。\n\n$$\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot( \\nabla_w err( w, x_i, y_i) )(y_ix_i) \\\\\n        &= w_t + \\eta  \\underbrace{\\theta (-y_i w_t^T x_i)(y_i x_i)}_{- \\nabla_w err( w, x_i, y_i)}(y_ix_i)\n\\end{align}\n\\tag{23}\n$$\n\n对比之前的PLA算法的公式（如公式（24）），容易发现两个公式很类似，因此logistic Regession 的SGD算法又叫\"软\"PLA，因为权值并没有那么绝对不是1就是0，而是一个在0~1之间的值。如果 $\\eta = 1$ 且 $w_t^T x_i \\approx \\infty$ 始终是一个很大的值，则logistic Regession 的SGD相当于是PLA算法。\n\n$$\nw_{t+1} = w_t + \\underbrace{1}_\\eta  \\underbrace{ \\left[\\left[ sign(w_tTx_i) \\neq y_i\\right]\\right]}_{\\nu}(y_ix_i)\n\\tag{24}\n$$\n\n\nSGD算法关键是找出两个最佳的参数: 迭代次数 $t$ 和学习步长 $\\eta$。\n1. 对于迭代次数 $t$ 只能假设足够步数后是已经做到足够好，即通常设置一个大的数值即可；\n2. 学习步长 $\\eta$通常也很难选定(老师推荐：0.1126)。\n\n\nSGD算法的优缺点：\n1. 优点：计算简单快速，适用于大数据或者流式数据；\n2. 缺点：不稳定，需要一定的调试时间。\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先引入了 Logistic Regression\n2. 然后对比了 Logistic Regression 和 Linear Regression, Linear Classification。\n3. 接着分析Logistic Regression 的误差方程，梯度方程，并用Gradient Descent 来最小化误差，并分析如何选择步长。\n\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\10\\10 - 1 - Logistic Regression Problem (14-33)\n\n[2] 机器学习基石(台湾大学-林轩田)\\10\\10 - 2 - Logistic Regression Error (15-58)\n\n[3] 机器学习基石(台湾大学-林轩田)\\10\\10 - 4 - Gradient Descent (19-18)\n\n\n<br>\n<br>\n---------------------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-13-8.How can Machine Learn - Logistic Regression","published":1,"updated":"2018-10-27T04:30:42.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0br001te0owen0lbkxt","content":"<h1 id=\"How-can-Machine-Learn-Logistic-Regression\"><a href=\"#How-can-Machine-Learn-Logistic-Regression\" class=\"headerlink\" title=\"How can Machine Learn? - Logistic Regression\"></a>How can Machine Learn? - Logistic Regression</h1><blockquote>\n<p>这一节讨论与 Linear Regression 非常类似的Logistic Regression</p>\n</blockquote>\n<h2 id=\"1-Introduction-of-Logistic-Regression\"><a href=\"#1-Introduction-of-Logistic-Regression\" class=\"headerlink\" title=\"1. Introduction of Logistic Regression\"></a>1. Introduction of Logistic Regression</h2><p>使用二元分类分析心脏病复发问题，其输出空间只含有两项{+1，-1}，分别表示复发和不发复发。在含有噪音的情况下，目标函数f可以使用目标分布P来表示，如公式（1）所示</p>\n<script type=\"math/tex; mode=display\">\nf(x) = sign \\left( P(+1|x) - \\frac{1}{2} \\right) ∈ \\{ +1,-1 \\}\n\\tag{1}</script><p>但是实际情况，医生往往不会直接告诉病人说是否会心脏病复发，而是用概率，例如说有80%的可能性会复发，此种情况被称为软二元分类（soft binary classification），目标函数f的表达如公式（2）所示，其输出以概率的形式，在0~1之间。</p>\n<script type=\"math/tex; mode=display\">\nf(x) =  P(+1|x)  ∈ [ +1,-1 ]\n\\tag{2}</script><p>但是病人的病历里面不可能记录以前有多少多少的几率复发/不复发，而是真实的记录病人是否复发。所以概率的情况来说，复发/不复发的情况就像是噪音了(因为偏离中间的概率值大)，所以我们把实际的训练数据看成是含有噪音的理想训练数据。这种问题如何求解呢？我们可以通过输入各属性 $x=(x_0,x_1, x_2, …, x_n)$ 的加权总分数（weighted scores），如公式（3）所示</p>\n<script type=\"math/tex; mode=display\">\ns = \\sum\\limits_{i=0}^n w_ix_i = w^Tx\n\\tag{3}</script><p>这里的s的值不在 0~1之间，所以我们还需要将他进行归一化处理，那就可以使用Logistic Regression。函数用表示 $\\theta(s)$，叫做Logistic Function 或者 Sigmoid Function，如公式（4）所示。分数s越大风险越高，分数s越小风险越低。假设函数h如公式(5)所示，函数曲线的示意图如图一所示。</p>\n<script type=\"math/tex; mode=display\">\n\\theta( s ) = \\frac{ e } {e + e^z} = \\frac{1}{1+e^{-z}}\n\\tag{4}</script><script type=\"math/tex; mode=display\">\nh(x) = \\theta( w^T x ) = \\frac{ 1 } {1+e^{-w^Tx}}\n\\tag{5}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/57938b7a7b126af2ff2d5abdbea1a2fa0f6a4e1f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-1%20Logistic%20Curve.png\" alt=\"Logistic Curve\"></p>\n<center> 图一 Logistic Curve <sup>[1]</sup></center>\n\n\n<p>观察函数的图形，该函数是一个平滑（处处可微分），单调（monotonic）的S形（sigmoid）函数，因此又被称为sigmoid函数。</p>\n<p>Logistic Regression 是当前业界比较常用的机器学习方法，用于估计某种事物的可能性，应用场合如：广告预测，购物推荐，患病可能性判断等。 Logistic Regression既可以做回归，也可以做分类（二分类为主）。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Comparison-of-Linear-Regression-Logistic-Classification-and-Logistic-Regression\"><a href=\"#2-Comparison-of-Linear-Regression-Logistic-Classification-and-Logistic-Regression\" class=\"headerlink\" title=\"2. Comparison of Linear Regression, Logistic Classification and Logistic Regression\"></a>2. Comparison of Linear Regression, Logistic Classification and Logistic Regression</h2><p>将logisitic回归与之前学习的二元分类和线性回归做一对比，如图二所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a2cbd54aa0efe3a8f2f2f539a2fd595c4075971e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-2%20Comparison%20of%20Three%20Linear%20Models.png\" alt=\"Comparison of Three Linear Models\"></p>\n<center> 图二 Comparison of Three Linear Models <sup>[2]</sup></center>\n\n<p>其中分数s是在每个假设函数中都会出现的，前两个学习模型的错误衡量分别对应着0/1错误和平方错误，而logistic回归所使用的err函数应如何表示则是本节要介绍的内容。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Error-Measurement-of-Logistic-Regression-cross-entropy-error\"><a href=\"#3-Error-Measurement-of-Logistic-Regression-cross-entropy-error\" class=\"headerlink\" title=\"3. Error Measurement of Logistic Regression - cross-entropy error\"></a>3. Error Measurement of Logistic Regression - cross-entropy error</h2><p>这一节的推导需要对最大似然法和条件概率求解有一定的了解。</p>\n<blockquote>\n<p>TODO:最大似然法 和 条件概率</p>\n</blockquote>\n<p>1.首先从 Logistic Function 可以推导出下面的公式（6），花括号上半部分不难理解，是将目标函数等式左右对调的结果，而下半部分的推导也很简单，因为+1与-1的总概率为1。</p>\n<script type=\"math/tex; mode=display\">\nf(x) = P(+1|x) \\Leftrightarrow P(y|x) = \\left\\{\n\\begin{aligned}\n& f(x)  \\quad   &for \\quad y = +1\\\\\n& 1-f(x)        &for \\quad y = -1\n\\end{aligned}\n\\right.\n\\tag{6}</script><p>2.假设存在一个数据集 $D={(x_1, \\circ), (x_2, \\times), \\cdots, (x_n, \\times)}$,则通过目标函数产生此种数据集样本的概率可以用公式（7）表示。</p>\n<script type=\"math/tex; mode=display\">\nP(D) = P\\{ x_1 \\} P\\{ \\circ|x_1 \\} \\times P\\{ x_2 \\}P\\{ \\times|x_2 \\} \\times \\dots \\times P\\{ x_n \\} P\\{ \\times|x_n \\}\n\\tag{7}</script><p>3.把公式（6）的公式带入公式（7)中，可以得到公式（8）。</p>\n<script type=\"math/tex; mode=display\">\nP(D) = P\\{ x_1 \\} f(x_1) \\times P\\{ x_2 \\} (1-f(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-f(x_n))\n\\tag{7}</script><p>4.f(x)是理想的函数，而我们实际训练得到的是hypothesis h(x)，所以我们还得想办法用h(x)代替f(x)，但是这样的前提是我们假设函数h(x)对数据集与f(x)产生的可能性很大，即likelihood(似然)，即我们在之前在VC Bound的推论中，知道在数据量足够大的情况下g(x)是会接近于f(x)的，如公式（8）所示</p>\n<script type=\"math/tex; mode=display\">\nP(D) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (1-h(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-h(x_n))\n\\tag{8}</script><p>5.那么最大似然我们表示为 likelihood(h)，在代入simoid函数的特性 $1-h(x) = h(-x)$，可以得到公式（9）</p>\n<script type=\"math/tex; mode=display\">\nlikelihood(h) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n))\n\\tag{9}</script><p>6.那么最大的likelihood(h)如公式（10）所示，在计算最大的likelihood(h)时，所有$P(x_i)$的对大小没有影响，因为所有的假设函数都会乘以同样的$P(x_i)$，所以在表示的时候可以只考虑h(x)。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\max \\limits_h \\quad likelihood(logistic \\quad h)\n&\\propto P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n)) \\\\\n&\\propto  \\prod \\limits_{i=1}^n h(y_ix_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto  \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto\\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\end{align}\n\\tag{10}</script><p>7.连乘公式不容易求解最大问题，因此求其对数，此处以自然对数e为底，并代入sigmoid 方程，令$err(w,y_i,x_i) = ln(1+exp(-yw^Tx))$，如公式（11）所示，误差方程 $E_{in}$ 如公式（12)所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\max \\limits_w \\quad likelihood(w)\n&\\propto \\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\frac{1}{N} \\sum\\limits_{i=1}^{n} -ln \\theta (y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\underbrace{ \\frac{1}{N} \\sum\\limits_{i=1}^{n} err(w,y_i,x_i) }_{E_{in}(w)}  \\quad \\quad\n\\end{align}\n\\tag{11}</script><script type=\"math/tex; mode=display\">\nE_{in}(w) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln(1+exp(-yw^Tx))\n\\tag{12}</script><h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-Gradient-of-Logistic-Regression-Error\"><a href=\"#4-Gradient-of-Logistic-Regression-Error\" class=\"headerlink\" title=\"4. Gradient of Logistic Regression Error\"></a>4. Gradient of Logistic Regression Error</h2><p>上一节中，推导出logistic回归的 ，下一步的工作是寻找使得最小的权值向量w。<br>对公式（12）进行求导，可以得到公式（13），推导过程参考老师用的方法：用圈圈代替exp里面的数，用正方形代替ln里面的表达式，这样可以使得推导过程看起来更加明白</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\nE_{in}(w) &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln \\underbrace{(1+exp \\underbrace{(-yw^Tx)}_\\bigcirc)}_\\Box \\\\\n\n\n\\frac{\\partial E_{in}(w)}{\\partial w_i} &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left(\\frac{\\partial ln(\\Box)}{\\partial \\Box}\\right) \\left( \\frac{\\partial (1+exp(\\bigcirc))}{\\partial \\bigcirc} \\right) \\left( \\frac{\\partial - y_iw^Tx_i}{\\partial w_i} \\right) \\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\frac{1}{\\Box} \\right) \\left( exp(\\bigcirc) \\right) \\left( -y_i x_i \\right) \\\\\n\n                                          &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( exp(\\bigcirc) \\right) \\left(-y_i x_i \\right) \\quad \\because(\\frac{1}{\\Box}) \\approx 1\\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(\\bigcirc) \\right) \\left( -y_i x_i \\right)  \\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(-y_iw^Tx_n) \\right) \\left( -y_i x_i \\right)  \\\\\n\\end{align}\n\\tag{13}</script><p> 从公式（13）可以看出，该函数是一个 $\\theta$ 函数作为权值，关于 $(-y_nx_n)$ 的加权求和函数。如果函数的所有权值为零，，可以看出 $y_i$与所有的对应的 $w^Tx_n$ 的同号，即线性可分。</p>\n<p>但是，求该问题的解不能使用类似求解线性回归时使用的闭式解的求解方式，此最小值又该如何计算？我们可以借鉴之前PLA的方法进行迭代求解，如公式（14）</p>\n<script type=\"math/tex; mode=display\">\nw_{t+1} = w_t + \\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i\n\\tag{14}</script><p>从公式（14）可以看出，当 $sign(w_t^Tx_i)=y_n$ 的时候，向量不改变，当 $sign(w_t^Tx_i) \\neq y_n$ 的时候 要加上 $y_ix_i$，然后我们把公式（14)做一定的调整得到公式（15），其中多乘以一个1作为更新的步长，用 $\\eta$表示，PLA中更新的部分用 $\\nu$ 来代表，表示更新的方向。该算法被称为迭代优化方法（iterative optimization approach）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t + \\underbrace{1}_\\eta \\cdot\n                 \\underbrace{\\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i}_\\nu \\\\\n        &= w_t + \\eta \\cdot \\nu\n\\end{align}\n\\tag{15}</script><h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"5-Use-Gradient-Descent-to-Minimize-the-Error-of-Logistic-Regression\"><a href=\"#5-Use-Gradient-Descent-to-Minimize-the-Error-of-Logistic-Regression\" class=\"headerlink\" title=\"5. Use Gradient Descent to Minimize the Error of Logistic Regression\"></a>5. Use Gradient Descent to Minimize the Error of Logistic Regression</h2><p>上面我们根据PLA的方法求得针对Logistic回归问题的误差方程，现在我们就需要找到最佳的参数 $\\eta$ 和 $\\nu$。首先误差方程的曲线图如图三所示。$E-{in}$ 是关于权值向量 $w$ 的示意图为一个平滑且可微的凸函数，其中图像谷底的点对应着最佳 $w$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/efb59327c4bf9ddccb57959dcc04f7801267f667/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-3%20Iterative%20Optimization.png\" alt=\"Iterative Optimization\"></p>\n<center> 图三 Iterative Optimization <sup>[3]</sup></center>\n\n<p>为了分工明确，设 $\\nu$ 作为单位向量仅代表方向， $\\eta$ 代表步长表示每次更新改变的大小。在 $\\eta$ 固定的情况下，$\\nu$ 按照最陡峭的方向更改。即在 $\\eta$ 固定 $|\\nu| = 1$ 的情况下，有最快的速度找出使得 $E_{in}$ 最小的 $w$，得到公式（16）</p>\n<script type=\"math/tex; mode=display\">\n\\min\\limits_{|\\nu|=1} E_{in} \\underbrace{(w_i + \\eta \\nu)}_{w_{t+1}}\n\\tag{16}</script><p>但是公式（16）依然很难求得最小的 $w$，当 $\\eta$ 很小时，我们通过泰勒展开公式（17）可以得到公式（18），其中 $w_t$ 对应 $x_0$</p>\n<p>Tylor Expansion</p>\n<script type=\"math/tex; mode=display\">\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f^{(2)}(x_0)}{2!}(x-x_0)^2 + \\dots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)\n\\tag{17}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\n\\min\\limits_{|\\nu|=1} E_{in} (w_i + \\eta \\nu ^ T) &\\approx   E_{in}(w_t) + \\left(\\left( w_t + \\eta\\nu^T  \\right) - w_t \\right) \\frac{\\nabla E_{in}(w_t)}{1!} \\\\\n\n                                                  &= E_in(w_t) + \\eta\\nu^T \\nabla E_{in}(w_t)\n\n\\end{align}\n\\tag{18}</script><p>接着我们继续分析公式（18），其中 $E_in{w_t}$ 我们是知道的， $\\eta$ 是给定的步长， $\\nabla E_{in}(w_t)$ 也是知道的，所以求解公式（18）的最小值问题，可以转换成求解 $\\nu^T nabla E_{in}(w_t)$ 的最小值，即公式（19）</p>\n<script type=\"math/tex; mode=display\">\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t)\n\\tag{19}</script><p>两个向量最小的情况为其方向相反，即内积为负，得到公式（20）,这种情况下 $\\nu$ 是一个单位向量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t) &= -1 \\\\\n                                           \\nu &= - \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{20}</script><p>所以把公式（20）带入公式（15），可以得到公式（21）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{21}</script><p>从公式（21）可以看出，每次更新权值，w都是减少一点（具体多少要看我们谁的哪个的步长，已经误差大小），按照此种方式更新可以找到使得最小的w。此种方式称作梯度下降（gradient descent）。</p>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"6-Choose-Step-Length-for-Gradient-Descent\"><a href=\"#6-Choose-Step-Length-for-Gradient-Descent\" class=\"headerlink\" title=\"6. Choose Step Length for Gradient Descent\"></a>6. Choose Step Length for Gradient Descent</h2><p>由上面的公式（21）可以看出，w受 步长大小 $\\eta$ 和 误差大小的影响。在一定的 $\\eta$ 下，越接近谷底，纠正的也越来越小；但是如果选择的 $\\eta$ 太大，一个新就更新到对面的山峰上面去了（可能会导致纠正后误差更大），或者  $\\eta$ 太小，更新好久还没有更新到需要的准确度。所以选择适当的 $\\eta$ 很重要。如图四所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/09288541bf7cddb805bd091f25cf104e438fc179/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-4%20Choice%20of%20eta.png\" alt=\"Choice of Step Length\"></p>\n<center> 图四 Choice of Step Length <sup>[3]</sup></center>\n\n<p>因为 $\\eta$ 与 梯度大小 ${||\\nabla E_{in}(w_t)||}$ 正比，所以我们可以得到公式（22）</p>\n<script type=\"math/tex; mode=display\">\n\\eta_{new} = \\frac{ \\eta_{old}}{||\\nabla E_{in}(w_t)||}\n\\tag{22}</script><p>结合公式（21）（22），我们调整的公式（21）为（23）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}\n\\end{align}\n\\tag{21}</script><p>此时的 $\\eta$ 被称作固定的学习速率（fixed learning rate）。最终得到Logstic Regression 的步骤如下：</p>\n<ol>\n<li>设置权值w为 $w_0$，迭代次数他，并计算梯度 $\\nabla E_{in}(w_t) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\theta \\left( -y_iw_t^Tx_i \\right)\\left( -y_ix_i \\right)$</li>\n<li>不断迭代，并更新权值向量w，$w_{t+1} = w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}$，直到误差函数的导数近似于0，或者迭代一定的次数。</li>\n</ol>\n<p>Gradient Descent 劣势分析：</p>\n<ol>\n<li>不稳定:如果选择的步长太大太小，都会对算法有影响</li>\n<li>局部最优：如果函数不是凸函数的话，可能存在多个局部最优点，那样的话，Gradient Descent只能找到最近的局部最优。</li>\n<li>计算复杂度大，为O(N)，因为导数需要对所有的点进行一次遍历</li>\n</ol>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"7-Stochastic-Gradient-Descent-Another-Approach-of-Gradient-Descent\"><a href=\"#7-Stochastic-Gradient-Descent-Another-Approach-of-Gradient-Descent\" class=\"headerlink\" title=\"7. Stochastic Gradient Descent - Another Approach of Gradient Descent\"></a>7. Stochastic Gradient Descent - Another Approach of Gradient Descent</h2><p>上面讨论了 Gradient Descent,以及计算复杂度大的问题，这一节我们讨论另一种方法，可以将计算复杂度降成O(1)级别。这种方法就是Stochastic Gradient Descent（随机梯度），用符号 $\\nabla_w err(w, w_i, y_i)$ 表示， 核心思想是：通过N个样本中随机抽取一个样本点求出的梯度取代原来的期望梯度。 随机梯度值可以看做真实的梯度值加上一个噪音，使用随机梯度取代真实梯度做梯度下降的算法称作随机梯度下降 stochastic gradient descent(SGD)。在迭代次数足够多的情况下，平均的随机梯度和平均的真实梯度相差不大。真实梯度与随机梯度的关系如公式（22）所示</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_w E_{in}(w_t) = \\varepsilon_{i} \\cdot \\nabla_w err( w, x_i, y_i)\n\\tag{22}</script><p>Logistic Regression 的SGD的迭代如公式(23)所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot( \\nabla_w err( w, x_i, y_i) )(y_ix_i) \\\\\n        &= w_t + \\eta  \\underbrace{\\theta (-y_i w_t^T x_i)(y_i x_i)}_{- \\nabla_w err( w, x_i, y_i)}(y_ix_i)\n\\end{align}\n\\tag{23}</script><p>对比之前的PLA算法的公式（如公式（24）），容易发现两个公式很类似，因此logistic Regession 的SGD算法又叫”软”PLA，因为权值并没有那么绝对不是1就是0，而是一个在0~1之间的值。如果 $\\eta = 1$ 且 $w_t^T x_i \\approx \\infty$ 始终是一个很大的值，则logistic Regession 的SGD相当于是PLA算法。</p>\n<script type=\"math/tex; mode=display\">\nw_{t+1} = w_t + \\underbrace{1}_\\eta  \\underbrace{ \\left[\\left[ sign(w_tTx_i) \\neq y_i\\right]\\right]}_{\\nu}(y_ix_i)\n\\tag{24}</script><p>SGD算法关键是找出两个最佳的参数: 迭代次数 $t$ 和学习步长 $\\eta$。</p>\n<ol>\n<li>对于迭代次数 $t$ 只能假设足够步数后是已经做到足够好，即通常设置一个大的数值即可；</li>\n<li>学习步长 $\\eta$通常也很难选定(老师推荐：0.1126)。</li>\n</ol>\n<p>SGD算法的优缺点：</p>\n<ol>\n<li>优点：计算简单快速，适用于大数据或者流式数据；</li>\n<li>缺点：不稳定，需要一定的调试时间。</li>\n</ol>\n<h2 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先引入了 Logistic Regression</li>\n<li>然后对比了 Logistic Regression 和 Linear Regression, Linear Classification。</li>\n<li>接着分析Logistic Regression 的误差方程，梯度方程，并用Gradient Descent 来最小化误差，并分析如何选择步长。</li>\n</ol>\n<h2 id=\"-7\"><a href=\"#-7\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\10\\10 - 1 - Logistic Regression Problem (14-33)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\10\\10 - 2 - Logistic Regression Error (15-58)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\10\\10 - 4 - Gradient Descent (19-18)</p>\n<p><br></p>\n<h2 id=\"-8\"><a href=\"#-8\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Logistic-Regression\"><a href=\"#How-can-Machine-Learn-Logistic-Regression\" class=\"headerlink\" title=\"How can Machine Learn? - Logistic Regression\"></a>How can Machine Learn? - Logistic Regression</h1><blockquote>\n<p>这一节讨论与 Linear Regression 非常类似的Logistic Regression</p>\n</blockquote>\n<h2 id=\"1-Introduction-of-Logistic-Regression\"><a href=\"#1-Introduction-of-Logistic-Regression\" class=\"headerlink\" title=\"1. Introduction of Logistic Regression\"></a>1. Introduction of Logistic Regression</h2><p>使用二元分类分析心脏病复发问题，其输出空间只含有两项{+1，-1}，分别表示复发和不发复发。在含有噪音的情况下，目标函数f可以使用目标分布P来表示，如公式（1）所示</p>\n<script type=\"math/tex; mode=display\">\nf(x) = sign \\left( P(+1|x) - \\frac{1}{2} \\right) ∈ \\{ +1,-1 \\}\n\\tag{1}</script><p>但是实际情况，医生往往不会直接告诉病人说是否会心脏病复发，而是用概率，例如说有80%的可能性会复发，此种情况被称为软二元分类（soft binary classification），目标函数f的表达如公式（2）所示，其输出以概率的形式，在0~1之间。</p>\n<script type=\"math/tex; mode=display\">\nf(x) =  P(+1|x)  ∈ [ +1,-1 ]\n\\tag{2}</script><p>但是病人的病历里面不可能记录以前有多少多少的几率复发/不复发，而是真实的记录病人是否复发。所以概率的情况来说，复发/不复发的情况就像是噪音了(因为偏离中间的概率值大)，所以我们把实际的训练数据看成是含有噪音的理想训练数据。这种问题如何求解呢？我们可以通过输入各属性 $x=(x_0,x_1, x_2, …, x_n)$ 的加权总分数（weighted scores），如公式（3）所示</p>\n<script type=\"math/tex; mode=display\">\ns = \\sum\\limits_{i=0}^n w_ix_i = w^Tx\n\\tag{3}</script><p>这里的s的值不在 0~1之间，所以我们还需要将他进行归一化处理，那就可以使用Logistic Regression。函数用表示 $\\theta(s)$，叫做Logistic Function 或者 Sigmoid Function，如公式（4）所示。分数s越大风险越高，分数s越小风险越低。假设函数h如公式(5)所示，函数曲线的示意图如图一所示。</p>\n<script type=\"math/tex; mode=display\">\n\\theta( s ) = \\frac{ e } {e + e^z} = \\frac{1}{1+e^{-z}}\n\\tag{4}</script><script type=\"math/tex; mode=display\">\nh(x) = \\theta( w^T x ) = \\frac{ 1 } {1+e^{-w^Tx}}\n\\tag{5}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/57938b7a7b126af2ff2d5abdbea1a2fa0f6a4e1f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-1%20Logistic%20Curve.png\" alt=\"Logistic Curve\"></p>\n<center> 图一 Logistic Curve <sup>[1]</sup></center>\n\n\n<p>观察函数的图形，该函数是一个平滑（处处可微分），单调（monotonic）的S形（sigmoid）函数，因此又被称为sigmoid函数。</p>\n<p>Logistic Regression 是当前业界比较常用的机器学习方法，用于估计某种事物的可能性，应用场合如：广告预测，购物推荐，患病可能性判断等。 Logistic Regression既可以做回归，也可以做分类（二分类为主）。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Comparison-of-Linear-Regression-Logistic-Classification-and-Logistic-Regression\"><a href=\"#2-Comparison-of-Linear-Regression-Logistic-Classification-and-Logistic-Regression\" class=\"headerlink\" title=\"2. Comparison of Linear Regression, Logistic Classification and Logistic Regression\"></a>2. Comparison of Linear Regression, Logistic Classification and Logistic Regression</h2><p>将logisitic回归与之前学习的二元分类和线性回归做一对比，如图二所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a2cbd54aa0efe3a8f2f2f539a2fd595c4075971e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-2%20Comparison%20of%20Three%20Linear%20Models.png\" alt=\"Comparison of Three Linear Models\"></p>\n<center> 图二 Comparison of Three Linear Models <sup>[2]</sup></center>\n\n<p>其中分数s是在每个假设函数中都会出现的，前两个学习模型的错误衡量分别对应着0/1错误和平方错误，而logistic回归所使用的err函数应如何表示则是本节要介绍的内容。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Error-Measurement-of-Logistic-Regression-cross-entropy-error\"><a href=\"#3-Error-Measurement-of-Logistic-Regression-cross-entropy-error\" class=\"headerlink\" title=\"3. Error Measurement of Logistic Regression - cross-entropy error\"></a>3. Error Measurement of Logistic Regression - cross-entropy error</h2><p>这一节的推导需要对最大似然法和条件概率求解有一定的了解。</p>\n<blockquote>\n<p>TODO:最大似然法 和 条件概率</p>\n</blockquote>\n<p>1.首先从 Logistic Function 可以推导出下面的公式（6），花括号上半部分不难理解，是将目标函数等式左右对调的结果，而下半部分的推导也很简单，因为+1与-1的总概率为1。</p>\n<script type=\"math/tex; mode=display\">\nf(x) = P(+1|x) \\Leftrightarrow P(y|x) = \\left\\{\n\\begin{aligned}\n& f(x)  \\quad   &for \\quad y = +1\\\\\n& 1-f(x)        &for \\quad y = -1\n\\end{aligned}\n\\right.\n\\tag{6}</script><p>2.假设存在一个数据集 $D={(x_1, \\circ), (x_2, \\times), \\cdots, (x_n, \\times)}$,则通过目标函数产生此种数据集样本的概率可以用公式（7）表示。</p>\n<script type=\"math/tex; mode=display\">\nP(D) = P\\{ x_1 \\} P\\{ \\circ|x_1 \\} \\times P\\{ x_2 \\}P\\{ \\times|x_2 \\} \\times \\dots \\times P\\{ x_n \\} P\\{ \\times|x_n \\}\n\\tag{7}</script><p>3.把公式（6）的公式带入公式（7)中，可以得到公式（8）。</p>\n<script type=\"math/tex; mode=display\">\nP(D) = P\\{ x_1 \\} f(x_1) \\times P\\{ x_2 \\} (1-f(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-f(x_n))\n\\tag{7}</script><p>4.f(x)是理想的函数，而我们实际训练得到的是hypothesis h(x)，所以我们还得想办法用h(x)代替f(x)，但是这样的前提是我们假设函数h(x)对数据集与f(x)产生的可能性很大，即likelihood(似然)，即我们在之前在VC Bound的推论中，知道在数据量足够大的情况下g(x)是会接近于f(x)的，如公式（8）所示</p>\n<script type=\"math/tex; mode=display\">\nP(D) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (1-h(x_2)) \\times \\dots \\times P\\{ x_n \\} (1-h(x_n))\n\\tag{8}</script><p>5.那么最大似然我们表示为 likelihood(h)，在代入simoid函数的特性 $1-h(x) = h(-x)$，可以得到公式（9）</p>\n<script type=\"math/tex; mode=display\">\nlikelihood(h) = P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n))\n\\tag{9}</script><p>6.那么最大的likelihood(h)如公式（10）所示，在计算最大的likelihood(h)时，所有$P(x_i)$的对大小没有影响，因为所有的假设函数都会乘以同样的$P(x_i)$，所以在表示的时候可以只考虑h(x)。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\max \\limits_h \\quad likelihood(logistic \\quad h)\n&\\propto P\\{ x_1 \\} h(x_1) \\times P\\{ x_2 \\} (h(-x_2)) \\times \\dots \\times P\\{ x_n \\} (h(-x_n)) \\\\\n&\\propto  \\prod \\limits_{i=1}^n h(y_ix_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto  \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\max \\limits_w \\quad likelihood(w) &\\propto\\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n\\end{align}\n\\tag{10}</script><p>7.连乘公式不容易求解最大问题，因此求其对数，此处以自然对数e为底，并代入sigmoid 方程，令$err(w,y_i,x_i) = ln(1+exp(-yw^Tx))$，如公式（11）所示，误差方程 $E_{in}$ 如公式（12)所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\max \\limits_w \\quad likelihood(w)\n&\\propto \\max \\quad ln \\prod \\limits_{i=1}^n h(y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\frac{1}{N} \\sum\\limits_{i=1}^{n} -ln \\theta (y_iw^Tx_i) \\\\\n&\\propto \\min\\limits_w \\quad \\underbrace{ \\frac{1}{N} \\sum\\limits_{i=1}^{n} err(w,y_i,x_i) }_{E_{in}(w)}  \\quad \\quad\n\\end{align}\n\\tag{11}</script><script type=\"math/tex; mode=display\">\nE_{in}(w) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln(1+exp(-yw^Tx))\n\\tag{12}</script><h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-Gradient-of-Logistic-Regression-Error\"><a href=\"#4-Gradient-of-Logistic-Regression-Error\" class=\"headerlink\" title=\"4. Gradient of Logistic Regression Error\"></a>4. Gradient of Logistic Regression Error</h2><p>上一节中，推导出logistic回归的 ，下一步的工作是寻找使得最小的权值向量w。<br>对公式（12）进行求导，可以得到公式（13），推导过程参考老师用的方法：用圈圈代替exp里面的数，用正方形代替ln里面的表达式，这样可以使得推导过程看起来更加明白</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\nE_{in}(w) &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} ln \\underbrace{(1+exp \\underbrace{(-yw^Tx)}_\\bigcirc)}_\\Box \\\\\n\n\n\\frac{\\partial E_{in}(w)}{\\partial w_i} &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left(\\frac{\\partial ln(\\Box)}{\\partial \\Box}\\right) \\left( \\frac{\\partial (1+exp(\\bigcirc))}{\\partial \\bigcirc} \\right) \\left( \\frac{\\partial - y_iw^Tx_i}{\\partial w_i} \\right) \\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\frac{1}{\\Box} \\right) \\left( exp(\\bigcirc) \\right) \\left( -y_i x_i \\right) \\\\\n\n                                          &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( exp(\\bigcirc) \\right) \\left(-y_i x_i \\right) \\quad \\because(\\frac{1}{\\Box}) \\approx 1\\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(\\bigcirc) \\right) \\left( -y_i x_i \\right)  \\\\\n                                        &= \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\left( \\theta(-y_iw^Tx_n) \\right) \\left( -y_i x_i \\right)  \\\\\n\\end{align}\n\\tag{13}</script><p> 从公式（13）可以看出，该函数是一个 $\\theta$ 函数作为权值，关于 $(-y_nx_n)$ 的加权求和函数。如果函数的所有权值为零，，可以看出 $y_i$与所有的对应的 $w^Tx_n$ 的同号，即线性可分。</p>\n<p>但是，求该问题的解不能使用类似求解线性回归时使用的闭式解的求解方式，此最小值又该如何计算？我们可以借鉴之前PLA的方法进行迭代求解，如公式（14）</p>\n<script type=\"math/tex; mode=display\">\nw_{t+1} = w_t + \\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i\n\\tag{14}</script><p>从公式（14）可以看出，当 $sign(w_t^Tx_i)=y_n$ 的时候，向量不改变，当 $sign(w_t^Tx_i) \\neq y_n$ 的时候 要加上 $y_ix_i$，然后我们把公式（14)做一定的调整得到公式（15），其中多乘以一个1作为更新的步长，用 $\\eta$表示，PLA中更新的部分用 $\\nu$ 来代表，表示更新的方向。该算法被称为迭代优化方法（iterative optimization approach）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t + \\underbrace{1}_\\eta \\cdot\n                 \\underbrace{\\left[\\left[ sign(w_t^Tx_i) \\neq y_i \\right]\\right] y_ix_i}_\\nu \\\\\n        &= w_t + \\eta \\cdot \\nu\n\\end{align}\n\\tag{15}</script><h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"5-Use-Gradient-Descent-to-Minimize-the-Error-of-Logistic-Regression\"><a href=\"#5-Use-Gradient-Descent-to-Minimize-the-Error-of-Logistic-Regression\" class=\"headerlink\" title=\"5. Use Gradient Descent to Minimize the Error of Logistic Regression\"></a>5. Use Gradient Descent to Minimize the Error of Logistic Regression</h2><p>上面我们根据PLA的方法求得针对Logistic回归问题的误差方程，现在我们就需要找到最佳的参数 $\\eta$ 和 $\\nu$。首先误差方程的曲线图如图三所示。$E-{in}$ 是关于权值向量 $w$ 的示意图为一个平滑且可微的凸函数，其中图像谷底的点对应着最佳 $w$。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/efb59327c4bf9ddccb57959dcc04f7801267f667/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-3%20Iterative%20Optimization.png\" alt=\"Iterative Optimization\"></p>\n<center> 图三 Iterative Optimization <sup>[3]</sup></center>\n\n<p>为了分工明确，设 $\\nu$ 作为单位向量仅代表方向， $\\eta$ 代表步长表示每次更新改变的大小。在 $\\eta$ 固定的情况下，$\\nu$ 按照最陡峭的方向更改。即在 $\\eta$ 固定 $|\\nu| = 1$ 的情况下，有最快的速度找出使得 $E_{in}$ 最小的 $w$，得到公式（16）</p>\n<script type=\"math/tex; mode=display\">\n\\min\\limits_{|\\nu|=1} E_{in} \\underbrace{(w_i + \\eta \\nu)}_{w_{t+1}}\n\\tag{16}</script><p>但是公式（16）依然很难求得最小的 $w$，当 $\\eta$ 很小时，我们通过泰勒展开公式（17）可以得到公式（18），其中 $w_t$ 对应 $x_0$</p>\n<p>Tylor Expansion</p>\n<script type=\"math/tex; mode=display\">\nf(x) = f(x_0) + \\frac{f'(x_0)}{1!}(x-x_0) + \\frac{f^{(2)}(x_0)}{2!}(x-x_0)^2 + \\dots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)\n\\tag{17}</script><script type=\"math/tex; mode=display\">\n\\begin{align}\n\\min\\limits_{|\\nu|=1} E_{in} (w_i + \\eta \\nu ^ T) &\\approx   E_{in}(w_t) + \\left(\\left( w_t + \\eta\\nu^T  \\right) - w_t \\right) \\frac{\\nabla E_{in}(w_t)}{1!} \\\\\n\n                                                  &= E_in(w_t) + \\eta\\nu^T \\nabla E_{in}(w_t)\n\n\\end{align}\n\\tag{18}</script><p>接着我们继续分析公式（18），其中 $E_in{w_t}$ 我们是知道的， $\\eta$ 是给定的步长， $\\nabla E_{in}(w_t)$ 也是知道的，所以求解公式（18）的最小值问题，可以转换成求解 $\\nu^T nabla E_{in}(w_t)$ 的最小值，即公式（19）</p>\n<script type=\"math/tex; mode=display\">\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t)\n\\tag{19}</script><p>两个向量最小的情况为其方向相反，即内积为负，得到公式（20）,这种情况下 $\\nu$ 是一个单位向量</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\min\\limits_{|\\nu|=1} \\nu^T \\nabla E_{in}(w_t) &= -1 \\\\\n                                           \\nu &= - \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{20}</script><p>所以把公式（20）带入公式（15），可以得到公式（21）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot \\frac{\\nabla E_{in}(w_t)}{||\\nabla E_{in}(w_t)||}\n\\end{align}\n\\tag{21}</script><p>从公式（21）可以看出，每次更新权值，w都是减少一点（具体多少要看我们谁的哪个的步长，已经误差大小），按照此种方式更新可以找到使得最小的w。此种方式称作梯度下降（gradient descent）。</p>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"6-Choose-Step-Length-for-Gradient-Descent\"><a href=\"#6-Choose-Step-Length-for-Gradient-Descent\" class=\"headerlink\" title=\"6. Choose Step Length for Gradient Descent\"></a>6. Choose Step Length for Gradient Descent</h2><p>由上面的公式（21）可以看出，w受 步长大小 $\\eta$ 和 误差大小的影响。在一定的 $\\eta$ 下，越接近谷底，纠正的也越来越小；但是如果选择的 $\\eta$ 太大，一个新就更新到对面的山峰上面去了（可能会导致纠正后误差更大），或者  $\\eta$ 太小，更新好久还没有更新到需要的准确度。所以选择适当的 $\\eta$ 很重要。如图四所示。<br><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/09288541bf7cddb805bd091f25cf104e438fc179/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter8-4%20Choice%20of%20eta.png\" alt=\"Choice of Step Length\"></p>\n<center> 图四 Choice of Step Length <sup>[3]</sup></center>\n\n<p>因为 $\\eta$ 与 梯度大小 ${||\\nabla E_{in}(w_t)||}$ 正比，所以我们可以得到公式（22）</p>\n<script type=\"math/tex; mode=display\">\n\\eta_{new} = \\frac{ \\eta_{old}}{||\\nabla E_{in}(w_t)||}\n\\tag{22}</script><p>结合公式（21）（22），我们调整的公式（21）为（23）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}\n\\end{align}\n\\tag{21}</script><p>此时的 $\\eta$ 被称作固定的学习速率（fixed learning rate）。最终得到Logstic Regression 的步骤如下：</p>\n<ol>\n<li>设置权值w为 $w_0$，迭代次数他，并计算梯度 $\\nabla E_{in}(w_t) = \\frac{1}{N} \\sum\\limits_{i=1}^{n} \\theta \\left( -y_iw_t^Tx_i \\right)\\left( -y_ix_i \\right)$</li>\n<li>不断迭代，并更新权值向量w，$w_{t+1} = w_t - \\eta_{new} \\cdot {\\nabla E_{in}(w_t)}$，直到误差函数的导数近似于0，或者迭代一定的次数。</li>\n</ol>\n<p>Gradient Descent 劣势分析：</p>\n<ol>\n<li>不稳定:如果选择的步长太大太小，都会对算法有影响</li>\n<li>局部最优：如果函数不是凸函数的话，可能存在多个局部最优点，那样的话，Gradient Descent只能找到最近的局部最优。</li>\n<li>计算复杂度大，为O(N)，因为导数需要对所有的点进行一次遍历</li>\n</ol>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"7-Stochastic-Gradient-Descent-Another-Approach-of-Gradient-Descent\"><a href=\"#7-Stochastic-Gradient-Descent-Another-Approach-of-Gradient-Descent\" class=\"headerlink\" title=\"7. Stochastic Gradient Descent - Another Approach of Gradient Descent\"></a>7. Stochastic Gradient Descent - Another Approach of Gradient Descent</h2><p>上面讨论了 Gradient Descent,以及计算复杂度大的问题，这一节我们讨论另一种方法，可以将计算复杂度降成O(1)级别。这种方法就是Stochastic Gradient Descent（随机梯度），用符号 $\\nabla_w err(w, w_i, y_i)$ 表示， 核心思想是：通过N个样本中随机抽取一个样本点求出的梯度取代原来的期望梯度。 随机梯度值可以看做真实的梯度值加上一个噪音，使用随机梯度取代真实梯度做梯度下降的算法称作随机梯度下降 stochastic gradient descent(SGD)。在迭代次数足够多的情况下，平均的随机梯度和平均的真实梯度相差不大。真实梯度与随机梯度的关系如公式（22）所示</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_w E_{in}(w_t) = \\varepsilon_{i} \\cdot \\nabla_w err( w, x_i, y_i)\n\\tag{22}</script><p>Logistic Regression 的SGD的迭代如公式(23)所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nw_{t+1} &= w_t - \\eta \\cdot( \\nabla_w err( w, x_i, y_i) )(y_ix_i) \\\\\n        &= w_t + \\eta  \\underbrace{\\theta (-y_i w_t^T x_i)(y_i x_i)}_{- \\nabla_w err( w, x_i, y_i)}(y_ix_i)\n\\end{align}\n\\tag{23}</script><p>对比之前的PLA算法的公式（如公式（24）），容易发现两个公式很类似，因此logistic Regession 的SGD算法又叫”软”PLA，因为权值并没有那么绝对不是1就是0，而是一个在0~1之间的值。如果 $\\eta = 1$ 且 $w_t^T x_i \\approx \\infty$ 始终是一个很大的值，则logistic Regession 的SGD相当于是PLA算法。</p>\n<script type=\"math/tex; mode=display\">\nw_{t+1} = w_t + \\underbrace{1}_\\eta  \\underbrace{ \\left[\\left[ sign(w_tTx_i) \\neq y_i\\right]\\right]}_{\\nu}(y_ix_i)\n\\tag{24}</script><p>SGD算法关键是找出两个最佳的参数: 迭代次数 $t$ 和学习步长 $\\eta$。</p>\n<ol>\n<li>对于迭代次数 $t$ 只能假设足够步数后是已经做到足够好，即通常设置一个大的数值即可；</li>\n<li>学习步长 $\\eta$通常也很难选定(老师推荐：0.1126)。</li>\n</ol>\n<p>SGD算法的优缺点：</p>\n<ol>\n<li>优点：计算简单快速，适用于大数据或者流式数据；</li>\n<li>缺点：不稳定，需要一定的调试时间。</li>\n</ol>\n<h2 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先引入了 Logistic Regression</li>\n<li>然后对比了 Logistic Regression 和 Linear Regression, Linear Classification。</li>\n<li>接着分析Logistic Regression 的误差方程，梯度方程，并用Gradient Descent 来最小化误差，并分析如何选择步长。</li>\n</ol>\n<h2 id=\"-7\"><a href=\"#-7\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\10\\10 - 1 - Logistic Regression Problem (14-33)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\10\\10 - 2 - Logistic Regression Error (15-58)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\10\\10 - 4 - Gradient Descent (19-18)</p>\n<p><br></p>\n<h2 id=\"-8\"><a href=\"#-8\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"9.How can Machine Learn? - Linear Model for Classification","date":"2017-10-14T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# How can Machine Learn? - Linear Model for Classification\n\n>主要讨论 Linear Classification, Linear Reegression, Logistic Regression 在分类问题上的优劣对比，并拓展到多元分类\n\n## 1. Linear Models for Binary Classification\n\n### 1) Analyzing of Three Linear Models\n我们目前学习了Classification, Linear Reegression, Logistic Regression， 这三个模型有很多类似的地方。\n总结如图一，这里引入了s(score)作为得分，$s=w^Tx$\n\n![Linear Models Revisit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0e01f9a531b829ec48a4f3e9970fc737f62f9b56/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-1%20Linear%20Models.png)\n<center> 图一 Linear Models Revisit <sup>[1]</sup></center>\n\n从图中可以看出，Linear Classification的求解是NP-hard问题，其他两个方法都容易求解。并且可以看到他们的Hypothesis 都与 s 有关。所以可以利用这两种模型的算法近似求得二分类问题的最优权值w\n\n\n\n\n### 2) Error Functions Comparison\n\n1.首先对比3种方法的误差方程，如图二所示\n\n![Error Functions Revisit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f0bb56f85acd2e6c8500017ff01411c065136237/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-2%20Error%20Function%20Revisit.png)\n<center> 图二 Error Functions Revisit <sup>[1]</sup></center>\n\n\n\n2.根据图二的错误函数得到图三的关系图。\n\n![Visualizing Error Functions](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/89a29e7078c423404f64048c7ebbef7c33c6f534/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-3%20Visualizing%20Error%20Functions.png)\n<center> 图三 Visualizing Error Functions <sup>[1]</sup></center>\n\n从图三，我们可以得到以下几个结论：\n1. 对于 $err_{0/1}$， 在 $ys > 0$ 和 $ys < 0$ 的值相差很大\n2. $err_{CE}$ 随着 ys的增大而减小，而且无线接近于0，在 $ys > 0$ 的情况下，逐渐毕竟于 $err_{0/1}$\n3. $err_{SQR}$ 是一个凹函数，在 $ys = 1$ 的情况下，与 $err_{0/1}$ 相等\n4. $err_{0/1}$  始终小于 $err_{SQR}$， 绝大部分情况下小于 $err_{CE}$\n5. 虽然$err_{0/1}$  始终小于 $err_{SQR}$， 但是两者的差距较大\n6. 虽然$err_{0/1}$  不是全部情况下小于 $err_{CE}$，但是稍微做调整，可以实现 $err_{0/1}$  始终小于 $err_{CE}$ ，并且这两者的曲线接近，所以我们下面将想办法采用这种方式。\n\nerr为了让 $err_{0/1}$  也始终小于 $err_{CE}$ ，我们稍微做一些调整, 得到scaled CE $err_{SCE}$，如图四所示，这里只是给  $err_{CE}$ 的表达式把对数从 $log_e$ 换成 $log_2$。即从公式（1）换成公式（2）\n\n$$\nerr_{CE} = err(w,x,y) = err_{CE}(s,y) = ln(1+exp(-yw^Tx)) = ln(1+exp(-ys))\n\\tag{1}\n$$\n\n$$\nerr_{SCE} = \\frac{1}{ln2} err_{CE} = log_2(1+exp(-ys))\n\\tag{2}\n$$\n\n![Visualizing Error Functions with Scaled CE](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0277ba5bccfbf510f13974f587508dbebd21bea0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-4%20Visualizing%20Error%20Functions-scaled%20ce.png)\n<center> 图四 Visualizing Error Functions with Scaled CE <sup>[1]</sup></center>\n\n从图四中，我们可以发现，$err_{0/1}$  始终小于 $err_{SQR}$ 和 $err_{CE}$，如公式（3）所示，那么在数据量足够大的情况下，$E_{out}$ 也有类似的情况，如公式（4）所示。再接着，由于之前VC Bound的结论，我们可以得到公式（5）， 所以接下来我们就可以Logistic Regrssion的方法去解决Linear Classification的问题了\n\n$$\nE_{in}^{0/1}(w) \\leq E_{in}^{SCE}(w) = \\frac{1}{ln2} E_{in}^{CE}(w)\n\\tag{3}\n$$\n$$\nE_{out}^{0/1}(w) \\leq E_{out}^{SCE}(w) = \\frac{1}{ln2} E_{out}^{CE}(w)\n\\tag{4}\n$$\n$$\nE_{in}^{0/1}(w) \\leq E_{in}^{0/1}(w) + \\Omega ^{0/1}  \\leq E_{out}^{SCE}(w)  + \\Omega ^{0/1} = \\frac{1}{ln2} E_{out}^{CE}(w)  + \\Omega ^{0/1}\n\\tag{5}\n$$\n\n算法流程一般是在输出空间{-1, +1} 的情况下，通过线性回归和logistic回归相对应的求解方法求出最优的权值 $W_{REG}$；\n将求得的代入公式sign，得到最优假设函数。\n\n\n\n\n<br><br>\n----------------------------------\n## 2. Multiclass via Logistic Regression - OVA Algorithm\n\n实际生活中，也有很多的场合需要对多种情况进行分类：比如区分病人患了哪种类型的疾病；区分不同种类的蔬菜等。\n\n求解多类别问题可以采用二元分类的思想，将多类问题分解多多个二元分类问题，然后再分别求权值，最终分到最高权值的类别去。\n\n如图五的多类别问题，我们可以分解成图六的多个二元分类问题去求解，最终中间的公共区域，我们通过公式（6）求得最大的概率，哪一类的概率最大，就把这个点归于哪一类。\n>要注意使用软分类（因为直接分类的话中间的公共区域无法区分）\n\n$$\n\\DeclareMathOperator*{\\argmax}{argmax}\n\\begin{equation}\ng(x) = argmax_{k ∈ y} (\\theta w^T_{[k]} x)\n\\end{equation}\n\\tag{6}\n$$\n\n![Multiclass Classification](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bcdd07e44255ec22600bb992b5928f177522630e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-5%20Multiclass%20Classification.png)\n<center> 图五 Multiclass Classification <sup>[2]</sup></center>\n\n![Multiclass Classification Soft Classifiers](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3d035b4130569658df8474312c2d45e632fdfc79/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-6%20Multiclass%20Classification%20Soft%20Classifiers.png)\n<center> 图六 Multiclass Classification Soft Classifiers <sup>[2]</sup></center>\n\n这种算法称作一对多（One-Versus-All），简称为OVA，表示一个类别对其他所有类别。\n\n算法的流程如图七所示\n\n![OVA Decomposition](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/378a48ebf7a50d47599da2296c24c90e68ebd10c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-7%20OVA%20Decomposition.png)\n<center> 图七 OVA Decomposition <sup>[2]</sup></center>\n\n该算法的优点是简单有效，易于类似于logistic函数的二元分类问题扩展成多类别分类；缺点是当类别特别多时，产生了不平衡的现象（如类别特别多，则+1的数据量就很少，大部分都是-1，数据量严重不平衡）。\n\n\n\n<br><br>\n----------------------------------\n## 3. Multiclass via Binary Classification - OVO Algorithm\n上一节的最后提到OVA的方式在类别非常多的情况下，出现了训练数据严重失衡的现象，于是有另外一种方法 一对一(One-Versus-One)算法，简称OVO。同样对图五的问题做多元分类，但是这次我们一次单独考虑2种类型的点，直到两两都进行过分类（分类次数就是组合数 $C$， 例子中就是 $C_4^2 = 6$）。如图八所示。\n\n![OVO](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/15e07a2ab76b1bdb9f632949833e71c801f1371e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-8%20OVO.png)\n<center> 图八 OVO <sup>[3]</sup></center>\n\n\n算法的流程如图九所示\n\n![OVO Decomposition](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0bd54f49a461dcdf1bf0b3f50c11ebdb6401472a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-9%20OVO%20Decomposition.png)\n<center> 图九 OVO <sup>[3]</sup></center>\n\n其优点是简单有效，在做两两对比时，每次使用的不是全部训练数据，而是仅属于当前两类的训练数据，能将所有类似于二元分类的算法扩展成多元分类问题； 缺点是对比次数是 O(N^2) 即：$C_k^2$。 也就是说要分的类别越多，就需要花费更多的存储空间和运算时间。\n\n# Summary\n1. 首先我们对比了目前学到的Linear Models，由于Linear Classification的NP Hard求解问题，我们分析，最终发现可以使用Logistic Regression 的方法进行求解\n2. 接着我们讨论了Multiclass Classification的 OVA 算法，但是该算法存在问题：类型很多的时候，会出现数据不平衡的问题\n3. 最后在OVA的基础上，我们继续讨论了OVO算法，该算法克服了OVA数据不平衡的问题。但是该算法的缺点是存储空间和运算时间都比较大\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\11\\11 - 1 - Linear Models for Binary Classification (21-35)\n\n[2] 机器学习基石(台湾大学-林轩田)\\11\\11 - 3 - Multiclass via Logistic Regression (14-18)\n\n[3] 机器学习基石(台湾大学-林轩田)\\11\\11 - 4 - Multiclass via Binary Classification (11-35)\n\n<br><br>\n----------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-14-9.How can Machine Learn - Linear Model for Classification.md","raw":"---\ntitle: 9.How can Machine Learn? - Linear Model for Classification\ndate: 2017-10-14 12:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# How can Machine Learn? - Linear Model for Classification\n\n>主要讨论 Linear Classification, Linear Reegression, Logistic Regression 在分类问题上的优劣对比，并拓展到多元分类\n\n## 1. Linear Models for Binary Classification\n\n### 1) Analyzing of Three Linear Models\n我们目前学习了Classification, Linear Reegression, Logistic Regression， 这三个模型有很多类似的地方。\n总结如图一，这里引入了s(score)作为得分，$s=w^Tx$\n\n![Linear Models Revisit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0e01f9a531b829ec48a4f3e9970fc737f62f9b56/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-1%20Linear%20Models.png)\n<center> 图一 Linear Models Revisit <sup>[1]</sup></center>\n\n从图中可以看出，Linear Classification的求解是NP-hard问题，其他两个方法都容易求解。并且可以看到他们的Hypothesis 都与 s 有关。所以可以利用这两种模型的算法近似求得二分类问题的最优权值w\n\n\n\n\n### 2) Error Functions Comparison\n\n1.首先对比3种方法的误差方程，如图二所示\n\n![Error Functions Revisit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f0bb56f85acd2e6c8500017ff01411c065136237/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-2%20Error%20Function%20Revisit.png)\n<center> 图二 Error Functions Revisit <sup>[1]</sup></center>\n\n\n\n2.根据图二的错误函数得到图三的关系图。\n\n![Visualizing Error Functions](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/89a29e7078c423404f64048c7ebbef7c33c6f534/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-3%20Visualizing%20Error%20Functions.png)\n<center> 图三 Visualizing Error Functions <sup>[1]</sup></center>\n\n从图三，我们可以得到以下几个结论：\n1. 对于 $err_{0/1}$， 在 $ys > 0$ 和 $ys < 0$ 的值相差很大\n2. $err_{CE}$ 随着 ys的增大而减小，而且无线接近于0，在 $ys > 0$ 的情况下，逐渐毕竟于 $err_{0/1}$\n3. $err_{SQR}$ 是一个凹函数，在 $ys = 1$ 的情况下，与 $err_{0/1}$ 相等\n4. $err_{0/1}$  始终小于 $err_{SQR}$， 绝大部分情况下小于 $err_{CE}$\n5. 虽然$err_{0/1}$  始终小于 $err_{SQR}$， 但是两者的差距较大\n6. 虽然$err_{0/1}$  不是全部情况下小于 $err_{CE}$，但是稍微做调整，可以实现 $err_{0/1}$  始终小于 $err_{CE}$ ，并且这两者的曲线接近，所以我们下面将想办法采用这种方式。\n\nerr为了让 $err_{0/1}$  也始终小于 $err_{CE}$ ，我们稍微做一些调整, 得到scaled CE $err_{SCE}$，如图四所示，这里只是给  $err_{CE}$ 的表达式把对数从 $log_e$ 换成 $log_2$。即从公式（1）换成公式（2）\n\n$$\nerr_{CE} = err(w,x,y) = err_{CE}(s,y) = ln(1+exp(-yw^Tx)) = ln(1+exp(-ys))\n\\tag{1}\n$$\n\n$$\nerr_{SCE} = \\frac{1}{ln2} err_{CE} = log_2(1+exp(-ys))\n\\tag{2}\n$$\n\n![Visualizing Error Functions with Scaled CE](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0277ba5bccfbf510f13974f587508dbebd21bea0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-4%20Visualizing%20Error%20Functions-scaled%20ce.png)\n<center> 图四 Visualizing Error Functions with Scaled CE <sup>[1]</sup></center>\n\n从图四中，我们可以发现，$err_{0/1}$  始终小于 $err_{SQR}$ 和 $err_{CE}$，如公式（3）所示，那么在数据量足够大的情况下，$E_{out}$ 也有类似的情况，如公式（4）所示。再接着，由于之前VC Bound的结论，我们可以得到公式（5）， 所以接下来我们就可以Logistic Regrssion的方法去解决Linear Classification的问题了\n\n$$\nE_{in}^{0/1}(w) \\leq E_{in}^{SCE}(w) = \\frac{1}{ln2} E_{in}^{CE}(w)\n\\tag{3}\n$$\n$$\nE_{out}^{0/1}(w) \\leq E_{out}^{SCE}(w) = \\frac{1}{ln2} E_{out}^{CE}(w)\n\\tag{4}\n$$\n$$\nE_{in}^{0/1}(w) \\leq E_{in}^{0/1}(w) + \\Omega ^{0/1}  \\leq E_{out}^{SCE}(w)  + \\Omega ^{0/1} = \\frac{1}{ln2} E_{out}^{CE}(w)  + \\Omega ^{0/1}\n\\tag{5}\n$$\n\n算法流程一般是在输出空间{-1, +1} 的情况下，通过线性回归和logistic回归相对应的求解方法求出最优的权值 $W_{REG}$；\n将求得的代入公式sign，得到最优假设函数。\n\n\n\n\n<br><br>\n----------------------------------\n## 2. Multiclass via Logistic Regression - OVA Algorithm\n\n实际生活中，也有很多的场合需要对多种情况进行分类：比如区分病人患了哪种类型的疾病；区分不同种类的蔬菜等。\n\n求解多类别问题可以采用二元分类的思想，将多类问题分解多多个二元分类问题，然后再分别求权值，最终分到最高权值的类别去。\n\n如图五的多类别问题，我们可以分解成图六的多个二元分类问题去求解，最终中间的公共区域，我们通过公式（6）求得最大的概率，哪一类的概率最大，就把这个点归于哪一类。\n>要注意使用软分类（因为直接分类的话中间的公共区域无法区分）\n\n$$\n\\DeclareMathOperator*{\\argmax}{argmax}\n\\begin{equation}\ng(x) = argmax_{k ∈ y} (\\theta w^T_{[k]} x)\n\\end{equation}\n\\tag{6}\n$$\n\n![Multiclass Classification](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bcdd07e44255ec22600bb992b5928f177522630e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-5%20Multiclass%20Classification.png)\n<center> 图五 Multiclass Classification <sup>[2]</sup></center>\n\n![Multiclass Classification Soft Classifiers](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3d035b4130569658df8474312c2d45e632fdfc79/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-6%20Multiclass%20Classification%20Soft%20Classifiers.png)\n<center> 图六 Multiclass Classification Soft Classifiers <sup>[2]</sup></center>\n\n这种算法称作一对多（One-Versus-All），简称为OVA，表示一个类别对其他所有类别。\n\n算法的流程如图七所示\n\n![OVA Decomposition](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/378a48ebf7a50d47599da2296c24c90e68ebd10c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-7%20OVA%20Decomposition.png)\n<center> 图七 OVA Decomposition <sup>[2]</sup></center>\n\n该算法的优点是简单有效，易于类似于logistic函数的二元分类问题扩展成多类别分类；缺点是当类别特别多时，产生了不平衡的现象（如类别特别多，则+1的数据量就很少，大部分都是-1，数据量严重不平衡）。\n\n\n\n<br><br>\n----------------------------------\n## 3. Multiclass via Binary Classification - OVO Algorithm\n上一节的最后提到OVA的方式在类别非常多的情况下，出现了训练数据严重失衡的现象，于是有另外一种方法 一对一(One-Versus-One)算法，简称OVO。同样对图五的问题做多元分类，但是这次我们一次单独考虑2种类型的点，直到两两都进行过分类（分类次数就是组合数 $C$， 例子中就是 $C_4^2 = 6$）。如图八所示。\n\n![OVO](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/15e07a2ab76b1bdb9f632949833e71c801f1371e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-8%20OVO.png)\n<center> 图八 OVO <sup>[3]</sup></center>\n\n\n算法的流程如图九所示\n\n![OVO Decomposition](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0bd54f49a461dcdf1bf0b3f50c11ebdb6401472a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-9%20OVO%20Decomposition.png)\n<center> 图九 OVO <sup>[3]</sup></center>\n\n其优点是简单有效，在做两两对比时，每次使用的不是全部训练数据，而是仅属于当前两类的训练数据，能将所有类似于二元分类的算法扩展成多元分类问题； 缺点是对比次数是 O(N^2) 即：$C_k^2$。 也就是说要分的类别越多，就需要花费更多的存储空间和运算时间。\n\n# Summary\n1. 首先我们对比了目前学到的Linear Models，由于Linear Classification的NP Hard求解问题，我们分析，最终发现可以使用Logistic Regression 的方法进行求解\n2. 接着我们讨论了Multiclass Classification的 OVA 算法，但是该算法存在问题：类型很多的时候，会出现数据不平衡的问题\n3. 最后在OVA的基础上，我们继续讨论了OVO算法，该算法克服了OVA数据不平衡的问题。但是该算法的缺点是存储空间和运算时间都比较大\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\11\\11 - 1 - Linear Models for Binary Classification (21-35)\n\n[2] 机器学习基石(台湾大学-林轩田)\\11\\11 - 3 - Multiclass via Logistic Regression (14-18)\n\n[3] 机器学习基石(台湾大学-林轩田)\\11\\11 - 4 - Multiclass via Binary Classification (11-35)\n\n<br><br>\n----------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-14-9.How can Machine Learn - Linear Model for Classification","published":1,"updated":"2018-10-27T04:30:42.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bu001xe0owi5mfl839","content":"<h1 id=\"How-can-Machine-Learn-Linear-Model-for-Classification\"><a href=\"#How-can-Machine-Learn-Linear-Model-for-Classification\" class=\"headerlink\" title=\"How can Machine Learn? - Linear Model for Classification\"></a>How can Machine Learn? - Linear Model for Classification</h1><blockquote>\n<p>主要讨论 Linear Classification, Linear Reegression, Logistic Regression 在分类问题上的优劣对比，并拓展到多元分类</p>\n</blockquote>\n<h2 id=\"1-Linear-Models-for-Binary-Classification\"><a href=\"#1-Linear-Models-for-Binary-Classification\" class=\"headerlink\" title=\"1. Linear Models for Binary Classification\"></a>1. Linear Models for Binary Classification</h2><h3 id=\"1-Analyzing-of-Three-Linear-Models\"><a href=\"#1-Analyzing-of-Three-Linear-Models\" class=\"headerlink\" title=\"1) Analyzing of Three Linear Models\"></a>1) Analyzing of Three Linear Models</h3><p>我们目前学习了Classification, Linear Reegression, Logistic Regression， 这三个模型有很多类似的地方。<br>总结如图一，这里引入了s(score)作为得分，$s=w^Tx$</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0e01f9a531b829ec48a4f3e9970fc737f62f9b56/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-1%20Linear%20Models.png\" alt=\"Linear Models Revisit\"></p>\n<center> 图一 Linear Models Revisit <sup>[1]</sup></center>\n\n<p>从图中可以看出，Linear Classification的求解是NP-hard问题，其他两个方法都容易求解。并且可以看到他们的Hypothesis 都与 s 有关。所以可以利用这两种模型的算法近似求得二分类问题的最优权值w</p>\n<h3 id=\"2-Error-Functions-Comparison\"><a href=\"#2-Error-Functions-Comparison\" class=\"headerlink\" title=\"2) Error Functions Comparison\"></a>2) Error Functions Comparison</h3><p>1.首先对比3种方法的误差方程，如图二所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f0bb56f85acd2e6c8500017ff01411c065136237/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-2%20Error%20Function%20Revisit.png\" alt=\"Error Functions Revisit\"></p>\n<center> 图二 Error Functions Revisit <sup>[1]</sup></center>\n\n\n\n<p>2.根据图二的错误函数得到图三的关系图。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/89a29e7078c423404f64048c7ebbef7c33c6f534/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-3%20Visualizing%20Error%20Functions.png\" alt=\"Visualizing Error Functions\"></p>\n<center> 图三 Visualizing Error Functions <sup>[1]</sup></center>\n\n<p>从图三，我们可以得到以下几个结论：</p>\n<ol>\n<li>对于 $err_{0/1}$， 在 $ys &gt; 0$ 和 $ys &lt; 0$ 的值相差很大</li>\n<li>$err_{CE}$ 随着 ys的增大而减小，而且无线接近于0，在 $ys &gt; 0$ 的情况下，逐渐毕竟于 $err_{0/1}$</li>\n<li>$err_{SQR}$ 是一个凹函数，在 $ys = 1$ 的情况下，与 $err_{0/1}$ 相等</li>\n<li>$err_{0/1}$  始终小于 $err_{SQR}$， 绝大部分情况下小于 $err_{CE}$</li>\n<li>虽然$err_{0/1}$  始终小于 $err_{SQR}$， 但是两者的差距较大</li>\n<li>虽然$err_{0/1}$  不是全部情况下小于 $err_{CE}$，但是稍微做调整，可以实现 $err_{0/1}$  始终小于 $err_{CE}$ ，并且这两者的曲线接近，所以我们下面将想办法采用这种方式。</li>\n</ol>\n<p>err为了让 $err_{0/1}$  也始终小于 $err_{CE}$ ，我们稍微做一些调整, 得到scaled CE $err_{SCE}$，如图四所示，这里只是给  $err_{CE}$ 的表达式把对数从 $log_e$ 换成 $log_2$。即从公式（1）换成公式（2）</p>\n<script type=\"math/tex; mode=display\">\nerr_{CE} = err(w,x,y) = err_{CE}(s,y) = ln(1+exp(-yw^Tx)) = ln(1+exp(-ys))\n\\tag{1}</script><script type=\"math/tex; mode=display\">\nerr_{SCE} = \\frac{1}{ln2} err_{CE} = log_2(1+exp(-ys))\n\\tag{2}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0277ba5bccfbf510f13974f587508dbebd21bea0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-4%20Visualizing%20Error%20Functions-scaled%20ce.png\" alt=\"Visualizing Error Functions with Scaled CE\"></p>\n<center> 图四 Visualizing Error Functions with Scaled CE <sup>[1]</sup></center>\n\n<p>从图四中，我们可以发现，$err_{0/1}$  始终小于 $err_{SQR}$ 和 $err_{CE}$，如公式（3）所示，那么在数据量足够大的情况下，$E_{out}$ 也有类似的情况，如公式（4）所示。再接着，由于之前VC Bound的结论，我们可以得到公式（5）， 所以接下来我们就可以Logistic Regrssion的方法去解决Linear Classification的问题了</p>\n<script type=\"math/tex; mode=display\">\nE_{in}^{0/1}(w) \\leq E_{in}^{SCE}(w) = \\frac{1}{ln2} E_{in}^{CE}(w)\n\\tag{3}</script><script type=\"math/tex; mode=display\">\nE_{out}^{0/1}(w) \\leq E_{out}^{SCE}(w) = \\frac{1}{ln2} E_{out}^{CE}(w)\n\\tag{4}</script><script type=\"math/tex; mode=display\">\nE_{in}^{0/1}(w) \\leq E_{in}^{0/1}(w) + \\Omega ^{0/1}  \\leq E_{out}^{SCE}(w)  + \\Omega ^{0/1} = \\frac{1}{ln2} E_{out}^{CE}(w)  + \\Omega ^{0/1}\n\\tag{5}</script><p>算法流程一般是在输出空间{-1, +1} 的情况下，通过线性回归和logistic回归相对应的求解方法求出最优的权值 $W_{REG}$；<br>将求得的代入公式sign，得到最优假设函数。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Multiclass-via-Logistic-Regression-OVA-Algorithm\"><a href=\"#2-Multiclass-via-Logistic-Regression-OVA-Algorithm\" class=\"headerlink\" title=\"2. Multiclass via Logistic Regression - OVA Algorithm\"></a>2. Multiclass via Logistic Regression - OVA Algorithm</h2><p>实际生活中，也有很多的场合需要对多种情况进行分类：比如区分病人患了哪种类型的疾病；区分不同种类的蔬菜等。</p>\n<p>求解多类别问题可以采用二元分类的思想，将多类问题分解多多个二元分类问题，然后再分别求权值，最终分到最高权值的类别去。</p>\n<p>如图五的多类别问题，我们可以分解成图六的多个二元分类问题去求解，最终中间的公共区域，我们通过公式（6）求得最大的概率，哪一类的概率最大，就把这个点归于哪一类。</p>\n<blockquote>\n<p>要注意使用软分类（因为直接分类的话中间的公共区域无法区分）</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmax}{argmax}\n\\begin{equation}\ng(x) = argmax_{k ∈ y} (\\theta w^T_{[k]} x)\n\\end{equation}\n\\tag{6}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bcdd07e44255ec22600bb992b5928f177522630e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-5%20Multiclass%20Classification.png\" alt=\"Multiclass Classification\"></p>\n<center> 图五 Multiclass Classification <sup>[2]</sup></center>\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3d035b4130569658df8474312c2d45e632fdfc79/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-6%20Multiclass%20Classification%20Soft%20Classifiers.png\" alt=\"Multiclass Classification Soft Classifiers\"></p>\n<center> 图六 Multiclass Classification Soft Classifiers <sup>[2]</sup></center>\n\n<p>这种算法称作一对多（One-Versus-All），简称为OVA，表示一个类别对其他所有类别。</p>\n<p>算法的流程如图七所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/378a48ebf7a50d47599da2296c24c90e68ebd10c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-7%20OVA%20Decomposition.png\" alt=\"OVA Decomposition\"></p>\n<center> 图七 OVA Decomposition <sup>[2]</sup></center>\n\n<p>该算法的优点是简单有效，易于类似于logistic函数的二元分类问题扩展成多类别分类；缺点是当类别特别多时，产生了不平衡的现象（如类别特别多，则+1的数据量就很少，大部分都是-1，数据量严重不平衡）。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Multiclass-via-Binary-Classification-OVO-Algorithm\"><a href=\"#3-Multiclass-via-Binary-Classification-OVO-Algorithm\" class=\"headerlink\" title=\"3. Multiclass via Binary Classification - OVO Algorithm\"></a>3. Multiclass via Binary Classification - OVO Algorithm</h2><p>上一节的最后提到OVA的方式在类别非常多的情况下，出现了训练数据严重失衡的现象，于是有另外一种方法 一对一(One-Versus-One)算法，简称OVO。同样对图五的问题做多元分类，但是这次我们一次单独考虑2种类型的点，直到两两都进行过分类（分类次数就是组合数 $C$， 例子中就是 $C_4^2 = 6$）。如图八所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/15e07a2ab76b1bdb9f632949833e71c801f1371e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-8%20OVO.png\" alt=\"OVO\"></p>\n<center> 图八 OVO <sup>[3]</sup></center>\n\n\n<p>算法的流程如图九所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0bd54f49a461dcdf1bf0b3f50c11ebdb6401472a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-9%20OVO%20Decomposition.png\" alt=\"OVO Decomposition\"></p>\n<center> 图九 OVO <sup>[3]</sup></center>\n\n<p>其优点是简单有效，在做两两对比时，每次使用的不是全部训练数据，而是仅属于当前两类的训练数据，能将所有类似于二元分类的算法扩展成多元分类问题； 缺点是对比次数是 O(N^2) 即：$C_k^2$。 也就是说要分的类别越多，就需要花费更多的存储空间和运算时间。</p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先我们对比了目前学到的Linear Models，由于Linear Classification的NP Hard求解问题，我们分析，最终发现可以使用Logistic Regression 的方法进行求解</li>\n<li>接着我们讨论了Multiclass Classification的 OVA 算法，但是该算法存在问题：类型很多的时候，会出现数据不平衡的问题</li>\n<li>最后在OVA的基础上，我们继续讨论了OVO算法，该算法克服了OVA数据不平衡的问题。但是该算法的缺点是存储空间和运算时间都比较大</li>\n</ol>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\11\\11 - 1 - Linear Models for Binary Classification (21-35)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\11\\11 - 3 - Multiclass via Logistic Regression (14-18)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\11\\11 - 4 - Multiclass via Binary Classification (11-35)</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Linear-Model-for-Classification\"><a href=\"#How-can-Machine-Learn-Linear-Model-for-Classification\" class=\"headerlink\" title=\"How can Machine Learn? - Linear Model for Classification\"></a>How can Machine Learn? - Linear Model for Classification</h1><blockquote>\n<p>主要讨论 Linear Classification, Linear Reegression, Logistic Regression 在分类问题上的优劣对比，并拓展到多元分类</p>\n</blockquote>\n<h2 id=\"1-Linear-Models-for-Binary-Classification\"><a href=\"#1-Linear-Models-for-Binary-Classification\" class=\"headerlink\" title=\"1. Linear Models for Binary Classification\"></a>1. Linear Models for Binary Classification</h2><h3 id=\"1-Analyzing-of-Three-Linear-Models\"><a href=\"#1-Analyzing-of-Three-Linear-Models\" class=\"headerlink\" title=\"1) Analyzing of Three Linear Models\"></a>1) Analyzing of Three Linear Models</h3><p>我们目前学习了Classification, Linear Reegression, Logistic Regression， 这三个模型有很多类似的地方。<br>总结如图一，这里引入了s(score)作为得分，$s=w^Tx$</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0e01f9a531b829ec48a4f3e9970fc737f62f9b56/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-1%20Linear%20Models.png\" alt=\"Linear Models Revisit\"></p>\n<center> 图一 Linear Models Revisit <sup>[1]</sup></center>\n\n<p>从图中可以看出，Linear Classification的求解是NP-hard问题，其他两个方法都容易求解。并且可以看到他们的Hypothesis 都与 s 有关。所以可以利用这两种模型的算法近似求得二分类问题的最优权值w</p>\n<h3 id=\"2-Error-Functions-Comparison\"><a href=\"#2-Error-Functions-Comparison\" class=\"headerlink\" title=\"2) Error Functions Comparison\"></a>2) Error Functions Comparison</h3><p>1.首先对比3种方法的误差方程，如图二所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f0bb56f85acd2e6c8500017ff01411c065136237/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-2%20Error%20Function%20Revisit.png\" alt=\"Error Functions Revisit\"></p>\n<center> 图二 Error Functions Revisit <sup>[1]</sup></center>\n\n\n\n<p>2.根据图二的错误函数得到图三的关系图。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/89a29e7078c423404f64048c7ebbef7c33c6f534/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-3%20Visualizing%20Error%20Functions.png\" alt=\"Visualizing Error Functions\"></p>\n<center> 图三 Visualizing Error Functions <sup>[1]</sup></center>\n\n<p>从图三，我们可以得到以下几个结论：</p>\n<ol>\n<li>对于 $err_{0/1}$， 在 $ys &gt; 0$ 和 $ys &lt; 0$ 的值相差很大</li>\n<li>$err_{CE}$ 随着 ys的增大而减小，而且无线接近于0，在 $ys &gt; 0$ 的情况下，逐渐毕竟于 $err_{0/1}$</li>\n<li>$err_{SQR}$ 是一个凹函数，在 $ys = 1$ 的情况下，与 $err_{0/1}$ 相等</li>\n<li>$err_{0/1}$  始终小于 $err_{SQR}$， 绝大部分情况下小于 $err_{CE}$</li>\n<li>虽然$err_{0/1}$  始终小于 $err_{SQR}$， 但是两者的差距较大</li>\n<li>虽然$err_{0/1}$  不是全部情况下小于 $err_{CE}$，但是稍微做调整，可以实现 $err_{0/1}$  始终小于 $err_{CE}$ ，并且这两者的曲线接近，所以我们下面将想办法采用这种方式。</li>\n</ol>\n<p>err为了让 $err_{0/1}$  也始终小于 $err_{CE}$ ，我们稍微做一些调整, 得到scaled CE $err_{SCE}$，如图四所示，这里只是给  $err_{CE}$ 的表达式把对数从 $log_e$ 换成 $log_2$。即从公式（1）换成公式（2）</p>\n<script type=\"math/tex; mode=display\">\nerr_{CE} = err(w,x,y) = err_{CE}(s,y) = ln(1+exp(-yw^Tx)) = ln(1+exp(-ys))\n\\tag{1}</script><script type=\"math/tex; mode=display\">\nerr_{SCE} = \\frac{1}{ln2} err_{CE} = log_2(1+exp(-ys))\n\\tag{2}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0277ba5bccfbf510f13974f587508dbebd21bea0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-4%20Visualizing%20Error%20Functions-scaled%20ce.png\" alt=\"Visualizing Error Functions with Scaled CE\"></p>\n<center> 图四 Visualizing Error Functions with Scaled CE <sup>[1]</sup></center>\n\n<p>从图四中，我们可以发现，$err_{0/1}$  始终小于 $err_{SQR}$ 和 $err_{CE}$，如公式（3）所示，那么在数据量足够大的情况下，$E_{out}$ 也有类似的情况，如公式（4）所示。再接着，由于之前VC Bound的结论，我们可以得到公式（5）， 所以接下来我们就可以Logistic Regrssion的方法去解决Linear Classification的问题了</p>\n<script type=\"math/tex; mode=display\">\nE_{in}^{0/1}(w) \\leq E_{in}^{SCE}(w) = \\frac{1}{ln2} E_{in}^{CE}(w)\n\\tag{3}</script><script type=\"math/tex; mode=display\">\nE_{out}^{0/1}(w) \\leq E_{out}^{SCE}(w) = \\frac{1}{ln2} E_{out}^{CE}(w)\n\\tag{4}</script><script type=\"math/tex; mode=display\">\nE_{in}^{0/1}(w) \\leq E_{in}^{0/1}(w) + \\Omega ^{0/1}  \\leq E_{out}^{SCE}(w)  + \\Omega ^{0/1} = \\frac{1}{ln2} E_{out}^{CE}(w)  + \\Omega ^{0/1}\n\\tag{5}</script><p>算法流程一般是在输出空间{-1, +1} 的情况下，通过线性回归和logistic回归相对应的求解方法求出最优的权值 $W_{REG}$；<br>将求得的代入公式sign，得到最优假设函数。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Multiclass-via-Logistic-Regression-OVA-Algorithm\"><a href=\"#2-Multiclass-via-Logistic-Regression-OVA-Algorithm\" class=\"headerlink\" title=\"2. Multiclass via Logistic Regression - OVA Algorithm\"></a>2. Multiclass via Logistic Regression - OVA Algorithm</h2><p>实际生活中，也有很多的场合需要对多种情况进行分类：比如区分病人患了哪种类型的疾病；区分不同种类的蔬菜等。</p>\n<p>求解多类别问题可以采用二元分类的思想，将多类问题分解多多个二元分类问题，然后再分别求权值，最终分到最高权值的类别去。</p>\n<p>如图五的多类别问题，我们可以分解成图六的多个二元分类问题去求解，最终中间的公共区域，我们通过公式（6）求得最大的概率，哪一类的概率最大，就把这个点归于哪一类。</p>\n<blockquote>\n<p>要注意使用软分类（因为直接分类的话中间的公共区域无法区分）</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmax}{argmax}\n\\begin{equation}\ng(x) = argmax_{k ∈ y} (\\theta w^T_{[k]} x)\n\\end{equation}\n\\tag{6}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/bcdd07e44255ec22600bb992b5928f177522630e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-5%20Multiclass%20Classification.png\" alt=\"Multiclass Classification\"></p>\n<center> 图五 Multiclass Classification <sup>[2]</sup></center>\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/3d035b4130569658df8474312c2d45e632fdfc79/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-6%20Multiclass%20Classification%20Soft%20Classifiers.png\" alt=\"Multiclass Classification Soft Classifiers\"></p>\n<center> 图六 Multiclass Classification Soft Classifiers <sup>[2]</sup></center>\n\n<p>这种算法称作一对多（One-Versus-All），简称为OVA，表示一个类别对其他所有类别。</p>\n<p>算法的流程如图七所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/378a48ebf7a50d47599da2296c24c90e68ebd10c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-7%20OVA%20Decomposition.png\" alt=\"OVA Decomposition\"></p>\n<center> 图七 OVA Decomposition <sup>[2]</sup></center>\n\n<p>该算法的优点是简单有效，易于类似于logistic函数的二元分类问题扩展成多类别分类；缺点是当类别特别多时，产生了不平衡的现象（如类别特别多，则+1的数据量就很少，大部分都是-1，数据量严重不平衡）。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Multiclass-via-Binary-Classification-OVO-Algorithm\"><a href=\"#3-Multiclass-via-Binary-Classification-OVO-Algorithm\" class=\"headerlink\" title=\"3. Multiclass via Binary Classification - OVO Algorithm\"></a>3. Multiclass via Binary Classification - OVO Algorithm</h2><p>上一节的最后提到OVA的方式在类别非常多的情况下，出现了训练数据严重失衡的现象，于是有另外一种方法 一对一(One-Versus-One)算法，简称OVO。同样对图五的问题做多元分类，但是这次我们一次单独考虑2种类型的点，直到两两都进行过分类（分类次数就是组合数 $C$， 例子中就是 $C_4^2 = 6$）。如图八所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/15e07a2ab76b1bdb9f632949833e71c801f1371e/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-8%20OVO.png\" alt=\"OVO\"></p>\n<center> 图八 OVO <sup>[3]</sup></center>\n\n\n<p>算法的流程如图九所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/0bd54f49a461dcdf1bf0b3f50c11ebdb6401472a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter9-9%20OVO%20Decomposition.png\" alt=\"OVO Decomposition\"></p>\n<center> 图九 OVO <sup>[3]</sup></center>\n\n<p>其优点是简单有效，在做两两对比时，每次使用的不是全部训练数据，而是仅属于当前两类的训练数据，能将所有类似于二元分类的算法扩展成多元分类问题； 缺点是对比次数是 O(N^2) 即：$C_k^2$。 也就是说要分的类别越多，就需要花费更多的存储空间和运算时间。</p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先我们对比了目前学到的Linear Models，由于Linear Classification的NP Hard求解问题，我们分析，最终发现可以使用Logistic Regression 的方法进行求解</li>\n<li>接着我们讨论了Multiclass Classification的 OVA 算法，但是该算法存在问题：类型很多的时候，会出现数据不平衡的问题</li>\n<li>最后在OVA的基础上，我们继续讨论了OVO算法，该算法克服了OVA数据不平衡的问题。但是该算法的缺点是存储空间和运算时间都比较大</li>\n</ol>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\11\\11 - 1 - Linear Models for Binary Classification (21-35)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\11\\11 - 3 - Multiclass via Logistic Regression (14-18)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\11\\11 - 4 - Multiclass via Binary Classification (11-35)</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"10.How can Machine Learn? - Nonlinear Transformation","date":"2017-10-15T06:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# How can Machine Learn? - Nonlinear Transformation\n\n> 之前我们讨论的都是 线性模型，这一节我们讨论如何处理非线性模型的问题\n\n## 1. Quadratic Hypotheses\n线性模型可以通过VC Bound 进行约束，从而保证了数据量足够大，并且有算法找到合适的权值w。 但是对于非线性模型，我们如何处理呢？怎么能肯定的说非线性模型的机器学习是可行的呢？\n\n1.首先，非线性模型很显然是线性不可分(non-linear separable)的，如图一所示。可以看到无论怎样都不可能用一条直线分开，图中能刚好用一个圆分割，所以管它叫圈圈可分（Circular Separable），用圆的公式稍做变形可以得到这个圆的公式（1）\n\n$$\nh_{SEP}(x) = sign(-x_1^2 - x_1^2 + 0.6)\n\\tag{$1$}\n$$\n\n\n![Circular Separable](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f960da372873fcd5f4a105768a922e4c46ef95e2/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-1%20Circular%20Separable.png)\n<center> 图一 Circular Separable <sup>[1]</sup></center>\n\n\n2.类似于之前对Linear Model的公式变化，我们对公式（1）稍作调整，可以得到公式类似的结果，如公式（2)所示。 公式（2）的是z 不是 x，这个公式把 $\\{(x_n, y_n)\\}$ 转换成了线性可分的 $\\{(z_n, y_n)\\}$ ，这种转换成为特征转化(feature transform)用符号 $\\Phi$ 表示，经过特征转换后的图如图二所示。\n\n$$\n\\begin{align}\nh_{SEP}(x) &= sign(-x_1^2 - x_1^2 + 0.6) \\\\\n           &= sign( \\underbrace{0.6}_{w_0} \\times \\underbrace{1}_{x_0} + \\underbrace{(-1)}_{w_1} \\times \\underbrace{x_1^2}_{z_1} + \\underbrace{(-1)}_{w_2} \\times \\underbrace{x_2^2}_{z_2}) \\\\\n           &= sign(w^T z)\n\n\\end{align}\n\\tag{$2$}\n$$\n\n\n![Feature Transform](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/60a2e80f50a6f2be747b5585e544b06f76b598a5/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-2%20Feature%20Transform.png)\n<center> 图二 Circular Separable <sup>[1]</sup></center>\n\n\n3.那么如果能在z空间线性可分，反过来能不能在x空间圆形可分呢？\n答案是能的，下面进行证明。首先我们通过带入不同的值，得到不同情况下的空间图，如表格1所示\n\n表格1\n\nw              | 假设函数h(x)              |     形状                |\n:-------------:|:------------------------:|:-----------------------:|\n(0.6, -1, -1)  | sign(0.6-x_1^2-1x_2^2)   |   圆形（circle）         |\n(0.6, -1, -2)  | sign(0.6-x_1^2-2x_2^2)   |   椭圆形（ellipse）      |\n(0.6, -1, +2)  | sign(0.6-x_1^2+2x_2^2)   |   抛物线（hyperbola）    |\n(0.6, +1, +2)  | sign(0.6+x_1^2+2x_2^2)   |   constant:全为+1       |\n\n\n然后我们可以初步看出，可以表示多种图形，但是这并不是全部图形，比如说圆形的话是经过圆形的圆。所以我们用公式（3）来表示任意的二次曲面图形。\n$$\n\\Phi_2(x) = (1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)\n\\tag{$3$}\n$$\n\n\n可以发现无论怎样的情况，z空间都能对应到x空间去，也就是说通过算法在z空间里找到合适的权值w，就可以对应在x空间得到我们需要的图形。所以这种方法是可行的。\n\n\n<br><br>\n----------------------------------\n\n## 2. Nonlinear Transform\n上一部分我们定义了什么了二次hypothesis: z空间，那么这部分将介绍如何设计一个好的二次hypothesis来达到良好的分类效果。那么目标就是在z空间中设计一个最佳的分类线。\n\n\n整个过程就是通过特征转换的映射关系，把X空间的问题换到Z空间去做线性分类，具体步骤如下，也可以参考图三。\n\n1. 通过特征转换函数 $\\Phi$，将在X空间中不可分的数据集 $\\{(x_n, y_n)\\}$ 转换成在Z空间中可分的数据集 $\\{(z_n, y_n)\\}$ ；\n2. 使用线性分类算法通过数据集 $\\{(z_n, y_n)\\}$ 获得寻找最优权值向量 $w$；\n3. 回到X空间得到需要的返回假设函数 $g(x) = sign(w^T \\Phi(x_n))$.\n\n\n![The Nonlinear Transform Steps](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/7262c716aad5cb27418d5529cbca571437cc1d8a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-3%20The%20Nonlinear%20Transform%20Steps.png)\n<center> 图三 The Nonlinear Transform Steps <sup>[1]</sup></center>\n\n\n其实，我们以前处理机器学习问题的时候，已经做过类似的特征变换了。比如数字识别问题，我们从原始的像素值特征转换为一些实际的concrete特征，比如密度、对称性等等，这也用到了feature transform的思想。如图四所示\n\n![The Nonlinear Transform Example](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a60f915427ebe7a48375f1277bcb9787e7f4e9f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-4%20The%20Nonlinear%20Transform%20Examplepng.png)\n<center> 图四 The Nonlinear Transform Example <sup>[1]</sup></center>\n\n\n这种非线性模型算法结合了非线性转换和线性算法，因此包含两个重要的特征：转换函数和线性模型。这种求解非线性分类的思路不仅可以解决二次分类的问题，也可以用在三次感知器、三次回归，甚至多项式回归的问题上。\n\n\n\n\n<br><br>\n----------------------------------\n\n## 3. Price of Nonlinear Transform\n这一节我们要通过评估使用非线性转换说需要的代价来评估这种方法是否值得使用。下面将从2个问题去讨论：1.空间复杂度 2.能否保证机器能学习（模型的泛化能力会变差）\n\n1.首先，若x空间含有d个类别，即d个特征，特征维度是d维的，那么二次多项式个数，即z空间特征维度是如公式（4）所示\n\n$$\nd^˘ = 1 + C_d^0 + C_d^1 + d = \\frac{d+(d+3)}{2} + 1 = C_{2+d}^2\n\\tag{$4$}\n$$\n\n比如说d为2的时候，那么二次多项式为 $(1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)$ 共6个\n进一步推导到更高维度Q的多项式，那么z空间的特征维度如公式（5）所示\n\n$$\nd^˘ = C_{Q+d}^Q = C_{Q+d}^d = O(Q^d)\n\\tag{$5$}\n$$\n\n由上式可以看出，计算z域特征维度个数的时间复杂度是Q的d次方，随着Q和d的增大，计算量会变得很大。同时，空间复杂度也大。也就是说，这种特征变换的一个代价是计算的时间、空间复杂度都比较大。如图五所示\n\n![Model Complexity Price](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1b76f6dba7e21f6ed3b2000ed8a8927b1116b820/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-5%20Model%20Complexity%20Price.png)\n<center> 图五 Model Complexity Price <sup>[2]</sup></center>\n\n\n2.另一方面，关于泛化能力的问题，因为z域中特征个数随着Q和d增加变得很大，同时权重w也会增大，即自由度增加，VC Dimension增大。根据之前课程的讨论：VC Dimension过大，模型的泛化能力会比较差。\n下面举例说明。首先分类结果如图六所示\n\n![Generalization Issue](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2893a8362c568f176df9527a0f6b1e518e6fea3c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-6%20Generalization%20Issue.png)\n<center> 图六 Generalization Issue <sup>[2]</sup></center>\n\n上图中，左边是用直线进行线性分类，存在分类错误的点；右边是用四次曲线进行非线性分类，所有点都分类正确。\n\n1. 从分类结果来看：单从平面上这些训练数据来看，右边的图（四次曲线）的分类效果更好\n2. 但是从泛化能力来看的话：四次曲线模型很容易带来过拟合（下一节会讨论）的问题，虽然它的 $E_{in}$ 比较小，从泛化能力上来说，还是左边的分类器更好一些。也就是说VC Dimension过大会带来过拟合问题，$d^˘+1$ 不能太大了。\n\n\n\n\n> 那么如何选择合适的Q，来保证不会出现过拟合问题，确保模型的泛化能力足够强呢？一般情况下，为了尽量减少特征自由度，我们会根据训练样本的分布情况，人为地减少、省略一些项。但是，这种人为地删减特征又将会带来一些“自我分析”代价，虽然对训练样本分类效果好，但是对训练样本外的样本，不一定效果好。所以，一般情况下，还是要保存所有的多项式特征，避免对训练样本的人为选择。这种人为的判断好坏已经是人类的大脑处理过后的结果，在机器学习中应避免。\n\n\n\n\n<br><br>\n----------------------------------\n\n## 4. Structured Hypothesis Sets\n这一节我们先通过举例，最终总结出从x空间到y空间的多项式变化\n\n1.首先如果d为1维的话，如公式（6)所示，多项式中只有常数项\n\n$$\n\\Phi_0(x) = (1)\n\\tag{$6$}\n$$\n\n2.如果d为2维的时候，如公式（7）所示，多项式中包含了1维的多项式\n\n$$\n\\Phi_1(x) = ( \\Phi_0(x), x_1, x_2, \\dots, x_d)\n\\tag{$7$}\n$$\n\n3.如果d为3维的时候，如公式（8）所示，多项式中包含了2维的多项式\n\n$$\n\\Phi_2(x) = ( \\Phi_1(x), x_1^2, x1x_2, \\dots, x_d^2)\n\\tag{$8$}\n$$\n\n\n3.以此类推，如果d为Q维的时候，如公式（9）所示，多项式中包含了(Q-1)维的多项式\n\n$$\n\\Phi_Q(x) = ( \\Phi_{Q-1}(x), x_1^{Q}, x1^{Q-1} x_2, \\dots, x_d^Q)\n\\tag{$9$}\n$$\n\n并且可以发现，不能维度的Hypotheses存在以下关系，如公式（10）所示\n\n$$\nH_{\\Phi_0}  \\subset H_{\\Phi_1}  \\subset H_{\\Phi_2}  \\subset \\dots  \\subset H_{\\Phi_Q}\n\\tag{$9$}\n$$\n\n上述过程如图七所示，另外我们把这种结构叫做Structured Hypothesis Sets，如图八所示\n\n![Polynomial Transform Revisited](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b837983ab4b54c354be992a602f91cb714b9e885/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-7%20Polynomial%20Transform%20Revisited.png)\n<center> 图七 Polynomial Transform Revisited <sup>[3]</sup></center>\n\n![Structured Hypothesis Sets](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/767617e08ac2b435e9abc3efe9e1dc5495194e5f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-8%20Structured%20Hypothesis%20Set.png)\n<center> 图八 Structured Hypothesis Sets <sup>[3]</sup></center>\n\n从图八可以看出，随着变换多项式的阶数d增大，虽然 $E_{in}$ 逐渐减小，但是model complexity会逐渐增大，造成 $E_{out}$ 很大，所以阶数不能太高。所以，如果选择的阶数d很大，确实能使 $E_{in}$ 接近于0，但是泛化能力通常很差，我们把这种情况叫做tempting sin。所以，一般最合适的做法是先从低阶开始，如先选择一阶hypothesis，看看 $E_{in}$ 是否足够小，如果 $E_{in}$ 足够小的话就选择一阶，如果 $E_{in}$ 太大不满足需求，那么我们就逐次增加阶数，直到满足要求为止。也就是说，尽量选择低阶的hypothes，这样才能得到较强的泛化能力。\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先介绍了非线性分类模型，通过非线性的特征变化，将非线性模型映射到一个线性空间进行相信分类。\n2. 接着分析非线性模型的代价：时间和空间复杂度高，而且随着特征纬度的增加，模型的泛化能力变差\n3. 最后我们通过数学分析得到如何能在使用非线性转化的过程中，尽可能的提高模型泛化能力：尽可能使用简单模型（低阶）。\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\12\\12 - 1 - Quadratic Hypothesis (23-47)\n\n[2] 机器学习基石(台湾大学-林轩田)\\12\\12 - 3 - Price of Nonlinear Transform (15-37)\n\n[3] 机器学习基石(台湾大学-林轩田)\\12\\12 - 4 - Structured Hypothesis Sets (09-36)\n\n<br><br>\n----------------------------------","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-15-10.How can Machine Learn - Nonlinear Transformation.md","raw":"---\ntitle: 10.How can Machine Learn? - Nonlinear Transformation\ndate: 2017-10-15 14:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# How can Machine Learn? - Nonlinear Transformation\n\n> 之前我们讨论的都是 线性模型，这一节我们讨论如何处理非线性模型的问题\n\n## 1. Quadratic Hypotheses\n线性模型可以通过VC Bound 进行约束，从而保证了数据量足够大，并且有算法找到合适的权值w。 但是对于非线性模型，我们如何处理呢？怎么能肯定的说非线性模型的机器学习是可行的呢？\n\n1.首先，非线性模型很显然是线性不可分(non-linear separable)的，如图一所示。可以看到无论怎样都不可能用一条直线分开，图中能刚好用一个圆分割，所以管它叫圈圈可分（Circular Separable），用圆的公式稍做变形可以得到这个圆的公式（1）\n\n$$\nh_{SEP}(x) = sign(-x_1^2 - x_1^2 + 0.6)\n\\tag{$1$}\n$$\n\n\n![Circular Separable](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f960da372873fcd5f4a105768a922e4c46ef95e2/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-1%20Circular%20Separable.png)\n<center> 图一 Circular Separable <sup>[1]</sup></center>\n\n\n2.类似于之前对Linear Model的公式变化，我们对公式（1）稍作调整，可以得到公式类似的结果，如公式（2)所示。 公式（2）的是z 不是 x，这个公式把 $\\{(x_n, y_n)\\}$ 转换成了线性可分的 $\\{(z_n, y_n)\\}$ ，这种转换成为特征转化(feature transform)用符号 $\\Phi$ 表示，经过特征转换后的图如图二所示。\n\n$$\n\\begin{align}\nh_{SEP}(x) &= sign(-x_1^2 - x_1^2 + 0.6) \\\\\n           &= sign( \\underbrace{0.6}_{w_0} \\times \\underbrace{1}_{x_0} + \\underbrace{(-1)}_{w_1} \\times \\underbrace{x_1^2}_{z_1} + \\underbrace{(-1)}_{w_2} \\times \\underbrace{x_2^2}_{z_2}) \\\\\n           &= sign(w^T z)\n\n\\end{align}\n\\tag{$2$}\n$$\n\n\n![Feature Transform](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/60a2e80f50a6f2be747b5585e544b06f76b598a5/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-2%20Feature%20Transform.png)\n<center> 图二 Circular Separable <sup>[1]</sup></center>\n\n\n3.那么如果能在z空间线性可分，反过来能不能在x空间圆形可分呢？\n答案是能的，下面进行证明。首先我们通过带入不同的值，得到不同情况下的空间图，如表格1所示\n\n表格1\n\nw              | 假设函数h(x)              |     形状                |\n:-------------:|:------------------------:|:-----------------------:|\n(0.6, -1, -1)  | sign(0.6-x_1^2-1x_2^2)   |   圆形（circle）         |\n(0.6, -1, -2)  | sign(0.6-x_1^2-2x_2^2)   |   椭圆形（ellipse）      |\n(0.6, -1, +2)  | sign(0.6-x_1^2+2x_2^2)   |   抛物线（hyperbola）    |\n(0.6, +1, +2)  | sign(0.6+x_1^2+2x_2^2)   |   constant:全为+1       |\n\n\n然后我们可以初步看出，可以表示多种图形，但是这并不是全部图形，比如说圆形的话是经过圆形的圆。所以我们用公式（3）来表示任意的二次曲面图形。\n$$\n\\Phi_2(x) = (1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)\n\\tag{$3$}\n$$\n\n\n可以发现无论怎样的情况，z空间都能对应到x空间去，也就是说通过算法在z空间里找到合适的权值w，就可以对应在x空间得到我们需要的图形。所以这种方法是可行的。\n\n\n<br><br>\n----------------------------------\n\n## 2. Nonlinear Transform\n上一部分我们定义了什么了二次hypothesis: z空间，那么这部分将介绍如何设计一个好的二次hypothesis来达到良好的分类效果。那么目标就是在z空间中设计一个最佳的分类线。\n\n\n整个过程就是通过特征转换的映射关系，把X空间的问题换到Z空间去做线性分类，具体步骤如下，也可以参考图三。\n\n1. 通过特征转换函数 $\\Phi$，将在X空间中不可分的数据集 $\\{(x_n, y_n)\\}$ 转换成在Z空间中可分的数据集 $\\{(z_n, y_n)\\}$ ；\n2. 使用线性分类算法通过数据集 $\\{(z_n, y_n)\\}$ 获得寻找最优权值向量 $w$；\n3. 回到X空间得到需要的返回假设函数 $g(x) = sign(w^T \\Phi(x_n))$.\n\n\n![The Nonlinear Transform Steps](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/7262c716aad5cb27418d5529cbca571437cc1d8a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-3%20The%20Nonlinear%20Transform%20Steps.png)\n<center> 图三 The Nonlinear Transform Steps <sup>[1]</sup></center>\n\n\n其实，我们以前处理机器学习问题的时候，已经做过类似的特征变换了。比如数字识别问题，我们从原始的像素值特征转换为一些实际的concrete特征，比如密度、对称性等等，这也用到了feature transform的思想。如图四所示\n\n![The Nonlinear Transform Example](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a60f915427ebe7a48375f1277bcb9787e7f4e9f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-4%20The%20Nonlinear%20Transform%20Examplepng.png)\n<center> 图四 The Nonlinear Transform Example <sup>[1]</sup></center>\n\n\n这种非线性模型算法结合了非线性转换和线性算法，因此包含两个重要的特征：转换函数和线性模型。这种求解非线性分类的思路不仅可以解决二次分类的问题，也可以用在三次感知器、三次回归，甚至多项式回归的问题上。\n\n\n\n\n<br><br>\n----------------------------------\n\n## 3. Price of Nonlinear Transform\n这一节我们要通过评估使用非线性转换说需要的代价来评估这种方法是否值得使用。下面将从2个问题去讨论：1.空间复杂度 2.能否保证机器能学习（模型的泛化能力会变差）\n\n1.首先，若x空间含有d个类别，即d个特征，特征维度是d维的，那么二次多项式个数，即z空间特征维度是如公式（4）所示\n\n$$\nd^˘ = 1 + C_d^0 + C_d^1 + d = \\frac{d+(d+3)}{2} + 1 = C_{2+d}^2\n\\tag{$4$}\n$$\n\n比如说d为2的时候，那么二次多项式为 $(1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)$ 共6个\n进一步推导到更高维度Q的多项式，那么z空间的特征维度如公式（5）所示\n\n$$\nd^˘ = C_{Q+d}^Q = C_{Q+d}^d = O(Q^d)\n\\tag{$5$}\n$$\n\n由上式可以看出，计算z域特征维度个数的时间复杂度是Q的d次方，随着Q和d的增大，计算量会变得很大。同时，空间复杂度也大。也就是说，这种特征变换的一个代价是计算的时间、空间复杂度都比较大。如图五所示\n\n![Model Complexity Price](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1b76f6dba7e21f6ed3b2000ed8a8927b1116b820/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-5%20Model%20Complexity%20Price.png)\n<center> 图五 Model Complexity Price <sup>[2]</sup></center>\n\n\n2.另一方面，关于泛化能力的问题，因为z域中特征个数随着Q和d增加变得很大，同时权重w也会增大，即自由度增加，VC Dimension增大。根据之前课程的讨论：VC Dimension过大，模型的泛化能力会比较差。\n下面举例说明。首先分类结果如图六所示\n\n![Generalization Issue](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2893a8362c568f176df9527a0f6b1e518e6fea3c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-6%20Generalization%20Issue.png)\n<center> 图六 Generalization Issue <sup>[2]</sup></center>\n\n上图中，左边是用直线进行线性分类，存在分类错误的点；右边是用四次曲线进行非线性分类，所有点都分类正确。\n\n1. 从分类结果来看：单从平面上这些训练数据来看，右边的图（四次曲线）的分类效果更好\n2. 但是从泛化能力来看的话：四次曲线模型很容易带来过拟合（下一节会讨论）的问题，虽然它的 $E_{in}$ 比较小，从泛化能力上来说，还是左边的分类器更好一些。也就是说VC Dimension过大会带来过拟合问题，$d^˘+1$ 不能太大了。\n\n\n\n\n> 那么如何选择合适的Q，来保证不会出现过拟合问题，确保模型的泛化能力足够强呢？一般情况下，为了尽量减少特征自由度，我们会根据训练样本的分布情况，人为地减少、省略一些项。但是，这种人为地删减特征又将会带来一些“自我分析”代价，虽然对训练样本分类效果好，但是对训练样本外的样本，不一定效果好。所以，一般情况下，还是要保存所有的多项式特征，避免对训练样本的人为选择。这种人为的判断好坏已经是人类的大脑处理过后的结果，在机器学习中应避免。\n\n\n\n\n<br><br>\n----------------------------------\n\n## 4. Structured Hypothesis Sets\n这一节我们先通过举例，最终总结出从x空间到y空间的多项式变化\n\n1.首先如果d为1维的话，如公式（6)所示，多项式中只有常数项\n\n$$\n\\Phi_0(x) = (1)\n\\tag{$6$}\n$$\n\n2.如果d为2维的时候，如公式（7）所示，多项式中包含了1维的多项式\n\n$$\n\\Phi_1(x) = ( \\Phi_0(x), x_1, x_2, \\dots, x_d)\n\\tag{$7$}\n$$\n\n3.如果d为3维的时候，如公式（8）所示，多项式中包含了2维的多项式\n\n$$\n\\Phi_2(x) = ( \\Phi_1(x), x_1^2, x1x_2, \\dots, x_d^2)\n\\tag{$8$}\n$$\n\n\n3.以此类推，如果d为Q维的时候，如公式（9）所示，多项式中包含了(Q-1)维的多项式\n\n$$\n\\Phi_Q(x) = ( \\Phi_{Q-1}(x), x_1^{Q}, x1^{Q-1} x_2, \\dots, x_d^Q)\n\\tag{$9$}\n$$\n\n并且可以发现，不能维度的Hypotheses存在以下关系，如公式（10）所示\n\n$$\nH_{\\Phi_0}  \\subset H_{\\Phi_1}  \\subset H_{\\Phi_2}  \\subset \\dots  \\subset H_{\\Phi_Q}\n\\tag{$9$}\n$$\n\n上述过程如图七所示，另外我们把这种结构叫做Structured Hypothesis Sets，如图八所示\n\n![Polynomial Transform Revisited](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b837983ab4b54c354be992a602f91cb714b9e885/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-7%20Polynomial%20Transform%20Revisited.png)\n<center> 图七 Polynomial Transform Revisited <sup>[3]</sup></center>\n\n![Structured Hypothesis Sets](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/767617e08ac2b435e9abc3efe9e1dc5495194e5f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-8%20Structured%20Hypothesis%20Set.png)\n<center> 图八 Structured Hypothesis Sets <sup>[3]</sup></center>\n\n从图八可以看出，随着变换多项式的阶数d增大，虽然 $E_{in}$ 逐渐减小，但是model complexity会逐渐增大，造成 $E_{out}$ 很大，所以阶数不能太高。所以，如果选择的阶数d很大，确实能使 $E_{in}$ 接近于0，但是泛化能力通常很差，我们把这种情况叫做tempting sin。所以，一般最合适的做法是先从低阶开始，如先选择一阶hypothesis，看看 $E_{in}$ 是否足够小，如果 $E_{in}$ 足够小的话就选择一阶，如果 $E_{in}$ 太大不满足需求，那么我们就逐次增加阶数，直到满足要求为止。也就是说，尽量选择低阶的hypothes，这样才能得到较强的泛化能力。\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先介绍了非线性分类模型，通过非线性的特征变化，将非线性模型映射到一个线性空间进行相信分类。\n2. 接着分析非线性模型的代价：时间和空间复杂度高，而且随着特征纬度的增加，模型的泛化能力变差\n3. 最后我们通过数学分析得到如何能在使用非线性转化的过程中，尽可能的提高模型泛化能力：尽可能使用简单模型（低阶）。\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\12\\12 - 1 - Quadratic Hypothesis (23-47)\n\n[2] 机器学习基石(台湾大学-林轩田)\\12\\12 - 3 - Price of Nonlinear Transform (15-37)\n\n[3] 机器学习基石(台湾大学-林轩田)\\12\\12 - 4 - Structured Hypothesis Sets (09-36)\n\n<br><br>\n----------------------------------","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-15-10.How can Machine Learn - Nonlinear Transformation","published":1,"updated":"2018-10-27T04:30:42.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bw0021e0ow3pd6wdkl","content":"<h1 id=\"How-can-Machine-Learn-Nonlinear-Transformation\"><a href=\"#How-can-Machine-Learn-Nonlinear-Transformation\" class=\"headerlink\" title=\"How can Machine Learn? - Nonlinear Transformation\"></a>How can Machine Learn? - Nonlinear Transformation</h1><blockquote>\n<p>之前我们讨论的都是 线性模型，这一节我们讨论如何处理非线性模型的问题</p>\n</blockquote>\n<h2 id=\"1-Quadratic-Hypotheses\"><a href=\"#1-Quadratic-Hypotheses\" class=\"headerlink\" title=\"1. Quadratic Hypotheses\"></a>1. Quadratic Hypotheses</h2><p>线性模型可以通过VC Bound 进行约束，从而保证了数据量足够大，并且有算法找到合适的权值w。 但是对于非线性模型，我们如何处理呢？怎么能肯定的说非线性模型的机器学习是可行的呢？</p>\n<p>1.首先，非线性模型很显然是线性不可分(non-linear separable)的，如图一所示。可以看到无论怎样都不可能用一条直线分开，图中能刚好用一个圆分割，所以管它叫圈圈可分（Circular Separable），用圆的公式稍做变形可以得到这个圆的公式（1）</p>\n<script type=\"math/tex; mode=display\">\nh_{SEP}(x) = sign(-x_1^2 - x_1^2 + 0.6)\n\\tag{$1$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f960da372873fcd5f4a105768a922e4c46ef95e2/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-1%20Circular%20Separable.png\" alt=\"Circular Separable\"></p>\n<center> 图一 Circular Separable <sup>[1]</sup></center>\n\n\n<p>2.类似于之前对Linear Model的公式变化，我们对公式（1）稍作调整，可以得到公式类似的结果，如公式（2)所示。 公式（2）的是z 不是 x，这个公式把 $\\{(x_n, y_n)\\}$ 转换成了线性可分的 $\\{(z_n, y_n)\\}$ ，这种转换成为特征转化(feature transform)用符号 $\\Phi$ 表示，经过特征转换后的图如图二所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh_{SEP}(x) &= sign(-x_1^2 - x_1^2 + 0.6) \\\\\n           &= sign( \\underbrace{0.6}_{w_0} \\times \\underbrace{1}_{x_0} + \\underbrace{(-1)}_{w_1} \\times \\underbrace{x_1^2}_{z_1} + \\underbrace{(-1)}_{w_2} \\times \\underbrace{x_2^2}_{z_2}) \\\\\n           &= sign(w^T z)\n\n\\end{align}\n\\tag{$2$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/60a2e80f50a6f2be747b5585e544b06f76b598a5/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-2%20Feature%20Transform.png\" alt=\"Feature Transform\"></p>\n<center> 图二 Circular Separable <sup>[1]</sup></center>\n\n\n<p>3.那么如果能在z空间线性可分，反过来能不能在x空间圆形可分呢？<br>答案是能的，下面进行证明。首先我们通过带入不同的值，得到不同情况下的空间图，如表格1所示</p>\n<p>表格1</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">w</th>\n<th style=\"text-align:center\">假设函数h(x)</th>\n<th style=\"text-align:center\">形状</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">(0.6, -1, -1)</td>\n<td style=\"text-align:center\">sign(0.6-x_1^2-1x_2^2)</td>\n<td style=\"text-align:center\">圆形（circle）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(0.6, -1, -2)</td>\n<td style=\"text-align:center\">sign(0.6-x_1^2-2x_2^2)</td>\n<td style=\"text-align:center\">椭圆形（ellipse）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(0.6, -1, +2)</td>\n<td style=\"text-align:center\">sign(0.6-x_1^2+2x_2^2)</td>\n<td style=\"text-align:center\">抛物线（hyperbola）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(0.6, +1, +2)</td>\n<td style=\"text-align:center\">sign(0.6+x_1^2+2x_2^2)</td>\n<td style=\"text-align:center\">constant:全为+1</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>然后我们可以初步看出，可以表示多种图形，但是这并不是全部图形，比如说圆形的话是经过圆形的圆。所以我们用公式（3）来表示任意的二次曲面图形。</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_2(x) = (1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)\n\\tag{$3$}</script><p>可以发现无论怎样的情况，z空间都能对应到x空间去，也就是说通过算法在z空间里找到合适的权值w，就可以对应在x空间得到我们需要的图形。所以这种方法是可行的。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Nonlinear-Transform\"><a href=\"#2-Nonlinear-Transform\" class=\"headerlink\" title=\"2. Nonlinear Transform\"></a>2. Nonlinear Transform</h2><p>上一部分我们定义了什么了二次hypothesis: z空间，那么这部分将介绍如何设计一个好的二次hypothesis来达到良好的分类效果。那么目标就是在z空间中设计一个最佳的分类线。</p>\n<p>整个过程就是通过特征转换的映射关系，把X空间的问题换到Z空间去做线性分类，具体步骤如下，也可以参考图三。</p>\n<ol>\n<li>通过特征转换函数 $\\Phi$，将在X空间中不可分的数据集 $\\{(x_n, y_n)\\}$ 转换成在Z空间中可分的数据集 $\\{(z_n, y_n)\\}$ ；</li>\n<li>使用线性分类算法通过数据集 $\\{(z_n, y_n)\\}$ 获得寻找最优权值向量 $w$；</li>\n<li>回到X空间得到需要的返回假设函数 $g(x) = sign(w^T \\Phi(x_n))$.</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/7262c716aad5cb27418d5529cbca571437cc1d8a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-3%20The%20Nonlinear%20Transform%20Steps.png\" alt=\"The Nonlinear Transform Steps\"></p>\n<center> 图三 The Nonlinear Transform Steps <sup>[1]</sup></center>\n\n\n<p>其实，我们以前处理机器学习问题的时候，已经做过类似的特征变换了。比如数字识别问题，我们从原始的像素值特征转换为一些实际的concrete特征，比如密度、对称性等等，这也用到了feature transform的思想。如图四所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a60f915427ebe7a48375f1277bcb9787e7f4e9f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-4%20The%20Nonlinear%20Transform%20Examplepng.png\" alt=\"The Nonlinear Transform Example\"></p>\n<center> 图四 The Nonlinear Transform Example <sup>[1]</sup></center>\n\n\n<p>这种非线性模型算法结合了非线性转换和线性算法，因此包含两个重要的特征：转换函数和线性模型。这种求解非线性分类的思路不仅可以解决二次分类的问题，也可以用在三次感知器、三次回归，甚至多项式回归的问题上。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Price-of-Nonlinear-Transform\"><a href=\"#3-Price-of-Nonlinear-Transform\" class=\"headerlink\" title=\"3. Price of Nonlinear Transform\"></a>3. Price of Nonlinear Transform</h2><p>这一节我们要通过评估使用非线性转换说需要的代价来评估这种方法是否值得使用。下面将从2个问题去讨论：1.空间复杂度 2.能否保证机器能学习（模型的泛化能力会变差）</p>\n<p>1.首先，若x空间含有d个类别，即d个特征，特征维度是d维的，那么二次多项式个数，即z空间特征维度是如公式（4）所示</p>\n<script type=\"math/tex; mode=display\">\nd^˘ = 1 + C_d^0 + C_d^1 + d = \\frac{d+(d+3)}{2} + 1 = C_{2+d}^2\n\\tag{$4$}</script><p>比如说d为2的时候，那么二次多项式为 $(1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)$ 共6个<br>进一步推导到更高维度Q的多项式，那么z空间的特征维度如公式（5）所示</p>\n<script type=\"math/tex; mode=display\">\nd^˘ = C_{Q+d}^Q = C_{Q+d}^d = O(Q^d)\n\\tag{$5$}</script><p>由上式可以看出，计算z域特征维度个数的时间复杂度是Q的d次方，随着Q和d的增大，计算量会变得很大。同时，空间复杂度也大。也就是说，这种特征变换的一个代价是计算的时间、空间复杂度都比较大。如图五所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1b76f6dba7e21f6ed3b2000ed8a8927b1116b820/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-5%20Model%20Complexity%20Price.png\" alt=\"Model Complexity Price\"></p>\n<center> 图五 Model Complexity Price <sup>[2]</sup></center>\n\n\n<p>2.另一方面，关于泛化能力的问题，因为z域中特征个数随着Q和d增加变得很大，同时权重w也会增大，即自由度增加，VC Dimension增大。根据之前课程的讨论：VC Dimension过大，模型的泛化能力会比较差。<br>下面举例说明。首先分类结果如图六所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2893a8362c568f176df9527a0f6b1e518e6fea3c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-6%20Generalization%20Issue.png\" alt=\"Generalization Issue\"></p>\n<center> 图六 Generalization Issue <sup>[2]</sup></center>\n\n<p>上图中，左边是用直线进行线性分类，存在分类错误的点；右边是用四次曲线进行非线性分类，所有点都分类正确。</p>\n<ol>\n<li>从分类结果来看：单从平面上这些训练数据来看，右边的图（四次曲线）的分类效果更好</li>\n<li>但是从泛化能力来看的话：四次曲线模型很容易带来过拟合（下一节会讨论）的问题，虽然它的 $E_{in}$ 比较小，从泛化能力上来说，还是左边的分类器更好一些。也就是说VC Dimension过大会带来过拟合问题，$d^˘+1$ 不能太大了。</li>\n</ol>\n<blockquote>\n<p>那么如何选择合适的Q，来保证不会出现过拟合问题，确保模型的泛化能力足够强呢？一般情况下，为了尽量减少特征自由度，我们会根据训练样本的分布情况，人为地减少、省略一些项。但是，这种人为地删减特征又将会带来一些“自我分析”代价，虽然对训练样本分类效果好，但是对训练样本外的样本，不一定效果好。所以，一般情况下，还是要保存所有的多项式特征，避免对训练样本的人为选择。这种人为的判断好坏已经是人类的大脑处理过后的结果，在机器学习中应避免。</p>\n</blockquote>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-Structured-Hypothesis-Sets\"><a href=\"#4-Structured-Hypothesis-Sets\" class=\"headerlink\" title=\"4. Structured Hypothesis Sets\"></a>4. Structured Hypothesis Sets</h2><p>这一节我们先通过举例，最终总结出从x空间到y空间的多项式变化</p>\n<p>1.首先如果d为1维的话，如公式（6)所示，多项式中只有常数项</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_0(x) = (1)\n\\tag{$6$}</script><p>2.如果d为2维的时候，如公式（7）所示，多项式中包含了1维的多项式</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_1(x) = ( \\Phi_0(x), x_1, x_2, \\dots, x_d)\n\\tag{$7$}</script><p>3.如果d为3维的时候，如公式（8）所示，多项式中包含了2维的多项式</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_2(x) = ( \\Phi_1(x), x_1^2, x1x_2, \\dots, x_d^2)\n\\tag{$8$}</script><p>3.以此类推，如果d为Q维的时候，如公式（9）所示，多项式中包含了(Q-1)维的多项式</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_Q(x) = ( \\Phi_{Q-1}(x), x_1^{Q}, x1^{Q-1} x_2, \\dots, x_d^Q)\n\\tag{$9$}</script><p>并且可以发现，不能维度的Hypotheses存在以下关系，如公式（10）所示</p>\n<script type=\"math/tex; mode=display\">\nH_{\\Phi_0}  \\subset H_{\\Phi_1}  \\subset H_{\\Phi_2}  \\subset \\dots  \\subset H_{\\Phi_Q}\n\\tag{$9$}</script><p>上述过程如图七所示，另外我们把这种结构叫做Structured Hypothesis Sets，如图八所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b837983ab4b54c354be992a602f91cb714b9e885/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-7%20Polynomial%20Transform%20Revisited.png\" alt=\"Polynomial Transform Revisited\"></p>\n<center> 图七 Polynomial Transform Revisited <sup>[3]</sup></center>\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/767617e08ac2b435e9abc3efe9e1dc5495194e5f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-8%20Structured%20Hypothesis%20Set.png\" alt=\"Structured Hypothesis Sets\"></p>\n<center> 图八 Structured Hypothesis Sets <sup>[3]</sup></center>\n\n<p>从图八可以看出，随着变换多项式的阶数d增大，虽然 $E_{in}$ 逐渐减小，但是model complexity会逐渐增大，造成 $E_{out}$ 很大，所以阶数不能太高。所以，如果选择的阶数d很大，确实能使 $E_{in}$ 接近于0，但是泛化能力通常很差，我们把这种情况叫做tempting sin。所以，一般最合适的做法是先从低阶开始，如先选择一阶hypothesis，看看 $E_{in}$ 是否足够小，如果 $E_{in}$ 足够小的话就选择一阶，如果 $E_{in}$ 太大不满足需求，那么我们就逐次增加阶数，直到满足要求为止。也就是说，尽量选择低阶的hypothes，这样才能得到较强的泛化能力。</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了非线性分类模型，通过非线性的特征变化，将非线性模型映射到一个线性空间进行相信分类。</li>\n<li>接着分析非线性模型的代价：时间和空间复杂度高，而且随着特征纬度的增加，模型的泛化能力变差</li>\n<li>最后我们通过数学分析得到如何能在使用非线性转化的过程中，尽可能的提高模型泛化能力：尽可能使用简单模型（低阶）。</li>\n</ol>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\12\\12 - 1 - Quadratic Hypothesis (23-47)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\12\\12 - 3 - Price of Nonlinear Transform (15-37)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\12\\12 - 4 - Structured Hypothesis Sets (09-36)</p>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Nonlinear-Transformation\"><a href=\"#How-can-Machine-Learn-Nonlinear-Transformation\" class=\"headerlink\" title=\"How can Machine Learn? - Nonlinear Transformation\"></a>How can Machine Learn? - Nonlinear Transformation</h1><blockquote>\n<p>之前我们讨论的都是 线性模型，这一节我们讨论如何处理非线性模型的问题</p>\n</blockquote>\n<h2 id=\"1-Quadratic-Hypotheses\"><a href=\"#1-Quadratic-Hypotheses\" class=\"headerlink\" title=\"1. Quadratic Hypotheses\"></a>1. Quadratic Hypotheses</h2><p>线性模型可以通过VC Bound 进行约束，从而保证了数据量足够大，并且有算法找到合适的权值w。 但是对于非线性模型，我们如何处理呢？怎么能肯定的说非线性模型的机器学习是可行的呢？</p>\n<p>1.首先，非线性模型很显然是线性不可分(non-linear separable)的，如图一所示。可以看到无论怎样都不可能用一条直线分开，图中能刚好用一个圆分割，所以管它叫圈圈可分（Circular Separable），用圆的公式稍做变形可以得到这个圆的公式（1）</p>\n<script type=\"math/tex; mode=display\">\nh_{SEP}(x) = sign(-x_1^2 - x_1^2 + 0.6)\n\\tag{$1$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/f960da372873fcd5f4a105768a922e4c46ef95e2/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-1%20Circular%20Separable.png\" alt=\"Circular Separable\"></p>\n<center> 图一 Circular Separable <sup>[1]</sup></center>\n\n\n<p>2.类似于之前对Linear Model的公式变化，我们对公式（1）稍作调整，可以得到公式类似的结果，如公式（2)所示。 公式（2）的是z 不是 x，这个公式把 $\\{(x_n, y_n)\\}$ 转换成了线性可分的 $\\{(z_n, y_n)\\}$ ，这种转换成为特征转化(feature transform)用符号 $\\Phi$ 表示，经过特征转换后的图如图二所示。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh_{SEP}(x) &= sign(-x_1^2 - x_1^2 + 0.6) \\\\\n           &= sign( \\underbrace{0.6}_{w_0} \\times \\underbrace{1}_{x_0} + \\underbrace{(-1)}_{w_1} \\times \\underbrace{x_1^2}_{z_1} + \\underbrace{(-1)}_{w_2} \\times \\underbrace{x_2^2}_{z_2}) \\\\\n           &= sign(w^T z)\n\n\\end{align}\n\\tag{$2$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/60a2e80f50a6f2be747b5585e544b06f76b598a5/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-2%20Feature%20Transform.png\" alt=\"Feature Transform\"></p>\n<center> 图二 Circular Separable <sup>[1]</sup></center>\n\n\n<p>3.那么如果能在z空间线性可分，反过来能不能在x空间圆形可分呢？<br>答案是能的，下面进行证明。首先我们通过带入不同的值，得到不同情况下的空间图，如表格1所示</p>\n<p>表格1</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">w</th>\n<th style=\"text-align:center\">假设函数h(x)</th>\n<th style=\"text-align:center\">形状</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">(0.6, -1, -1)</td>\n<td style=\"text-align:center\">sign(0.6-x_1^2-1x_2^2)</td>\n<td style=\"text-align:center\">圆形（circle）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(0.6, -1, -2)</td>\n<td style=\"text-align:center\">sign(0.6-x_1^2-2x_2^2)</td>\n<td style=\"text-align:center\">椭圆形（ellipse）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(0.6, -1, +2)</td>\n<td style=\"text-align:center\">sign(0.6-x_1^2+2x_2^2)</td>\n<td style=\"text-align:center\">抛物线（hyperbola）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">(0.6, +1, +2)</td>\n<td style=\"text-align:center\">sign(0.6+x_1^2+2x_2^2)</td>\n<td style=\"text-align:center\">constant:全为+1</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>然后我们可以初步看出，可以表示多种图形，但是这并不是全部图形，比如说圆形的话是经过圆形的圆。所以我们用公式（3）来表示任意的二次曲面图形。</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_2(x) = (1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)\n\\tag{$3$}</script><p>可以发现无论怎样的情况，z空间都能对应到x空间去，也就是说通过算法在z空间里找到合适的权值w，就可以对应在x空间得到我们需要的图形。所以这种方法是可行的。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Nonlinear-Transform\"><a href=\"#2-Nonlinear-Transform\" class=\"headerlink\" title=\"2. Nonlinear Transform\"></a>2. Nonlinear Transform</h2><p>上一部分我们定义了什么了二次hypothesis: z空间，那么这部分将介绍如何设计一个好的二次hypothesis来达到良好的分类效果。那么目标就是在z空间中设计一个最佳的分类线。</p>\n<p>整个过程就是通过特征转换的映射关系，把X空间的问题换到Z空间去做线性分类，具体步骤如下，也可以参考图三。</p>\n<ol>\n<li>通过特征转换函数 $\\Phi$，将在X空间中不可分的数据集 $\\{(x_n, y_n)\\}$ 转换成在Z空间中可分的数据集 $\\{(z_n, y_n)\\}$ ；</li>\n<li>使用线性分类算法通过数据集 $\\{(z_n, y_n)\\}$ 获得寻找最优权值向量 $w$；</li>\n<li>回到X空间得到需要的返回假设函数 $g(x) = sign(w^T \\Phi(x_n))$.</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/7262c716aad5cb27418d5529cbca571437cc1d8a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-3%20The%20Nonlinear%20Transform%20Steps.png\" alt=\"The Nonlinear Transform Steps\"></p>\n<center> 图三 The Nonlinear Transform Steps <sup>[1]</sup></center>\n\n\n<p>其实，我们以前处理机器学习问题的时候，已经做过类似的特征变换了。比如数字识别问题，我们从原始的像素值特征转换为一些实际的concrete特征，比如密度、对称性等等，这也用到了feature transform的思想。如图四所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a60f915427ebe7a48375f1277bcb9787e7f4e9f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-4%20The%20Nonlinear%20Transform%20Examplepng.png\" alt=\"The Nonlinear Transform Example\"></p>\n<center> 图四 The Nonlinear Transform Example <sup>[1]</sup></center>\n\n\n<p>这种非线性模型算法结合了非线性转换和线性算法，因此包含两个重要的特征：转换函数和线性模型。这种求解非线性分类的思路不仅可以解决二次分类的问题，也可以用在三次感知器、三次回归，甚至多项式回归的问题上。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Price-of-Nonlinear-Transform\"><a href=\"#3-Price-of-Nonlinear-Transform\" class=\"headerlink\" title=\"3. Price of Nonlinear Transform\"></a>3. Price of Nonlinear Transform</h2><p>这一节我们要通过评估使用非线性转换说需要的代价来评估这种方法是否值得使用。下面将从2个问题去讨论：1.空间复杂度 2.能否保证机器能学习（模型的泛化能力会变差）</p>\n<p>1.首先，若x空间含有d个类别，即d个特征，特征维度是d维的，那么二次多项式个数，即z空间特征维度是如公式（4）所示</p>\n<script type=\"math/tex; mode=display\">\nd^˘ = 1 + C_d^0 + C_d^1 + d = \\frac{d+(d+3)}{2} + 1 = C_{2+d}^2\n\\tag{$4$}</script><p>比如说d为2的时候，那么二次多项式为 $(1, x_1, x_2, x_1^2, x_2^2, x_1x_2, x_2^2)$ 共6个<br>进一步推导到更高维度Q的多项式，那么z空间的特征维度如公式（5）所示</p>\n<script type=\"math/tex; mode=display\">\nd^˘ = C_{Q+d}^Q = C_{Q+d}^d = O(Q^d)\n\\tag{$5$}</script><p>由上式可以看出，计算z域特征维度个数的时间复杂度是Q的d次方，随着Q和d的增大，计算量会变得很大。同时，空间复杂度也大。也就是说，这种特征变换的一个代价是计算的时间、空间复杂度都比较大。如图五所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1b76f6dba7e21f6ed3b2000ed8a8927b1116b820/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-5%20Model%20Complexity%20Price.png\" alt=\"Model Complexity Price\"></p>\n<center> 图五 Model Complexity Price <sup>[2]</sup></center>\n\n\n<p>2.另一方面，关于泛化能力的问题，因为z域中特征个数随着Q和d增加变得很大，同时权重w也会增大，即自由度增加，VC Dimension增大。根据之前课程的讨论：VC Dimension过大，模型的泛化能力会比较差。<br>下面举例说明。首先分类结果如图六所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/2893a8362c568f176df9527a0f6b1e518e6fea3c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-6%20Generalization%20Issue.png\" alt=\"Generalization Issue\"></p>\n<center> 图六 Generalization Issue <sup>[2]</sup></center>\n\n<p>上图中，左边是用直线进行线性分类，存在分类错误的点；右边是用四次曲线进行非线性分类，所有点都分类正确。</p>\n<ol>\n<li>从分类结果来看：单从平面上这些训练数据来看，右边的图（四次曲线）的分类效果更好</li>\n<li>但是从泛化能力来看的话：四次曲线模型很容易带来过拟合（下一节会讨论）的问题，虽然它的 $E_{in}$ 比较小，从泛化能力上来说，还是左边的分类器更好一些。也就是说VC Dimension过大会带来过拟合问题，$d^˘+1$ 不能太大了。</li>\n</ol>\n<blockquote>\n<p>那么如何选择合适的Q，来保证不会出现过拟合问题，确保模型的泛化能力足够强呢？一般情况下，为了尽量减少特征自由度，我们会根据训练样本的分布情况，人为地减少、省略一些项。但是，这种人为地删减特征又将会带来一些“自我分析”代价，虽然对训练样本分类效果好，但是对训练样本外的样本，不一定效果好。所以，一般情况下，还是要保存所有的多项式特征，避免对训练样本的人为选择。这种人为的判断好坏已经是人类的大脑处理过后的结果，在机器学习中应避免。</p>\n</blockquote>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-Structured-Hypothesis-Sets\"><a href=\"#4-Structured-Hypothesis-Sets\" class=\"headerlink\" title=\"4. Structured Hypothesis Sets\"></a>4. Structured Hypothesis Sets</h2><p>这一节我们先通过举例，最终总结出从x空间到y空间的多项式变化</p>\n<p>1.首先如果d为1维的话，如公式（6)所示，多项式中只有常数项</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_0(x) = (1)\n\\tag{$6$}</script><p>2.如果d为2维的时候，如公式（7）所示，多项式中包含了1维的多项式</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_1(x) = ( \\Phi_0(x), x_1, x_2, \\dots, x_d)\n\\tag{$7$}</script><p>3.如果d为3维的时候，如公式（8）所示，多项式中包含了2维的多项式</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_2(x) = ( \\Phi_1(x), x_1^2, x1x_2, \\dots, x_d^2)\n\\tag{$8$}</script><p>3.以此类推，如果d为Q维的时候，如公式（9）所示，多项式中包含了(Q-1)维的多项式</p>\n<script type=\"math/tex; mode=display\">\n\\Phi_Q(x) = ( \\Phi_{Q-1}(x), x_1^{Q}, x1^{Q-1} x_2, \\dots, x_d^Q)\n\\tag{$9$}</script><p>并且可以发现，不能维度的Hypotheses存在以下关系，如公式（10）所示</p>\n<script type=\"math/tex; mode=display\">\nH_{\\Phi_0}  \\subset H_{\\Phi_1}  \\subset H_{\\Phi_2}  \\subset \\dots  \\subset H_{\\Phi_Q}\n\\tag{$9$}</script><p>上述过程如图七所示，另外我们把这种结构叫做Structured Hypothesis Sets，如图八所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b837983ab4b54c354be992a602f91cb714b9e885/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-7%20Polynomial%20Transform%20Revisited.png\" alt=\"Polynomial Transform Revisited\"></p>\n<center> 图七 Polynomial Transform Revisited <sup>[3]</sup></center>\n\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/767617e08ac2b435e9abc3efe9e1dc5495194e5f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter10-8%20Structured%20Hypothesis%20Set.png\" alt=\"Structured Hypothesis Sets\"></p>\n<center> 图八 Structured Hypothesis Sets <sup>[3]</sup></center>\n\n<p>从图八可以看出，随着变换多项式的阶数d增大，虽然 $E_{in}$ 逐渐减小，但是model complexity会逐渐增大，造成 $E_{out}$ 很大，所以阶数不能太高。所以，如果选择的阶数d很大，确实能使 $E_{in}$ 接近于0，但是泛化能力通常很差，我们把这种情况叫做tempting sin。所以，一般最合适的做法是先从低阶开始，如先选择一阶hypothesis，看看 $E_{in}$ 是否足够小，如果 $E_{in}$ 足够小的话就选择一阶，如果 $E_{in}$ 太大不满足需求，那么我们就逐次增加阶数，直到满足要求为止。也就是说，尽量选择低阶的hypothes，这样才能得到较强的泛化能力。</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了非线性分类模型，通过非线性的特征变化，将非线性模型映射到一个线性空间进行相信分类。</li>\n<li>接着分析非线性模型的代价：时间和空间复杂度高，而且随着特征纬度的增加，模型的泛化能力变差</li>\n<li>最后我们通过数学分析得到如何能在使用非线性转化的过程中，尽可能的提高模型泛化能力：尽可能使用简单模型（低阶）。</li>\n</ol>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\12\\12 - 1 - Quadratic Hypothesis (23-47)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\12\\12 - 3 - Price of Nonlinear Transform (15-37)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\12\\12 - 4 - Structured Hypothesis Sets (09-36)</p>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"11.How can Machine Learn Better? - Overfitting and Solution","date":"2017-10-16T07:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# How can Machine Learn Better? - Overfitting and Solution\n\n## 1. What is Overfitting?\n上一节最后，我们提到了如果线性模型的模型复杂度太大的话，可能会引起Overfitting。同样的很明显会有Underfitting的情况。\n> 那什么是Overfitting，Underfitting呢？\n\n首先根据名字，Overfitting：over fitting，就是在fitting的时候太over了。我们用线性模型去分类/回归处理数据的过程就是一个fitting的过程，所以也就是说我们处理过头了。同理Underfitting就是处理不够到位。\n\n> 那么什么时候才是处理过头呢？什么时候才是处理不到位呢？\n\n就是在处理相对简单的问题的时候用了相对复杂的模型去处理。\n就是在处理相对复杂的问题的时候用了相对简单的模型去处理。\n\n我们用下面的例子来进行说明\n1.首先例子如图一所示(这里用的是Ng的图，因为在林老师的ppt中没找到很好地图同时体现Underfit, good fit overfit)。左图是欠拟合(underfit)，中间的图四好的拟合（good fit），右图是过度拟合（overfit）。单纯从拟合结果来看：明显左边和中间的图 $E_{in}$ 比右图要大。但是从泛化好坏来看，显然左图和中间的图要比右图好。\n假如我们考虑good fit分类出错的点为噪音点（noise），那么Overfit的模型就会受到了严重的干扰。\n\n![Underfit, Good Fit and Overfit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/faeeb6ed9dd42d75c5b4b20d6b9a592c92ce7ece/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-3%20Underfit%20Good%20Fit%20and%20Overfit.png)\n<center> 图一 Underfit, Good Fit and Overfit <sup>[1]</sup></center>\n\n\n2. 接着我们回头看之前总结的VC Dimension 的曲线， 如图二所示。\n\n![Learning Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/17974844acd6bf87d8cf4d68731f9d4cade5b450/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-2%20Learning%20Curve%20.png)\n\n图二 Learning Curve <sup>[1]</sup>\n\n\n图中可以看到在VC Dimension变大时，$E_{in}$ 变小， 但 $E_{out}$ 先变小后变大，而过拟合和欠拟合的情况的主要区别就在于 $E_{out}$ 的变化情况，具体解释如下：\n- 过拟合（Overfitting）发生在VC Dimension较大时，$E_{in}$ 太小， 但 $E_{out}$ 太大（即VC Dimension 太大了） ，表示在训练样本上拟合做的很好，$E_{in}$ 太小，但是过度了，使得泛化能力变差， $E_{out}$ 很大\n- 欠拟合（Underfitting）发生在在VC Dimension较小时，$E_{in}$ 太大，同时 $E_{out}$ 太大（即VC Dimension 太小了），表示在训练样本上拟合做不够好，$E_{in}$ 太大，虽然泛化能力很强（即 $E_{out}$ 也太大）\n\n关于如何解决欠拟合的问题之前也讨论过： 从低到高不断地提高多项式次数，使得VC维提高，达到拟合的效果。\n但过拟合的问题更为复杂，下面会更深入的探讨。\n\n\n3. 下面的图三，可以让我们更加直观的看到overfitting造成的问题\n\n![Cases of Overfitting](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cbdf35a9838985e1f889100ce389c4d316cc0f0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-4%20Case%20of%20Overfitting.png)\n<center> 图三 Case of Overfitting <sup>[2]</sup></center>\n\n从图中可以看到，Overfitting的 $E_{in}$ 都比 good-fit的要低，但是 $E_{out}$ 却很高（泛化能力差）。\n\n\n总结起来有3个因数会导致Overfitting的发生：\n- data size N 太小\n- noise 太多\n- VC Dimension太大\n\n<br><br>\n----------------------------------\n\n\n## 2. Dealing with Overfitting\n上一节我们提出了overfitting并作了分析。总结出3个因数会导致overfitting，下面根据这3个因数，我们有5种方法帮助我们避免overfitting的发生。\n\n- 使用简单的模型(start from simple model)，逐次增加模型的复杂度 - 防止 VC Dimension太大\n- 进行数据清理/裁剪(data cleaning/pruning) - 防止 noise 太多\n- 数据提示（data hinting） - 防止 data size N 太小\n- 正则化（regularization） - 防止 VC Dimension太大\n- 确认（validation） - 提取一部分的数据作为测试集，提前估计模型的泛化强度\n\n\n下面我们分别介绍这5种方法，其中前三种方法比较简单，这里不做深入讨论，而 Regularization 和 Validation 较复杂，这里会用比较多的笔墨进行讨论。\n\n### 1) Start from Simple Model\n上一章中也提到过，由于VC Dimension太大的话，导致 $E_{in}$ 变小的同时 $E_{out}$却在变大。所以我们如果从d=1阶的模型开始debug，如果 $E_{in}$ 不符合要求，那么我们增大d为2阶，然后在进行debug，以此类推，直到 $E_{in}$ 符合我们要求位置，这个时候的 VC Dimension 不会很大，而且我们也得到泛化能力相对较强的模型。\n\n\n### 2) Data Cleaning/Pruning\nData cleaning/pruning就是对训练数据集里label有明显错误的样本进行清理（data cleaning）或者裁剪（pruning)。data cleaning/pruning关键在于如何准确寻找label错误的点或者是noise的点。而处理的方法为\n- 纠正，即数据清理（data cleaning）的方式处理该情况；\n- 删除错误样本，即数据裁剪（data pruning）的方式处理。\n\n处理措施很简单，但是发现样本是噪音或离群点却比较困难。\n\n\n### 3) Data Hinting\nData hinting是针对N不够大的情况，通过data hinting的方法就可以对已知的样本进行简单的处理、变换，从而获得更多的样本。比如说：数字分类问题，可以对已知的数字图片进行轻微的平移或者旋转，从而得到更多的数据，达到扩大训练集的目的。这种通过data hinting得到的数据叫做：virtual examples。\n\n> 需要注意的是，新获取的virtual examples可能不再是iid某个distribution。所以新构建的virtual examples要尽量合理，且是独立同分布的。\n\n### 4) Regularization\nRegularization（正规化）处理属于penalized方法的一种，通过正规化的处理来对原来的方程加上一个regularizer进行penalize，从而使得过渡复杂的模型，变得没那么复杂。\n\n关于Regularization 的讨论看此链接:\n[12. 机器学习基石-How can Machine Learn Better? - Regularization](https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/)\n\n### 5) Validation\n这个是目前最常用的方法之一，通过提前把一部分的数据拿出来作为测试集，因为测试集是随机取出来的，而将来实际的应用中，数据也大体和测试集出入不大，所以用这种方法，可以提前得到实际应用的时候，模型的错误 $E_{out}$ 通过这个作为衡量模型是否合格的条件之一。\n\n关于Validation 的讨论看此链接\n\n[13. 机器学习基石-How can Machine Learn Better? - Validation](https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/)\n\n\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1.首先介绍了Overfitting和Underfitting的概念。\n\n2.接着我们着重分析Overfitting，总结了产生Overfitting的原因：\n\n- data size N 太小\n\n- noise 太多\n\n- VC Dimension太大\n\n3.最后我们分析如何最大程度的避免Overfitting。在solution中.\n\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\13\\13 - 1 - What is Overfitting- (10-45)\n\n[2] 机器学习基石(台湾大学-林轩田)\\13\\13 - 2 - The Role of Noise and Data Size (13-36)\n\n\n<br><br>\n----------------------------------\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-16-11.How can Machine Learn Better - Overfitting and Solution.md","raw":"---\ntitle: 11.How can Machine Learn Better? - Overfitting and Solution\ndate: 2017-10-16 15:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# How can Machine Learn Better? - Overfitting and Solution\n\n## 1. What is Overfitting?\n上一节最后，我们提到了如果线性模型的模型复杂度太大的话，可能会引起Overfitting。同样的很明显会有Underfitting的情况。\n> 那什么是Overfitting，Underfitting呢？\n\n首先根据名字，Overfitting：over fitting，就是在fitting的时候太over了。我们用线性模型去分类/回归处理数据的过程就是一个fitting的过程，所以也就是说我们处理过头了。同理Underfitting就是处理不够到位。\n\n> 那么什么时候才是处理过头呢？什么时候才是处理不到位呢？\n\n就是在处理相对简单的问题的时候用了相对复杂的模型去处理。\n就是在处理相对复杂的问题的时候用了相对简单的模型去处理。\n\n我们用下面的例子来进行说明\n1.首先例子如图一所示(这里用的是Ng的图，因为在林老师的ppt中没找到很好地图同时体现Underfit, good fit overfit)。左图是欠拟合(underfit)，中间的图四好的拟合（good fit），右图是过度拟合（overfit）。单纯从拟合结果来看：明显左边和中间的图 $E_{in}$ 比右图要大。但是从泛化好坏来看，显然左图和中间的图要比右图好。\n假如我们考虑good fit分类出错的点为噪音点（noise），那么Overfit的模型就会受到了严重的干扰。\n\n![Underfit, Good Fit and Overfit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/faeeb6ed9dd42d75c5b4b20d6b9a592c92ce7ece/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-3%20Underfit%20Good%20Fit%20and%20Overfit.png)\n<center> 图一 Underfit, Good Fit and Overfit <sup>[1]</sup></center>\n\n\n2. 接着我们回头看之前总结的VC Dimension 的曲线， 如图二所示。\n\n![Learning Curve](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/17974844acd6bf87d8cf4d68731f9d4cade5b450/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-2%20Learning%20Curve%20.png)\n\n图二 Learning Curve <sup>[1]</sup>\n\n\n图中可以看到在VC Dimension变大时，$E_{in}$ 变小， 但 $E_{out}$ 先变小后变大，而过拟合和欠拟合的情况的主要区别就在于 $E_{out}$ 的变化情况，具体解释如下：\n- 过拟合（Overfitting）发生在VC Dimension较大时，$E_{in}$ 太小， 但 $E_{out}$ 太大（即VC Dimension 太大了） ，表示在训练样本上拟合做的很好，$E_{in}$ 太小，但是过度了，使得泛化能力变差， $E_{out}$ 很大\n- 欠拟合（Underfitting）发生在在VC Dimension较小时，$E_{in}$ 太大，同时 $E_{out}$ 太大（即VC Dimension 太小了），表示在训练样本上拟合做不够好，$E_{in}$ 太大，虽然泛化能力很强（即 $E_{out}$ 也太大）\n\n关于如何解决欠拟合的问题之前也讨论过： 从低到高不断地提高多项式次数，使得VC维提高，达到拟合的效果。\n但过拟合的问题更为复杂，下面会更深入的探讨。\n\n\n3. 下面的图三，可以让我们更加直观的看到overfitting造成的问题\n\n![Cases of Overfitting](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cbdf35a9838985e1f889100ce389c4d316cc0f0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-4%20Case%20of%20Overfitting.png)\n<center> 图三 Case of Overfitting <sup>[2]</sup></center>\n\n从图中可以看到，Overfitting的 $E_{in}$ 都比 good-fit的要低，但是 $E_{out}$ 却很高（泛化能力差）。\n\n\n总结起来有3个因数会导致Overfitting的发生：\n- data size N 太小\n- noise 太多\n- VC Dimension太大\n\n<br><br>\n----------------------------------\n\n\n## 2. Dealing with Overfitting\n上一节我们提出了overfitting并作了分析。总结出3个因数会导致overfitting，下面根据这3个因数，我们有5种方法帮助我们避免overfitting的发生。\n\n- 使用简单的模型(start from simple model)，逐次增加模型的复杂度 - 防止 VC Dimension太大\n- 进行数据清理/裁剪(data cleaning/pruning) - 防止 noise 太多\n- 数据提示（data hinting） - 防止 data size N 太小\n- 正则化（regularization） - 防止 VC Dimension太大\n- 确认（validation） - 提取一部分的数据作为测试集，提前估计模型的泛化强度\n\n\n下面我们分别介绍这5种方法，其中前三种方法比较简单，这里不做深入讨论，而 Regularization 和 Validation 较复杂，这里会用比较多的笔墨进行讨论。\n\n### 1) Start from Simple Model\n上一章中也提到过，由于VC Dimension太大的话，导致 $E_{in}$ 变小的同时 $E_{out}$却在变大。所以我们如果从d=1阶的模型开始debug，如果 $E_{in}$ 不符合要求，那么我们增大d为2阶，然后在进行debug，以此类推，直到 $E_{in}$ 符合我们要求位置，这个时候的 VC Dimension 不会很大，而且我们也得到泛化能力相对较强的模型。\n\n\n### 2) Data Cleaning/Pruning\nData cleaning/pruning就是对训练数据集里label有明显错误的样本进行清理（data cleaning）或者裁剪（pruning)。data cleaning/pruning关键在于如何准确寻找label错误的点或者是noise的点。而处理的方法为\n- 纠正，即数据清理（data cleaning）的方式处理该情况；\n- 删除错误样本，即数据裁剪（data pruning）的方式处理。\n\n处理措施很简单，但是发现样本是噪音或离群点却比较困难。\n\n\n### 3) Data Hinting\nData hinting是针对N不够大的情况，通过data hinting的方法就可以对已知的样本进行简单的处理、变换，从而获得更多的样本。比如说：数字分类问题，可以对已知的数字图片进行轻微的平移或者旋转，从而得到更多的数据，达到扩大训练集的目的。这种通过data hinting得到的数据叫做：virtual examples。\n\n> 需要注意的是，新获取的virtual examples可能不再是iid某个distribution。所以新构建的virtual examples要尽量合理，且是独立同分布的。\n\n### 4) Regularization\nRegularization（正规化）处理属于penalized方法的一种，通过正规化的处理来对原来的方程加上一个regularizer进行penalize，从而使得过渡复杂的模型，变得没那么复杂。\n\n关于Regularization 的讨论看此链接:\n[12. 机器学习基石-How can Machine Learn Better? - Regularization](https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/)\n\n### 5) Validation\n这个是目前最常用的方法之一，通过提前把一部分的数据拿出来作为测试集，因为测试集是随机取出来的，而将来实际的应用中，数据也大体和测试集出入不大，所以用这种方法，可以提前得到实际应用的时候，模型的错误 $E_{out}$ 通过这个作为衡量模型是否合格的条件之一。\n\n关于Validation 的讨论看此链接\n\n[13. 机器学习基石-How can Machine Learn Better? - Validation](https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/)\n\n\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1.首先介绍了Overfitting和Underfitting的概念。\n\n2.接着我们着重分析Overfitting，总结了产生Overfitting的原因：\n\n- data size N 太小\n\n- noise 太多\n\n- VC Dimension太大\n\n3.最后我们分析如何最大程度的避免Overfitting。在solution中.\n\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\13\\13 - 1 - What is Overfitting- (10-45)\n\n[2] 机器学习基石(台湾大学-林轩田)\\13\\13 - 2 - The Role of Noise and Data Size (13-36)\n\n\n<br><br>\n----------------------------------\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-16-11.How can Machine Learn Better - Overfitting and Solution","published":1,"updated":"2018-10-27T04:30:42.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0by0025e0owha4rylud","content":"<h1 id=\"How-can-Machine-Learn-Better-Overfitting-and-Solution\"><a href=\"#How-can-Machine-Learn-Better-Overfitting-and-Solution\" class=\"headerlink\" title=\"How can Machine Learn Better? - Overfitting and Solution\"></a>How can Machine Learn Better? - Overfitting and Solution</h1><h2 id=\"1-What-is-Overfitting\"><a href=\"#1-What-is-Overfitting\" class=\"headerlink\" title=\"1. What is Overfitting?\"></a>1. What is Overfitting?</h2><p>上一节最后，我们提到了如果线性模型的模型复杂度太大的话，可能会引起Overfitting。同样的很明显会有Underfitting的情况。</p>\n<blockquote>\n<p>那什么是Overfitting，Underfitting呢？</p>\n</blockquote>\n<p>首先根据名字，Overfitting：over fitting，就是在fitting的时候太over了。我们用线性模型去分类/回归处理数据的过程就是一个fitting的过程，所以也就是说我们处理过头了。同理Underfitting就是处理不够到位。</p>\n<blockquote>\n<p>那么什么时候才是处理过头呢？什么时候才是处理不到位呢？</p>\n</blockquote>\n<p>就是在处理相对简单的问题的时候用了相对复杂的模型去处理。<br>就是在处理相对复杂的问题的时候用了相对简单的模型去处理。</p>\n<p>我们用下面的例子来进行说明<br>1.首先例子如图一所示(这里用的是Ng的图，因为在林老师的ppt中没找到很好地图同时体现Underfit, good fit overfit)。左图是欠拟合(underfit)，中间的图四好的拟合（good fit），右图是过度拟合（overfit）。单纯从拟合结果来看：明显左边和中间的图 $E_{in}$ 比右图要大。但是从泛化好坏来看，显然左图和中间的图要比右图好。<br>假如我们考虑good fit分类出错的点为噪音点（noise），那么Overfit的模型就会受到了严重的干扰。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/faeeb6ed9dd42d75c5b4b20d6b9a592c92ce7ece/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-3%20Underfit%20Good%20Fit%20and%20Overfit.png\" alt=\"Underfit, Good Fit and Overfit\"></p>\n<center> 图一 Underfit, Good Fit and Overfit <sup>[1]</sup></center>\n\n\n<ol>\n<li>接着我们回头看之前总结的VC Dimension 的曲线， 如图二所示。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/17974844acd6bf87d8cf4d68731f9d4cade5b450/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-2%20Learning%20Curve%20.png\" alt=\"Learning Curve\"></p>\n<p>图二 Learning Curve <sup>[1]</sup></p>\n<p>图中可以看到在VC Dimension变大时，$E_{in}$ 变小， 但 $E_{out}$ 先变小后变大，而过拟合和欠拟合的情况的主要区别就在于 $E_{out}$ 的变化情况，具体解释如下：</p>\n<ul>\n<li>过拟合（Overfitting）发生在VC Dimension较大时，$E_{in}$ 太小， 但 $E_{out}$ 太大（即VC Dimension 太大了） ，表示在训练样本上拟合做的很好，$E_{in}$ 太小，但是过度了，使得泛化能力变差， $E_{out}$ 很大</li>\n<li>欠拟合（Underfitting）发生在在VC Dimension较小时，$E_{in}$ 太大，同时 $E_{out}$ 太大（即VC Dimension 太小了），表示在训练样本上拟合做不够好，$E_{in}$ 太大，虽然泛化能力很强（即 $E_{out}$ 也太大）</li>\n</ul>\n<p>关于如何解决欠拟合的问题之前也讨论过： 从低到高不断地提高多项式次数，使得VC维提高，达到拟合的效果。<br>但过拟合的问题更为复杂，下面会更深入的探讨。</p>\n<ol>\n<li>下面的图三，可以让我们更加直观的看到overfitting造成的问题</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cbdf35a9838985e1f889100ce389c4d316cc0f0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-4%20Case%20of%20Overfitting.png\" alt=\"Cases of Overfitting\"></p>\n<center> 图三 Case of Overfitting <sup>[2]</sup></center>\n\n<p>从图中可以看到，Overfitting的 $E_{in}$ 都比 good-fit的要低，但是 $E_{out}$ 却很高（泛化能力差）。</p>\n<p>总结起来有3个因数会导致Overfitting的发生：</p>\n<ul>\n<li>data size N 太小</li>\n<li>noise 太多</li>\n<li>VC Dimension太大</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Dealing-with-Overfitting\"><a href=\"#2-Dealing-with-Overfitting\" class=\"headerlink\" title=\"2. Dealing with Overfitting\"></a>2. Dealing with Overfitting</h2><p>上一节我们提出了overfitting并作了分析。总结出3个因数会导致overfitting，下面根据这3个因数，我们有5种方法帮助我们避免overfitting的发生。</p>\n<ul>\n<li>使用简单的模型(start from simple model)，逐次增加模型的复杂度 - 防止 VC Dimension太大</li>\n<li>进行数据清理/裁剪(data cleaning/pruning) - 防止 noise 太多</li>\n<li>数据提示（data hinting） - 防止 data size N 太小</li>\n<li>正则化（regularization） - 防止 VC Dimension太大</li>\n<li>确认（validation） - 提取一部分的数据作为测试集，提前估计模型的泛化强度</li>\n</ul>\n<p>下面我们分别介绍这5种方法，其中前三种方法比较简单，这里不做深入讨论，而 Regularization 和 Validation 较复杂，这里会用比较多的笔墨进行讨论。</p>\n<h3 id=\"1-Start-from-Simple-Model\"><a href=\"#1-Start-from-Simple-Model\" class=\"headerlink\" title=\"1) Start from Simple Model\"></a>1) Start from Simple Model</h3><p>上一章中也提到过，由于VC Dimension太大的话，导致 $E_{in}$ 变小的同时 $E_{out}$却在变大。所以我们如果从d=1阶的模型开始debug，如果 $E_{in}$ 不符合要求，那么我们增大d为2阶，然后在进行debug，以此类推，直到 $E_{in}$ 符合我们要求位置，这个时候的 VC Dimension 不会很大，而且我们也得到泛化能力相对较强的模型。</p>\n<h3 id=\"2-Data-Cleaning-Pruning\"><a href=\"#2-Data-Cleaning-Pruning\" class=\"headerlink\" title=\"2) Data Cleaning/Pruning\"></a>2) Data Cleaning/Pruning</h3><p>Data cleaning/pruning就是对训练数据集里label有明显错误的样本进行清理（data cleaning）或者裁剪（pruning)。data cleaning/pruning关键在于如何准确寻找label错误的点或者是noise的点。而处理的方法为</p>\n<ul>\n<li>纠正，即数据清理（data cleaning）的方式处理该情况；</li>\n<li>删除错误样本，即数据裁剪（data pruning）的方式处理。</li>\n</ul>\n<p>处理措施很简单，但是发现样本是噪音或离群点却比较困难。</p>\n<h3 id=\"3-Data-Hinting\"><a href=\"#3-Data-Hinting\" class=\"headerlink\" title=\"3) Data Hinting\"></a>3) Data Hinting</h3><p>Data hinting是针对N不够大的情况，通过data hinting的方法就可以对已知的样本进行简单的处理、变换，从而获得更多的样本。比如说：数字分类问题，可以对已知的数字图片进行轻微的平移或者旋转，从而得到更多的数据，达到扩大训练集的目的。这种通过data hinting得到的数据叫做：virtual examples。</p>\n<blockquote>\n<p>需要注意的是，新获取的virtual examples可能不再是iid某个distribution。所以新构建的virtual examples要尽量合理，且是独立同分布的。</p>\n</blockquote>\n<h3 id=\"4-Regularization\"><a href=\"#4-Regularization\" class=\"headerlink\" title=\"4) Regularization\"></a>4) Regularization</h3><p>Regularization（正规化）处理属于penalized方法的一种，通过正规化的处理来对原来的方程加上一个regularizer进行penalize，从而使得过渡复杂的模型，变得没那么复杂。</p>\n<p>关于Regularization 的讨论看此链接:<br><a href=\"https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/\">12. 机器学习基石-How can Machine Learn Better? - Regularization</a></p>\n<h3 id=\"5-Validation\"><a href=\"#5-Validation\" class=\"headerlink\" title=\"5) Validation\"></a>5) Validation</h3><p>这个是目前最常用的方法之一，通过提前把一部分的数据拿出来作为测试集，因为测试集是随机取出来的，而将来实际的应用中，数据也大体和测试集出入不大，所以用这种方法，可以提前得到实际应用的时候，模型的错误 $E_{out}$ 通过这个作为衡量模型是否合格的条件之一。</p>\n<p>关于Validation 的讨论看此链接</p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/\">13. 机器学习基石-How can Machine Learn Better? - Validation</a></p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>1.首先介绍了Overfitting和Underfitting的概念。</p>\n<p>2.接着我们着重分析Overfitting，总结了产生Overfitting的原因：</p>\n<ul>\n<li><p>data size N 太小</p>\n</li>\n<li><p>noise 太多</p>\n</li>\n<li><p>VC Dimension太大</p>\n</li>\n</ul>\n<p>3.最后我们分析如何最大程度的避免Overfitting。在solution中.</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\13\\13 - 1 - What is Overfitting- (10-45)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\13\\13 - 2 - The Role of Noise and Data Size (13-36)</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Better-Overfitting-and-Solution\"><a href=\"#How-can-Machine-Learn-Better-Overfitting-and-Solution\" class=\"headerlink\" title=\"How can Machine Learn Better? - Overfitting and Solution\"></a>How can Machine Learn Better? - Overfitting and Solution</h1><h2 id=\"1-What-is-Overfitting\"><a href=\"#1-What-is-Overfitting\" class=\"headerlink\" title=\"1. What is Overfitting?\"></a>1. What is Overfitting?</h2><p>上一节最后，我们提到了如果线性模型的模型复杂度太大的话，可能会引起Overfitting。同样的很明显会有Underfitting的情况。</p>\n<blockquote>\n<p>那什么是Overfitting，Underfitting呢？</p>\n</blockquote>\n<p>首先根据名字，Overfitting：over fitting，就是在fitting的时候太over了。我们用线性模型去分类/回归处理数据的过程就是一个fitting的过程，所以也就是说我们处理过头了。同理Underfitting就是处理不够到位。</p>\n<blockquote>\n<p>那么什么时候才是处理过头呢？什么时候才是处理不到位呢？</p>\n</blockquote>\n<p>就是在处理相对简单的问题的时候用了相对复杂的模型去处理。<br>就是在处理相对复杂的问题的时候用了相对简单的模型去处理。</p>\n<p>我们用下面的例子来进行说明<br>1.首先例子如图一所示(这里用的是Ng的图，因为在林老师的ppt中没找到很好地图同时体现Underfit, good fit overfit)。左图是欠拟合(underfit)，中间的图四好的拟合（good fit），右图是过度拟合（overfit）。单纯从拟合结果来看：明显左边和中间的图 $E_{in}$ 比右图要大。但是从泛化好坏来看，显然左图和中间的图要比右图好。<br>假如我们考虑good fit分类出错的点为噪音点（noise），那么Overfit的模型就会受到了严重的干扰。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/faeeb6ed9dd42d75c5b4b20d6b9a592c92ce7ece/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-3%20Underfit%20Good%20Fit%20and%20Overfit.png\" alt=\"Underfit, Good Fit and Overfit\"></p>\n<center> 图一 Underfit, Good Fit and Overfit <sup>[1]</sup></center>\n\n\n<ol>\n<li>接着我们回头看之前总结的VC Dimension 的曲线， 如图二所示。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/17974844acd6bf87d8cf4d68731f9d4cade5b450/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-2%20Learning%20Curve%20.png\" alt=\"Learning Curve\"></p>\n<p>图二 Learning Curve <sup>[1]</sup></p>\n<p>图中可以看到在VC Dimension变大时，$E_{in}$ 变小， 但 $E_{out}$ 先变小后变大，而过拟合和欠拟合的情况的主要区别就在于 $E_{out}$ 的变化情况，具体解释如下：</p>\n<ul>\n<li>过拟合（Overfitting）发生在VC Dimension较大时，$E_{in}$ 太小， 但 $E_{out}$ 太大（即VC Dimension 太大了） ，表示在训练样本上拟合做的很好，$E_{in}$ 太小，但是过度了，使得泛化能力变差， $E_{out}$ 很大</li>\n<li>欠拟合（Underfitting）发生在在VC Dimension较小时，$E_{in}$ 太大，同时 $E_{out}$ 太大（即VC Dimension 太小了），表示在训练样本上拟合做不够好，$E_{in}$ 太大，虽然泛化能力很强（即 $E_{out}$ 也太大）</li>\n</ul>\n<p>关于如何解决欠拟合的问题之前也讨论过： 从低到高不断地提高多项式次数，使得VC维提高，达到拟合的效果。<br>但过拟合的问题更为复杂，下面会更深入的探讨。</p>\n<ol>\n<li>下面的图三，可以让我们更加直观的看到overfitting造成的问题</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cbdf35a9838985e1f889100ce389c4d316cc0f0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter11-4%20Case%20of%20Overfitting.png\" alt=\"Cases of Overfitting\"></p>\n<center> 图三 Case of Overfitting <sup>[2]</sup></center>\n\n<p>从图中可以看到，Overfitting的 $E_{in}$ 都比 good-fit的要低，但是 $E_{out}$ 却很高（泛化能力差）。</p>\n<p>总结起来有3个因数会导致Overfitting的发生：</p>\n<ul>\n<li>data size N 太小</li>\n<li>noise 太多</li>\n<li>VC Dimension太大</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Dealing-with-Overfitting\"><a href=\"#2-Dealing-with-Overfitting\" class=\"headerlink\" title=\"2. Dealing with Overfitting\"></a>2. Dealing with Overfitting</h2><p>上一节我们提出了overfitting并作了分析。总结出3个因数会导致overfitting，下面根据这3个因数，我们有5种方法帮助我们避免overfitting的发生。</p>\n<ul>\n<li>使用简单的模型(start from simple model)，逐次增加模型的复杂度 - 防止 VC Dimension太大</li>\n<li>进行数据清理/裁剪(data cleaning/pruning) - 防止 noise 太多</li>\n<li>数据提示（data hinting） - 防止 data size N 太小</li>\n<li>正则化（regularization） - 防止 VC Dimension太大</li>\n<li>确认（validation） - 提取一部分的数据作为测试集，提前估计模型的泛化强度</li>\n</ul>\n<p>下面我们分别介绍这5种方法，其中前三种方法比较简单，这里不做深入讨论，而 Regularization 和 Validation 较复杂，这里会用比较多的笔墨进行讨论。</p>\n<h3 id=\"1-Start-from-Simple-Model\"><a href=\"#1-Start-from-Simple-Model\" class=\"headerlink\" title=\"1) Start from Simple Model\"></a>1) Start from Simple Model</h3><p>上一章中也提到过，由于VC Dimension太大的话，导致 $E_{in}$ 变小的同时 $E_{out}$却在变大。所以我们如果从d=1阶的模型开始debug，如果 $E_{in}$ 不符合要求，那么我们增大d为2阶，然后在进行debug，以此类推，直到 $E_{in}$ 符合我们要求位置，这个时候的 VC Dimension 不会很大，而且我们也得到泛化能力相对较强的模型。</p>\n<h3 id=\"2-Data-Cleaning-Pruning\"><a href=\"#2-Data-Cleaning-Pruning\" class=\"headerlink\" title=\"2) Data Cleaning/Pruning\"></a>2) Data Cleaning/Pruning</h3><p>Data cleaning/pruning就是对训练数据集里label有明显错误的样本进行清理（data cleaning）或者裁剪（pruning)。data cleaning/pruning关键在于如何准确寻找label错误的点或者是noise的点。而处理的方法为</p>\n<ul>\n<li>纠正，即数据清理（data cleaning）的方式处理该情况；</li>\n<li>删除错误样本，即数据裁剪（data pruning）的方式处理。</li>\n</ul>\n<p>处理措施很简单，但是发现样本是噪音或离群点却比较困难。</p>\n<h3 id=\"3-Data-Hinting\"><a href=\"#3-Data-Hinting\" class=\"headerlink\" title=\"3) Data Hinting\"></a>3) Data Hinting</h3><p>Data hinting是针对N不够大的情况，通过data hinting的方法就可以对已知的样本进行简单的处理、变换，从而获得更多的样本。比如说：数字分类问题，可以对已知的数字图片进行轻微的平移或者旋转，从而得到更多的数据，达到扩大训练集的目的。这种通过data hinting得到的数据叫做：virtual examples。</p>\n<blockquote>\n<p>需要注意的是，新获取的virtual examples可能不再是iid某个distribution。所以新构建的virtual examples要尽量合理，且是独立同分布的。</p>\n</blockquote>\n<h3 id=\"4-Regularization\"><a href=\"#4-Regularization\" class=\"headerlink\" title=\"4) Regularization\"></a>4) Regularization</h3><p>Regularization（正规化）处理属于penalized方法的一种，通过正规化的处理来对原来的方程加上一个regularizer进行penalize，从而使得过渡复杂的模型，变得没那么复杂。</p>\n<p>关于Regularization 的讨论看此链接:<br><a href=\"https://zhichengmle.github.io/2017/10/17/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-17-12.How%20can%20Machine%20Learn%20Better%20-%20Regularization/\">12. 机器学习基石-How can Machine Learn Better? - Regularization</a></p>\n<h3 id=\"5-Validation\"><a href=\"#5-Validation\" class=\"headerlink\" title=\"5) Validation\"></a>5) Validation</h3><p>这个是目前最常用的方法之一，通过提前把一部分的数据拿出来作为测试集，因为测试集是随机取出来的，而将来实际的应用中，数据也大体和测试集出入不大，所以用这种方法，可以提前得到实际应用的时候，模型的错误 $E_{out}$ 通过这个作为衡量模型是否合格的条件之一。</p>\n<p>关于Validation 的讨论看此链接</p>\n<p><a href=\"https://zhichengmle.github.io/2017/10/18/ReadNote-Machine%20Learning%20Foudantion%20-NTU/2017-10-18-13.How%20can%20Machine%20Learn%20Better%20-%20Validation/\">13. 机器学习基石-How can Machine Learn Better? - Validation</a></p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><p>1.首先介绍了Overfitting和Underfitting的概念。</p>\n<p>2.接着我们着重分析Overfitting，总结了产生Overfitting的原因：</p>\n<ul>\n<li><p>data size N 太小</p>\n</li>\n<li><p>noise 太多</p>\n</li>\n<li><p>VC Dimension太大</p>\n</li>\n</ul>\n<p>3.最后我们分析如何最大程度的避免Overfitting。在solution中.</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\13\\13 - 1 - What is Overfitting- (10-45)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\13\\13 - 2 - The Role of Noise and Data Size (13-36)</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"13.How can Machine Learn Better? - Validation","date":"2017-10-18T06:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# How can Machine Learn Better? - Validation\n\n> 这一节我们Validation，需要选择的原因是机器学习的算法有很多种，如何评估哪一种适合当前的使用场景是一个值得商榷的问题。所以通过Validation，我们可以对模型的误差有一定的测试，评估，从而可以确定我们所需要的模型。\n\n## 1. Model Selection Problem\n到目前为止，已经学过了许多算法模型，但一个模型需要很多参数的选择，这是本章讨论的重点。\n\n以二元分类为例，在学过的算法有PLA、pocket、线性回归、logistic回归；算法中需要用到迭代方法，就需要选择迭代步骤T；同理也需要选择学习步长 ；处理非线性问题时，需要用到不同的转换函数，可能是线性的，二次式，10次多项式或者10次勒让德多项式；如果加上正则化项，则可以选择L2正则化项，L1正则化项；有了正则化项，则参数 值也需要选择。\n\n在如此多的选项中设计一个适用于各种情况各个数据集的模型显然是不可能的，因此针对不同的情况，对各个参数的选择是必须的。\n\n我们主要是通过误差 E 来进行判断一个模型是否良好的。我们有 $E_{out}$ 和 $E_{in}$\n1. 显然我们不能通过 $E_{out}$ 来进行评估，因为我们不可能拿得到未来要进行测试用的数据。\n2. 但是我们也不能通过 $E_{in}$ 来进行并评估，因为从前面2节的讨论中，我们知道，模型复杂度越高的模型， $E_{in}$ 往往就越高，但是也造成了模型的泛化能力变弱，使得  $E_{out} \\approx E_{in}$ 的条件不成立，根本谈不上机器学习了。\n\n但是我们能否采用另一个相对宽松的误差来作为评估呢？比如说:有这样一个独立于训练样本的测试集，将M个模型在测试集上进行测试，看一下Etest的大小，则选取Etest最小的模型作为最佳模型。\n> 是可以的，因为我们有Hoeffding Inequity作为理论保证\n\n下面我们将讨论这个宽松的误差。\n1.首先，这个最小的测试集选出来的权值满足公式（1），其中 $m^\\ast$ 表示最佳的权值\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\nm^* = \\argmin\\limits_{1 \\leq m \\leq M} (E_m = E_{test}(A_m(D)))\n\\tag{$1$}\n$$\n\n2.这种测试集验证的方法，根据finite-bin Hoffding不等式，可以得到公式（2），并且可以看出，模型个数M越少，测试集数目越大，那么 $O(\\sqrt{\\frac{logM}{N_{test}}}$ 越小，即 $E_{test}(g_{m^\\ast})$ 越接近于 $E_{out}(g_{m^\\ast})$ 。\n\n$$\nE_{out}(g_{m^\\ast}) \\leq E_{test}(g_{m^\\ast}) + O(\\sqrt{\\frac{logM}{N_{test}}}\n\\tag{$2$}\n$$\n\n\n\n下面比较一下使用 $E_{in}$ 和 $E_{test}$ 作为评估基准的方法：\n1. 使用 $E_{in}$ 作为判断基准，使用的数据集就是训练集D本身；不仅使用D来训练不同的 $g_{m^\\ast}$ ，而且又使用D来选择最好的 $g_{m^\\ast}$ ，那么 $g_{m^\\ast}$ 对未知数据并不一定泛化能力好。课堂中举的例子是：，老师用学生做过的练习题训练学生，然后再用一样的题目来对学生进行考试，这种方法即使学生得到高分，也不能说明他的真的掌握了知识。所以最小化 $E_{in}$ 的方法并不科学。\n2. 第使用 $E_{test}$ 作为判断基准，使用的是独立于训练集D之外的测试集。而后者使用的是独立于D的测试集，相当于用一份题目来训练学生后，再用另外一份全新的题目来测试学生的水平，这样更能反映出学生对知识点的理解，所以最小化 $E_{test}$ 更加理想。但是真正的训练集是拿不到的（要实际投入使用才知道）。所以，寻找一种折中的办法，我们可以使用已有的训练集D来创造一个验证集validation set，即从D中划出一部分 $D_{val}$ 作为验证集。D另外的部分作为训练模型使用， $D_{val}$ 独立开来，用来测试各个模型的好坏，最小化 $E_{val}$ ，从而选择最佳的 $g_{m^\\ast}$ ∗。\n\n>下面，我们针对验证集的选择进行讨论。\n\n\n<br><br>\n----------------------------------\n## 2. Validation\n验证集的选择，我们必须遵循几点：\n1. 选择要随机 - 造成数据不平衡，结果有问题\n2. 数据量分配要合理 - 过多的验证集会造成训练集的减少，过少的验证集验证结果可信度不高\n3. 验证集必须是新的，没有被用于训练 - 那就等于是直接用训练集去做验证了\n\n所以为了满足这3个条件，我们下面需要讨论如何来划分数据集\n\n1.首先我们将原本的数据样本D分为两部分： 训练数据 $D_{train}$ 和 验证数据 $D_{val}$， 如公式（3）所示，如图一所示。\n\n$$\n\\underbrace{D}_{size=N} = \\underbrace{D_{train}}_{size=N-K} \\cup \\underbrace{D_{val}}_{size=K}\n\\tag{$3$}\n$$\n\n![Validation Set](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9bf9752d63dd11988ef0024464fe257c99f4827a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-1%20Validation%20Set.png)\n<center> 图一 Validation Set <sup>[1]</sup></center>\n\n\n2.根据Hoeffding Inequity，我们可以得到公式（4）\n\n$$\nE_{out}(g_{m*}) \\leq E_{out}(g_{m^-}) \\leq E_{test}(g_{m^-}) + O(\\sqrt{\\frac{logM}{K}}\n\\tag{$2$}\n$$\n\n下面我们举个例子来解释这种模型选择的方法的优越性，假设有两个模型：一个是5阶多项式HΦ5，一个是10阶多项式HΦ10。通过不使用验证集和使用验证集两种方法对模型选择结果进行比较，分析结果如图二所示\n\n![Validation in Practice](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/70d9d9faae5aed3273361b2fb4a776cf83c9fb27/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-2%20Validation%20in%20Practice.png)\n<center> 图二 Validation in Practice <sup>[1]</sup></center>\n\n图中，横坐标表示验证集数量K，纵坐标表示 $E_{out}$ 大小。黑色水平线表示没有验证集，完全使用 $E_{in}$ 作为判断基准，那么 $H_{\\Phi 10}$ 更好一些，但是这种方法的 $E_{out}$ 比较大，而且与K无关。黑色虚线表示测试集非常接近实际数据，这是一种理想的情况，其 $E_{out}$ 很小，同样也与K无关，实际中很难得到这条虚线。\n\n红色曲线表示使用验证集，但是最终选取的矩是 $g_{m^\\ast}^-$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先减小再增大，当K大于一定值的时候，甚至会超过黑色水平线。蓝色曲线表示也使用验证集，最终选取的矩是 $g_{m^\\ast}$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先缓慢减小再缓慢增大，且一直位于红色曲线和黑色直线之下。从此可见，蓝色曲线对应的方法最好，符合我们之前讨论的使用验证集进行模型选择效果最好。\n\n但是也存在问题，当 K 太大的时候，红色曲线会超过黑色直线，也就是上面提到的，选择了太多的数据作为验证集，从而导致训练的数据大大减少，那么模型的泛化能力太差，不能保证 $E_{in} \\approx E_{out}$\n\n>那么如何选择 K呢？\n\n老师的建议是选择 $K = \\frac{N}{5}$\n\n\n\n\n<br><br>\n----------------------------------\n## 3. Leave-One-Out Cross Validation\n上一节，最后我们提到了K值得重要性，下面我们将讨论如何让这个数据取得更加合理。\n\n第一种方法叫做： Leave-One-Out Cross Validation(留一法交叉验证)，这方法是采用一种极端的情况（K=1），也就是说验证集大小为1，即每次只用一组数据对 $g_m$ 进行验证，重复N次，最后求平均误差。\n\n这种算法的优缺点如下：\n- 优点：使得 $g_m^- \\approx g_m$\n- 缺点：①$E_{val}$ 与 $E_{out}$  可能会相差很大 ②时间和空间复杂度非常大 ③稳定性差（例如对于二分类问题，取值只有0和1两种，预测本身存在不稳定的因素，那么对所有的Eloocv计算平均值可能会带来很大的数值跳动）\n\n误差方程的表达式如公式（3）所示。\n\n$$\nE_{loocv}(H, A) = \\frac{1}{N} \\sum\\limits_{n=1}^{N} \\cdot err(g_n^-(x_n), y_n)\n\\tag{$3$}\n$$\n\n\n该算法的具体流程如下：\n\n1.取n=1的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$\n\n2.接着取n=2的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$\n\n3.以此类推，重复N次，直到n=N的点也进行上述的操作\n\n4.把N次误差加起来求平均\n\n课上举了一个例子说明该方法的效果并且总结了Feature的多少与 $E_{in} E_{out} E_{loocv}$的关系。如图三所示。很明显可以看出，使用Ein发生了过拟合，而Eloocv分类效果更好，泛化能力强。\n\n\n![Leave-One-Out in Practice](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a5de867bdf6c5738844287c3de950431325891b0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-4%20Leave-One-Out%20in%20Practice.png)\n<center> 图三 Leave-One-Out in Practice <sup>[2]</sup></center>\n\n\n但是这种方法由于他的缺点太多，所以实际中往往很少使用。更多的是使用下面要讨论的V-Fold Cross Validation\n\n\n<br><br>\n----------------------------------\n## 4. V-Fold Cross Validation\n上面讨论的Leave-One-Out Cross Validation 的优缺点导致了该算法不好用。所以针对该算法的缺点，人们对其改进为V-Fold Cross Validation: 这种算法是把数据N平均分为V分，每次取一份作为验证集，剩下的V-1份作为测试集，重复V次，算出平均误差。那样的话Leave-One-Out Cross Validation 可以看成是V=N的极端情况\n\n该算法的误差方程如公式（4）所示\n\n$$\nE_{cv}(H, A) = \\frac{1}{V} \\sum\\limits_{V=1}^{V} E_{val}^{(v)}(g_v^-)\n\\tag{$4$}\n$$\n\n一般的Validation使用V-Fold Cross Validation来选择最佳的模型。\n\n但是该算法也有一点问题：就是Validation的数据来源是集中的，所以并不能保证交叉验证的效果好，得到的数学模型一定就很好。只有在样本数据足够多的时候，结果才可信，数学模型泛化能力越强。\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先介绍了validation验证的意义\n2. 然后介绍了Leave-One-Out算法并分析其优劣：该算法在实际应用不多\n3. 最后根据Leave-One-Out算法的缺点，做改进，提出了V-Fold Cross Validation\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\15\\15 - 1 - Model Selection Problem (16-00)\n\n[2] 机器学习基石(台湾大学-林轩田)\\15\\15 - 3 - Leave-One-Out Cross Validation (16-06)\n\n<br><br>\n----------------------------------\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-18-13.How can Machine Learn Better - Validation.md","raw":"---\ntitle: 13.How can Machine Learn Better? - Validation\ndate: 2017-10-18 14:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# How can Machine Learn Better? - Validation\n\n> 这一节我们Validation，需要选择的原因是机器学习的算法有很多种，如何评估哪一种适合当前的使用场景是一个值得商榷的问题。所以通过Validation，我们可以对模型的误差有一定的测试，评估，从而可以确定我们所需要的模型。\n\n## 1. Model Selection Problem\n到目前为止，已经学过了许多算法模型，但一个模型需要很多参数的选择，这是本章讨论的重点。\n\n以二元分类为例，在学过的算法有PLA、pocket、线性回归、logistic回归；算法中需要用到迭代方法，就需要选择迭代步骤T；同理也需要选择学习步长 ；处理非线性问题时，需要用到不同的转换函数，可能是线性的，二次式，10次多项式或者10次勒让德多项式；如果加上正则化项，则可以选择L2正则化项，L1正则化项；有了正则化项，则参数 值也需要选择。\n\n在如此多的选项中设计一个适用于各种情况各个数据集的模型显然是不可能的，因此针对不同的情况，对各个参数的选择是必须的。\n\n我们主要是通过误差 E 来进行判断一个模型是否良好的。我们有 $E_{out}$ 和 $E_{in}$\n1. 显然我们不能通过 $E_{out}$ 来进行评估，因为我们不可能拿得到未来要进行测试用的数据。\n2. 但是我们也不能通过 $E_{in}$ 来进行并评估，因为从前面2节的讨论中，我们知道，模型复杂度越高的模型， $E_{in}$ 往往就越高，但是也造成了模型的泛化能力变弱，使得  $E_{out} \\approx E_{in}$ 的条件不成立，根本谈不上机器学习了。\n\n但是我们能否采用另一个相对宽松的误差来作为评估呢？比如说:有这样一个独立于训练样本的测试集，将M个模型在测试集上进行测试，看一下Etest的大小，则选取Etest最小的模型作为最佳模型。\n> 是可以的，因为我们有Hoeffding Inequity作为理论保证\n\n下面我们将讨论这个宽松的误差。\n1.首先，这个最小的测试集选出来的权值满足公式（1），其中 $m^\\ast$ 表示最佳的权值\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\nm^* = \\argmin\\limits_{1 \\leq m \\leq M} (E_m = E_{test}(A_m(D)))\n\\tag{$1$}\n$$\n\n2.这种测试集验证的方法，根据finite-bin Hoffding不等式，可以得到公式（2），并且可以看出，模型个数M越少，测试集数目越大，那么 $O(\\sqrt{\\frac{logM}{N_{test}}}$ 越小，即 $E_{test}(g_{m^\\ast})$ 越接近于 $E_{out}(g_{m^\\ast})$ 。\n\n$$\nE_{out}(g_{m^\\ast}) \\leq E_{test}(g_{m^\\ast}) + O(\\sqrt{\\frac{logM}{N_{test}}}\n\\tag{$2$}\n$$\n\n\n\n下面比较一下使用 $E_{in}$ 和 $E_{test}$ 作为评估基准的方法：\n1. 使用 $E_{in}$ 作为判断基准，使用的数据集就是训练集D本身；不仅使用D来训练不同的 $g_{m^\\ast}$ ，而且又使用D来选择最好的 $g_{m^\\ast}$ ，那么 $g_{m^\\ast}$ 对未知数据并不一定泛化能力好。课堂中举的例子是：，老师用学生做过的练习题训练学生，然后再用一样的题目来对学生进行考试，这种方法即使学生得到高分，也不能说明他的真的掌握了知识。所以最小化 $E_{in}$ 的方法并不科学。\n2. 第使用 $E_{test}$ 作为判断基准，使用的是独立于训练集D之外的测试集。而后者使用的是独立于D的测试集，相当于用一份题目来训练学生后，再用另外一份全新的题目来测试学生的水平，这样更能反映出学生对知识点的理解，所以最小化 $E_{test}$ 更加理想。但是真正的训练集是拿不到的（要实际投入使用才知道）。所以，寻找一种折中的办法，我们可以使用已有的训练集D来创造一个验证集validation set，即从D中划出一部分 $D_{val}$ 作为验证集。D另外的部分作为训练模型使用， $D_{val}$ 独立开来，用来测试各个模型的好坏，最小化 $E_{val}$ ，从而选择最佳的 $g_{m^\\ast}$ ∗。\n\n>下面，我们针对验证集的选择进行讨论。\n\n\n<br><br>\n----------------------------------\n## 2. Validation\n验证集的选择，我们必须遵循几点：\n1. 选择要随机 - 造成数据不平衡，结果有问题\n2. 数据量分配要合理 - 过多的验证集会造成训练集的减少，过少的验证集验证结果可信度不高\n3. 验证集必须是新的，没有被用于训练 - 那就等于是直接用训练集去做验证了\n\n所以为了满足这3个条件，我们下面需要讨论如何来划分数据集\n\n1.首先我们将原本的数据样本D分为两部分： 训练数据 $D_{train}$ 和 验证数据 $D_{val}$， 如公式（3）所示，如图一所示。\n\n$$\n\\underbrace{D}_{size=N} = \\underbrace{D_{train}}_{size=N-K} \\cup \\underbrace{D_{val}}_{size=K}\n\\tag{$3$}\n$$\n\n![Validation Set](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9bf9752d63dd11988ef0024464fe257c99f4827a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-1%20Validation%20Set.png)\n<center> 图一 Validation Set <sup>[1]</sup></center>\n\n\n2.根据Hoeffding Inequity，我们可以得到公式（4）\n\n$$\nE_{out}(g_{m*}) \\leq E_{out}(g_{m^-}) \\leq E_{test}(g_{m^-}) + O(\\sqrt{\\frac{logM}{K}}\n\\tag{$2$}\n$$\n\n下面我们举个例子来解释这种模型选择的方法的优越性，假设有两个模型：一个是5阶多项式HΦ5，一个是10阶多项式HΦ10。通过不使用验证集和使用验证集两种方法对模型选择结果进行比较，分析结果如图二所示\n\n![Validation in Practice](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/70d9d9faae5aed3273361b2fb4a776cf83c9fb27/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-2%20Validation%20in%20Practice.png)\n<center> 图二 Validation in Practice <sup>[1]</sup></center>\n\n图中，横坐标表示验证集数量K，纵坐标表示 $E_{out}$ 大小。黑色水平线表示没有验证集，完全使用 $E_{in}$ 作为判断基准，那么 $H_{\\Phi 10}$ 更好一些，但是这种方法的 $E_{out}$ 比较大，而且与K无关。黑色虚线表示测试集非常接近实际数据，这是一种理想的情况，其 $E_{out}$ 很小，同样也与K无关，实际中很难得到这条虚线。\n\n红色曲线表示使用验证集，但是最终选取的矩是 $g_{m^\\ast}^-$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先减小再增大，当K大于一定值的时候，甚至会超过黑色水平线。蓝色曲线表示也使用验证集，最终选取的矩是 $g_{m^\\ast}$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先缓慢减小再缓慢增大，且一直位于红色曲线和黑色直线之下。从此可见，蓝色曲线对应的方法最好，符合我们之前讨论的使用验证集进行模型选择效果最好。\n\n但是也存在问题，当 K 太大的时候，红色曲线会超过黑色直线，也就是上面提到的，选择了太多的数据作为验证集，从而导致训练的数据大大减少，那么模型的泛化能力太差，不能保证 $E_{in} \\approx E_{out}$\n\n>那么如何选择 K呢？\n\n老师的建议是选择 $K = \\frac{N}{5}$\n\n\n\n\n<br><br>\n----------------------------------\n## 3. Leave-One-Out Cross Validation\n上一节，最后我们提到了K值得重要性，下面我们将讨论如何让这个数据取得更加合理。\n\n第一种方法叫做： Leave-One-Out Cross Validation(留一法交叉验证)，这方法是采用一种极端的情况（K=1），也就是说验证集大小为1，即每次只用一组数据对 $g_m$ 进行验证，重复N次，最后求平均误差。\n\n这种算法的优缺点如下：\n- 优点：使得 $g_m^- \\approx g_m$\n- 缺点：①$E_{val}$ 与 $E_{out}$  可能会相差很大 ②时间和空间复杂度非常大 ③稳定性差（例如对于二分类问题，取值只有0和1两种，预测本身存在不稳定的因素，那么对所有的Eloocv计算平均值可能会带来很大的数值跳动）\n\n误差方程的表达式如公式（3）所示。\n\n$$\nE_{loocv}(H, A) = \\frac{1}{N} \\sum\\limits_{n=1}^{N} \\cdot err(g_n^-(x_n), y_n)\n\\tag{$3$}\n$$\n\n\n该算法的具体流程如下：\n\n1.取n=1的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$\n\n2.接着取n=2的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$\n\n3.以此类推，重复N次，直到n=N的点也进行上述的操作\n\n4.把N次误差加起来求平均\n\n课上举了一个例子说明该方法的效果并且总结了Feature的多少与 $E_{in} E_{out} E_{loocv}$的关系。如图三所示。很明显可以看出，使用Ein发生了过拟合，而Eloocv分类效果更好，泛化能力强。\n\n\n![Leave-One-Out in Practice](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a5de867bdf6c5738844287c3de950431325891b0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-4%20Leave-One-Out%20in%20Practice.png)\n<center> 图三 Leave-One-Out in Practice <sup>[2]</sup></center>\n\n\n但是这种方法由于他的缺点太多，所以实际中往往很少使用。更多的是使用下面要讨论的V-Fold Cross Validation\n\n\n<br><br>\n----------------------------------\n## 4. V-Fold Cross Validation\n上面讨论的Leave-One-Out Cross Validation 的优缺点导致了该算法不好用。所以针对该算法的缺点，人们对其改进为V-Fold Cross Validation: 这种算法是把数据N平均分为V分，每次取一份作为验证集，剩下的V-1份作为测试集，重复V次，算出平均误差。那样的话Leave-One-Out Cross Validation 可以看成是V=N的极端情况\n\n该算法的误差方程如公式（4）所示\n\n$$\nE_{cv}(H, A) = \\frac{1}{V} \\sum\\limits_{V=1}^{V} E_{val}^{(v)}(g_v^-)\n\\tag{$4$}\n$$\n\n一般的Validation使用V-Fold Cross Validation来选择最佳的模型。\n\n但是该算法也有一点问题：就是Validation的数据来源是集中的，所以并不能保证交叉验证的效果好，得到的数学模型一定就很好。只有在样本数据足够多的时候，结果才可信，数学模型泛化能力越强。\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先介绍了validation验证的意义\n2. 然后介绍了Leave-One-Out算法并分析其优劣：该算法在实际应用不多\n3. 最后根据Leave-One-Out算法的缺点，做改进，提出了V-Fold Cross Validation\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\15\\15 - 1 - Model Selection Problem (16-00)\n\n[2] 机器学习基石(台湾大学-林轩田)\\15\\15 - 3 - Leave-One-Out Cross Validation (16-06)\n\n<br><br>\n----------------------------------\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-18-13.How can Machine Learn Better - Validation","published":1,"updated":"2018-10-27T04:30:42.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0bz0028e0owk2sh41zi","content":"<h1 id=\"How-can-Machine-Learn-Better-Validation\"><a href=\"#How-can-Machine-Learn-Better-Validation\" class=\"headerlink\" title=\"How can Machine Learn Better? - Validation\"></a>How can Machine Learn Better? - Validation</h1><blockquote>\n<p>这一节我们Validation，需要选择的原因是机器学习的算法有很多种，如何评估哪一种适合当前的使用场景是一个值得商榷的问题。所以通过Validation，我们可以对模型的误差有一定的测试，评估，从而可以确定我们所需要的模型。</p>\n</blockquote>\n<h2 id=\"1-Model-Selection-Problem\"><a href=\"#1-Model-Selection-Problem\" class=\"headerlink\" title=\"1. Model Selection Problem\"></a>1. Model Selection Problem</h2><p>到目前为止，已经学过了许多算法模型，但一个模型需要很多参数的选择，这是本章讨论的重点。</p>\n<p>以二元分类为例，在学过的算法有PLA、pocket、线性回归、logistic回归；算法中需要用到迭代方法，就需要选择迭代步骤T；同理也需要选择学习步长 ；处理非线性问题时，需要用到不同的转换函数，可能是线性的，二次式，10次多项式或者10次勒让德多项式；如果加上正则化项，则可以选择L2正则化项，L1正则化项；有了正则化项，则参数 值也需要选择。</p>\n<p>在如此多的选项中设计一个适用于各种情况各个数据集的模型显然是不可能的，因此针对不同的情况，对各个参数的选择是必须的。</p>\n<p>我们主要是通过误差 E 来进行判断一个模型是否良好的。我们有 $E_{out}$ 和 $E_{in}$</p>\n<ol>\n<li>显然我们不能通过 $E_{out}$ 来进行评估，因为我们不可能拿得到未来要进行测试用的数据。</li>\n<li>但是我们也不能通过 $E_{in}$ 来进行并评估，因为从前面2节的讨论中，我们知道，模型复杂度越高的模型， $E_{in}$ 往往就越高，但是也造成了模型的泛化能力变弱，使得  $E_{out} \\approx E_{in}$ 的条件不成立，根本谈不上机器学习了。</li>\n</ol>\n<p>但是我们能否采用另一个相对宽松的误差来作为评估呢？比如说:有这样一个独立于训练样本的测试集，将M个模型在测试集上进行测试，看一下Etest的大小，则选取Etest最小的模型作为最佳模型。</p>\n<blockquote>\n<p>是可以的，因为我们有Hoeffding Inequity作为理论保证</p>\n</blockquote>\n<p>下面我们将讨论这个宽松的误差。<br>1.首先，这个最小的测试集选出来的权值满足公式（1），其中 $m^\\ast$ 表示最佳的权值</p>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmin}{argmin}\nm^* = \\argmin\\limits_{1 \\leq m \\leq M} (E_m = E_{test}(A_m(D)))\n\\tag{$1$}</script><p>2.这种测试集验证的方法，根据finite-bin Hoffding不等式，可以得到公式（2），并且可以看出，模型个数M越少，测试集数目越大，那么 $O(\\sqrt{\\frac{logM}{N_{test}}}$ 越小，即 $E_{test}(g_{m^\\ast})$ 越接近于 $E_{out}(g_{m^\\ast})$ 。</p>\n<script type=\"math/tex; mode=display\">\nE_{out}(g_{m^\\ast}) \\leq E_{test}(g_{m^\\ast}) + O(\\sqrt{\\frac{logM}{N_{test}}}\n\\tag{$2$}</script><p>下面比较一下使用 $E_{in}$ 和 $E_{test}$ 作为评估基准的方法：</p>\n<ol>\n<li>使用 $E_{in}$ 作为判断基准，使用的数据集就是训练集D本身；不仅使用D来训练不同的 $g_{m^\\ast}$ ，而且又使用D来选择最好的 $g_{m^\\ast}$ ，那么 $g_{m^\\ast}$ 对未知数据并不一定泛化能力好。课堂中举的例子是：，老师用学生做过的练习题训练学生，然后再用一样的题目来对学生进行考试，这种方法即使学生得到高分，也不能说明他的真的掌握了知识。所以最小化 $E_{in}$ 的方法并不科学。</li>\n<li>第使用 $E_{test}$ 作为判断基准，使用的是独立于训练集D之外的测试集。而后者使用的是独立于D的测试集，相当于用一份题目来训练学生后，再用另外一份全新的题目来测试学生的水平，这样更能反映出学生对知识点的理解，所以最小化 $E_{test}$ 更加理想。但是真正的训练集是拿不到的（要实际投入使用才知道）。所以，寻找一种折中的办法，我们可以使用已有的训练集D来创造一个验证集validation set，即从D中划出一部分 $D_{val}$ 作为验证集。D另外的部分作为训练模型使用， $D_{val}$ 独立开来，用来测试各个模型的好坏，最小化 $E_{val}$ ，从而选择最佳的 $g_{m^\\ast}$ ∗。</li>\n</ol>\n<blockquote>\n<p>下面，我们针对验证集的选择进行讨论。</p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Validation\"><a href=\"#2-Validation\" class=\"headerlink\" title=\"2. Validation\"></a>2. Validation</h2><p>验证集的选择，我们必须遵循几点：</p>\n<ol>\n<li>选择要随机 - 造成数据不平衡，结果有问题</li>\n<li>数据量分配要合理 - 过多的验证集会造成训练集的减少，过少的验证集验证结果可信度不高</li>\n<li>验证集必须是新的，没有被用于训练 - 那就等于是直接用训练集去做验证了</li>\n</ol>\n<p>所以为了满足这3个条件，我们下面需要讨论如何来划分数据集</p>\n<p>1.首先我们将原本的数据样本D分为两部分： 训练数据 $D_{train}$ 和 验证数据 $D_{val}$， 如公式（3）所示，如图一所示。</p>\n<script type=\"math/tex; mode=display\">\n\\underbrace{D}_{size=N} = \\underbrace{D_{train}}_{size=N-K} \\cup \\underbrace{D_{val}}_{size=K}\n\\tag{$3$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9bf9752d63dd11988ef0024464fe257c99f4827a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-1%20Validation%20Set.png\" alt=\"Validation Set\"></p>\n<center> 图一 Validation Set <sup>[1]</sup></center>\n\n\n<p>2.根据Hoeffding Inequity，我们可以得到公式（4）</p>\n<script type=\"math/tex; mode=display\">\nE_{out}(g_{m*}) \\leq E_{out}(g_{m^-}) \\leq E_{test}(g_{m^-}) + O(\\sqrt{\\frac{logM}{K}}\n\\tag{$2$}</script><p>下面我们举个例子来解释这种模型选择的方法的优越性，假设有两个模型：一个是5阶多项式HΦ5，一个是10阶多项式HΦ10。通过不使用验证集和使用验证集两种方法对模型选择结果进行比较，分析结果如图二所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/70d9d9faae5aed3273361b2fb4a776cf83c9fb27/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-2%20Validation%20in%20Practice.png\" alt=\"Validation in Practice\"></p>\n<center> 图二 Validation in Practice <sup>[1]</sup></center>\n\n<p>图中，横坐标表示验证集数量K，纵坐标表示 $E_{out}$ 大小。黑色水平线表示没有验证集，完全使用 $E_{in}$ 作为判断基准，那么 $H_{\\Phi 10}$ 更好一些，但是这种方法的 $E_{out}$ 比较大，而且与K无关。黑色虚线表示测试集非常接近实际数据，这是一种理想的情况，其 $E_{out}$ 很小，同样也与K无关，实际中很难得到这条虚线。</p>\n<p>红色曲线表示使用验证集，但是最终选取的矩是 $g_{m^\\ast}^-$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先减小再增大，当K大于一定值的时候，甚至会超过黑色水平线。蓝色曲线表示也使用验证集，最终选取的矩是 $g_{m^\\ast}$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先缓慢减小再缓慢增大，且一直位于红色曲线和黑色直线之下。从此可见，蓝色曲线对应的方法最好，符合我们之前讨论的使用验证集进行模型选择效果最好。</p>\n<p>但是也存在问题，当 K 太大的时候，红色曲线会超过黑色直线，也就是上面提到的，选择了太多的数据作为验证集，从而导致训练的数据大大减少，那么模型的泛化能力太差，不能保证 $E_{in} \\approx E_{out}$</p>\n<blockquote>\n<p>那么如何选择 K呢？</p>\n</blockquote>\n<p>老师的建议是选择 $K = \\frac{N}{5}$</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Leave-One-Out-Cross-Validation\"><a href=\"#3-Leave-One-Out-Cross-Validation\" class=\"headerlink\" title=\"3. Leave-One-Out Cross Validation\"></a>3. Leave-One-Out Cross Validation</h2><p>上一节，最后我们提到了K值得重要性，下面我们将讨论如何让这个数据取得更加合理。</p>\n<p>第一种方法叫做： Leave-One-Out Cross Validation(留一法交叉验证)，这方法是采用一种极端的情况（K=1），也就是说验证集大小为1，即每次只用一组数据对 $g_m$ 进行验证，重复N次，最后求平均误差。</p>\n<p>这种算法的优缺点如下：</p>\n<ul>\n<li>优点：使得 $g_m^- \\approx g_m$</li>\n<li>缺点：①$E_{val}$ 与 $E_{out}$  可能会相差很大 ②时间和空间复杂度非常大 ③稳定性差（例如对于二分类问题，取值只有0和1两种，预测本身存在不稳定的因素，那么对所有的Eloocv计算平均值可能会带来很大的数值跳动）</li>\n</ul>\n<p>误差方程的表达式如公式（3）所示。</p>\n<script type=\"math/tex; mode=display\">\nE_{loocv}(H, A) = \\frac{1}{N} \\sum\\limits_{n=1}^{N} \\cdot err(g_n^-(x_n), y_n)\n\\tag{$3$}</script><p>该算法的具体流程如下：</p>\n<p>1.取n=1的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$</p>\n<p>2.接着取n=2的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$</p>\n<p>3.以此类推，重复N次，直到n=N的点也进行上述的操作</p>\n<p>4.把N次误差加起来求平均</p>\n<p>课上举了一个例子说明该方法的效果并且总结了Feature的多少与 $E_{in} E_{out} E_{loocv}$的关系。如图三所示。很明显可以看出，使用Ein发生了过拟合，而Eloocv分类效果更好，泛化能力强。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a5de867bdf6c5738844287c3de950431325891b0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-4%20Leave-One-Out%20in%20Practice.png\" alt=\"Leave-One-Out in Practice\"></p>\n<center> 图三 Leave-One-Out in Practice <sup>[2]</sup></center>\n\n\n<p>但是这种方法由于他的缺点太多，所以实际中往往很少使用。更多的是使用下面要讨论的V-Fold Cross Validation</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-V-Fold-Cross-Validation\"><a href=\"#4-V-Fold-Cross-Validation\" class=\"headerlink\" title=\"4. V-Fold Cross Validation\"></a>4. V-Fold Cross Validation</h2><p>上面讨论的Leave-One-Out Cross Validation 的优缺点导致了该算法不好用。所以针对该算法的缺点，人们对其改进为V-Fold Cross Validation: 这种算法是把数据N平均分为V分，每次取一份作为验证集，剩下的V-1份作为测试集，重复V次，算出平均误差。那样的话Leave-One-Out Cross Validation 可以看成是V=N的极端情况</p>\n<p>该算法的误差方程如公式（4）所示</p>\n<script type=\"math/tex; mode=display\">\nE_{cv}(H, A) = \\frac{1}{V} \\sum\\limits_{V=1}^{V} E_{val}^{(v)}(g_v^-)\n\\tag{$4$}</script><p>一般的Validation使用V-Fold Cross Validation来选择最佳的模型。</p>\n<p>但是该算法也有一点问题：就是Validation的数据来源是集中的，所以并不能保证交叉验证的效果好，得到的数学模型一定就很好。只有在样本数据足够多的时候，结果才可信，数学模型泛化能力越强。</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了validation验证的意义</li>\n<li>然后介绍了Leave-One-Out算法并分析其优劣：该算法在实际应用不多</li>\n<li>最后根据Leave-One-Out算法的缺点，做改进，提出了V-Fold Cross Validation</li>\n</ol>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\15\\15 - 1 - Model Selection Problem (16-00)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\15\\15 - 3 - Leave-One-Out Cross Validation (16-06)</p>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Better-Validation\"><a href=\"#How-can-Machine-Learn-Better-Validation\" class=\"headerlink\" title=\"How can Machine Learn Better? - Validation\"></a>How can Machine Learn Better? - Validation</h1><blockquote>\n<p>这一节我们Validation，需要选择的原因是机器学习的算法有很多种，如何评估哪一种适合当前的使用场景是一个值得商榷的问题。所以通过Validation，我们可以对模型的误差有一定的测试，评估，从而可以确定我们所需要的模型。</p>\n</blockquote>\n<h2 id=\"1-Model-Selection-Problem\"><a href=\"#1-Model-Selection-Problem\" class=\"headerlink\" title=\"1. Model Selection Problem\"></a>1. Model Selection Problem</h2><p>到目前为止，已经学过了许多算法模型，但一个模型需要很多参数的选择，这是本章讨论的重点。</p>\n<p>以二元分类为例，在学过的算法有PLA、pocket、线性回归、logistic回归；算法中需要用到迭代方法，就需要选择迭代步骤T；同理也需要选择学习步长 ；处理非线性问题时，需要用到不同的转换函数，可能是线性的，二次式，10次多项式或者10次勒让德多项式；如果加上正则化项，则可以选择L2正则化项，L1正则化项；有了正则化项，则参数 值也需要选择。</p>\n<p>在如此多的选项中设计一个适用于各种情况各个数据集的模型显然是不可能的，因此针对不同的情况，对各个参数的选择是必须的。</p>\n<p>我们主要是通过误差 E 来进行判断一个模型是否良好的。我们有 $E_{out}$ 和 $E_{in}$</p>\n<ol>\n<li>显然我们不能通过 $E_{out}$ 来进行评估，因为我们不可能拿得到未来要进行测试用的数据。</li>\n<li>但是我们也不能通过 $E_{in}$ 来进行并评估，因为从前面2节的讨论中，我们知道，模型复杂度越高的模型， $E_{in}$ 往往就越高，但是也造成了模型的泛化能力变弱，使得  $E_{out} \\approx E_{in}$ 的条件不成立，根本谈不上机器学习了。</li>\n</ol>\n<p>但是我们能否采用另一个相对宽松的误差来作为评估呢？比如说:有这样一个独立于训练样本的测试集，将M个模型在测试集上进行测试，看一下Etest的大小，则选取Etest最小的模型作为最佳模型。</p>\n<blockquote>\n<p>是可以的，因为我们有Hoeffding Inequity作为理论保证</p>\n</blockquote>\n<p>下面我们将讨论这个宽松的误差。<br>1.首先，这个最小的测试集选出来的权值满足公式（1），其中 $m^\\ast$ 表示最佳的权值</p>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmin}{argmin}\nm^* = \\argmin\\limits_{1 \\leq m \\leq M} (E_m = E_{test}(A_m(D)))\n\\tag{$1$}</script><p>2.这种测试集验证的方法，根据finite-bin Hoffding不等式，可以得到公式（2），并且可以看出，模型个数M越少，测试集数目越大，那么 $O(\\sqrt{\\frac{logM}{N_{test}}}$ 越小，即 $E_{test}(g_{m^\\ast})$ 越接近于 $E_{out}(g_{m^\\ast})$ 。</p>\n<script type=\"math/tex; mode=display\">\nE_{out}(g_{m^\\ast}) \\leq E_{test}(g_{m^\\ast}) + O(\\sqrt{\\frac{logM}{N_{test}}}\n\\tag{$2$}</script><p>下面比较一下使用 $E_{in}$ 和 $E_{test}$ 作为评估基准的方法：</p>\n<ol>\n<li>使用 $E_{in}$ 作为判断基准，使用的数据集就是训练集D本身；不仅使用D来训练不同的 $g_{m^\\ast}$ ，而且又使用D来选择最好的 $g_{m^\\ast}$ ，那么 $g_{m^\\ast}$ 对未知数据并不一定泛化能力好。课堂中举的例子是：，老师用学生做过的练习题训练学生，然后再用一样的题目来对学生进行考试，这种方法即使学生得到高分，也不能说明他的真的掌握了知识。所以最小化 $E_{in}$ 的方法并不科学。</li>\n<li>第使用 $E_{test}$ 作为判断基准，使用的是独立于训练集D之外的测试集。而后者使用的是独立于D的测试集，相当于用一份题目来训练学生后，再用另外一份全新的题目来测试学生的水平，这样更能反映出学生对知识点的理解，所以最小化 $E_{test}$ 更加理想。但是真正的训练集是拿不到的（要实际投入使用才知道）。所以，寻找一种折中的办法，我们可以使用已有的训练集D来创造一个验证集validation set，即从D中划出一部分 $D_{val}$ 作为验证集。D另外的部分作为训练模型使用， $D_{val}$ 独立开来，用来测试各个模型的好坏，最小化 $E_{val}$ ，从而选择最佳的 $g_{m^\\ast}$ ∗。</li>\n</ol>\n<blockquote>\n<p>下面，我们针对验证集的选择进行讨论。</p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Validation\"><a href=\"#2-Validation\" class=\"headerlink\" title=\"2. Validation\"></a>2. Validation</h2><p>验证集的选择，我们必须遵循几点：</p>\n<ol>\n<li>选择要随机 - 造成数据不平衡，结果有问题</li>\n<li>数据量分配要合理 - 过多的验证集会造成训练集的减少，过少的验证集验证结果可信度不高</li>\n<li>验证集必须是新的，没有被用于训练 - 那就等于是直接用训练集去做验证了</li>\n</ol>\n<p>所以为了满足这3个条件，我们下面需要讨论如何来划分数据集</p>\n<p>1.首先我们将原本的数据样本D分为两部分： 训练数据 $D_{train}$ 和 验证数据 $D_{val}$， 如公式（3）所示，如图一所示。</p>\n<script type=\"math/tex; mode=display\">\n\\underbrace{D}_{size=N} = \\underbrace{D_{train}}_{size=N-K} \\cup \\underbrace{D_{val}}_{size=K}\n\\tag{$3$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9bf9752d63dd11988ef0024464fe257c99f4827a/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-1%20Validation%20Set.png\" alt=\"Validation Set\"></p>\n<center> 图一 Validation Set <sup>[1]</sup></center>\n\n\n<p>2.根据Hoeffding Inequity，我们可以得到公式（4）</p>\n<script type=\"math/tex; mode=display\">\nE_{out}(g_{m*}) \\leq E_{out}(g_{m^-}) \\leq E_{test}(g_{m^-}) + O(\\sqrt{\\frac{logM}{K}}\n\\tag{$2$}</script><p>下面我们举个例子来解释这种模型选择的方法的优越性，假设有两个模型：一个是5阶多项式HΦ5，一个是10阶多项式HΦ10。通过不使用验证集和使用验证集两种方法对模型选择结果进行比较，分析结果如图二所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/70d9d9faae5aed3273361b2fb4a776cf83c9fb27/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-2%20Validation%20in%20Practice.png\" alt=\"Validation in Practice\"></p>\n<center> 图二 Validation in Practice <sup>[1]</sup></center>\n\n<p>图中，横坐标表示验证集数量K，纵坐标表示 $E_{out}$ 大小。黑色水平线表示没有验证集，完全使用 $E_{in}$ 作为判断基准，那么 $H_{\\Phi 10}$ 更好一些，但是这种方法的 $E_{out}$ 比较大，而且与K无关。黑色虚线表示测试集非常接近实际数据，这是一种理想的情况，其 $E_{out}$ 很小，同样也与K无关，实际中很难得到这条虚线。</p>\n<p>红色曲线表示使用验证集，但是最终选取的矩是 $g_{m^\\ast}^-$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先减小再增大，当K大于一定值的时候，甚至会超过黑色水平线。蓝色曲线表示也使用验证集，最终选取的矩是 $g_{m^\\ast}$ ，其趋势是随着K的增加，它对应的 $E_{out}$ 先缓慢减小再缓慢增大，且一直位于红色曲线和黑色直线之下。从此可见，蓝色曲线对应的方法最好，符合我们之前讨论的使用验证集进行模型选择效果最好。</p>\n<p>但是也存在问题，当 K 太大的时候，红色曲线会超过黑色直线，也就是上面提到的，选择了太多的数据作为验证集，从而导致训练的数据大大减少，那么模型的泛化能力太差，不能保证 $E_{in} \\approx E_{out}$</p>\n<blockquote>\n<p>那么如何选择 K呢？</p>\n</blockquote>\n<p>老师的建议是选择 $K = \\frac{N}{5}$</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Leave-One-Out-Cross-Validation\"><a href=\"#3-Leave-One-Out-Cross-Validation\" class=\"headerlink\" title=\"3. Leave-One-Out Cross Validation\"></a>3. Leave-One-Out Cross Validation</h2><p>上一节，最后我们提到了K值得重要性，下面我们将讨论如何让这个数据取得更加合理。</p>\n<p>第一种方法叫做： Leave-One-Out Cross Validation(留一法交叉验证)，这方法是采用一种极端的情况（K=1），也就是说验证集大小为1，即每次只用一组数据对 $g_m$ 进行验证，重复N次，最后求平均误差。</p>\n<p>这种算法的优缺点如下：</p>\n<ul>\n<li>优点：使得 $g_m^- \\approx g_m$</li>\n<li>缺点：①$E_{val}$ 与 $E_{out}$  可能会相差很大 ②时间和空间复杂度非常大 ③稳定性差（例如对于二分类问题，取值只有0和1两种，预测本身存在不稳定的因素，那么对所有的Eloocv计算平均值可能会带来很大的数值跳动）</li>\n</ul>\n<p>误差方程的表达式如公式（3）所示。</p>\n<script type=\"math/tex; mode=display\">\nE_{loocv}(H, A) = \\frac{1}{N} \\sum\\limits_{n=1}^{N} \\cdot err(g_n^-(x_n), y_n)\n\\tag{$3$}</script><p>该算法的具体流程如下：</p>\n<p>1.取n=1的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$</p>\n<p>2.接着取n=2的点出来做验证集，其他点保留作为训练集，求出Hypothesis 和对应的 误差 $err(g_n^-(x_n), y_n)$</p>\n<p>3.以此类推，重复N次，直到n=N的点也进行上述的操作</p>\n<p>4.把N次误差加起来求平均</p>\n<p>课上举了一个例子说明该方法的效果并且总结了Feature的多少与 $E_{in} E_{out} E_{loocv}$的关系。如图三所示。很明显可以看出，使用Ein发生了过拟合，而Eloocv分类效果更好，泛化能力强。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/a5de867bdf6c5738844287c3de950431325891b0/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter13-4%20Leave-One-Out%20in%20Practice.png\" alt=\"Leave-One-Out in Practice\"></p>\n<center> 图三 Leave-One-Out in Practice <sup>[2]</sup></center>\n\n\n<p>但是这种方法由于他的缺点太多，所以实际中往往很少使用。更多的是使用下面要讨论的V-Fold Cross Validation</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-V-Fold-Cross-Validation\"><a href=\"#4-V-Fold-Cross-Validation\" class=\"headerlink\" title=\"4. V-Fold Cross Validation\"></a>4. V-Fold Cross Validation</h2><p>上面讨论的Leave-One-Out Cross Validation 的优缺点导致了该算法不好用。所以针对该算法的缺点，人们对其改进为V-Fold Cross Validation: 这种算法是把数据N平均分为V分，每次取一份作为验证集，剩下的V-1份作为测试集，重复V次，算出平均误差。那样的话Leave-One-Out Cross Validation 可以看成是V=N的极端情况</p>\n<p>该算法的误差方程如公式（4）所示</p>\n<script type=\"math/tex; mode=display\">\nE_{cv}(H, A) = \\frac{1}{V} \\sum\\limits_{V=1}^{V} E_{val}^{(v)}(g_v^-)\n\\tag{$4$}</script><p>一般的Validation使用V-Fold Cross Validation来选择最佳的模型。</p>\n<p>但是该算法也有一点问题：就是Validation的数据来源是集中的，所以并不能保证交叉验证的效果好，得到的数学模型一定就很好。只有在样本数据足够多的时候，结果才可信，数学模型泛化能力越强。</p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了validation验证的意义</li>\n<li>然后介绍了Leave-One-Out算法并分析其优劣：该算法在实际应用不多</li>\n<li>最后根据Leave-One-Out算法的缺点，做改进，提出了V-Fold Cross Validation</li>\n</ol>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\15\\15 - 1 - Model Selection Problem (16-00)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\15\\15 - 3 - Leave-One-Out Cross Validation (16-06)</p>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"12.How can Machine Learn Better? - Regularization","date":"2017-10-17T03:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# How can Machine Learn Better? - Regularization\n\n\n## 1. Regularized Hypothesis Set\n正则化的主要思想：将假设函数从高次多项式的数降低到低次，即把复杂的模型变成简单模型。如图一所示的表示高次多项式函数，明显产生了过拟合现象，而左图的表示使用正则化后的低次函数。并且从图中的下方的Hypothesis Set的圈中可以看出，高次的多项式会包含低次的多项式。所以在转换的过程，就是把模型从外圈降至内圈的过程。\n\n> 但是：Regularization 不适用于多个解的模型，因为在降阶的过程中面临着选择最适解\n\n![Regularization Fit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1ef39e622b59906f5831d3493e000c306845a087/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-1%20Regularization%20Fit.png)\n<center> 图一 Regularization Fit <sup>[1]</sup></center>\n\n\n下面来讨论如何进行降阶：\n1.首先我们在列出10次和2次的多项式，如公式（1）（2）所示。对比可以发现，其实 $H_2$ 可以看成是 $H_{10}$ 的3~10次项的系数为0，如公式（3）所示，其中 $s.t.$ 是subject to的意思，即约束条件\n\n$$\nH_{10} = w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10}\n\\tag{$1$}\n$$\n\n$$\nH_{2} = w_0 + w_1 x + w_2 x^2\n\\tag{$2$}\n$$\n\n\n$$\nH_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. w_3= w_4 = \\dots = w_{10} =0\n\\tag{$3$}\n$$\n\n2.接着我们稍微放宽一下条件：我们不限定说一定要 3~10次多项式系数为0，我们只要要求满足有8项为0，即3项不为零（包括常数项），如公式（4）所示。这种Hypothesis称为 $H^{\\prime}_2$。并且这个Hypothesis与 $H_2$ $H_{10}$ 的关系如公式（5）所示。显然，  $H^{\\prime}_2$ 比 $H_2$ 更加的Flexible， 而 $H^{\\prime}_2$ 比 $H_{10}$ 的复杂度更低。\n\n$$\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10}(w_q \\neq 0) \\leq 3\n\\tag{$4$}\n$$\n\n$$\nH_2 \\subset  H^{\\prime}_{2} \\subset H_{10}\n\\tag{$5$}\n$$\n\n3.但是这个Hypothesis $H^{\\prime}_2$ 的求解也是一个NP-Hard问题。所以我们继续寻找容易求解的宽松情况。如公式（6）所示，这种Hypothesis我们称为 $H(C)$ 其中C为常数，H(C)称为regularized hypothesis set。这个方程的限定条件是让 权重的平方和小于C，当C增大时，限定的条件越宽松。如果C接近于无穷大，那么就和 $H_{10}$ 没什么区别了,如公式（7）所示\n\n$$\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10} w_q^2 = ||w||^2 \\leq C\n\\tag{$6$}\n$$\n\n$$\nH(0) \\subset H(1.126) \\subset \\dots \\subset H(1126) \\subset \\dots \\subset H(\\infty) \\subset H(10)\n\\tag{$7$}\n$$\n\n这种形式的限定条件是可以进行求解的，我们把求解的满足限定条件的权重w记为wREG。接下来就要探讨如何求解wREG。\n\n\n<br><br>\n----------------------------------\n\n## 2. Weight Decay Regularization\n1.首先我们为了表示方便，把公式（6）做一定的调整：写成向量矩阵的形式，得到公式（8）\n\n$$\n\\min\\limits_{w \\in R^{Q+1}} E_{in}(w) = \\frac{1}{N} \\underbrace{\\sum\\limits_{n=1}{N} (w^Tz_n - y_n) ^ 2}_{(Zw-y)^T(Zw-y)} \\quad\n\ns.t. \\underbrace{\\sum\\limits_{q=0}^Q w_q^2}_{w^Tw} \\leq C\n\\tag{$8$}\n$$\n\n\n\n2.我们的目的是计算 $E_{in}(w)$ 的最小值，其中限定条件是 $||w2|| \\leq C$ 如图二所示，这个限定条件从几何角度上的意思是，权重w被限定在半径为 $\\sqrt C$ 的圆内（红色的圆），而球外的w都不符合要求，即便它是靠近 $E_{in}(w)$ 梯度为零的w。\n\n实际的变化方向如蓝色的向量 $- \\nabla E_{in}$ 所示，其中红色向量normal 限定了切线的法向量的方向，而绿色的向量 $W_{lin}$ 就是我们需要想方法找到让他最短的时刻。\n\n显然，红色和绿色的向量其实就是蓝色向量的相互垂直的分向量，由高中的数学知识，我们知道，当蓝色向量越接近于红色的向量，那么绿色的向量长度越小，即如公式（9）所示\n\n$$\n- \\nabla E_{in}(W_{REG}) \\propto W_{REG}\n\\tag{$9$}\n$$\n\n\n![The Lagrange Multiplier](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/097a94496bbb81ecd7927daf3b0a828b057929f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-2%20The%20Lagrange%20Multiplier.png)\n<center> 图二 The Lagrange Multiplier <sup>[2]</sup></center>\n\n\n3.然后我们队公式（9）加入拉格朗日算子 $\\lambda$ ， 进行调整得到公式（10）\n\n$$\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) \\propto \\frac{2 \\lambda}{N} W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & \\frac{2}{N} (Z^TZW_{REG} - Z^Ty) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & W_{REG} = (Z^T Z + \\lambda I )^{-1} Z^Ty\n\\end{align}\n\\tag{$10$}\n$$\n\n上式中包含了求逆矩阵的过程，因为 $Z^TZ$ 是半正定矩阵，如果 $\\lambda$ 大于零，那么 $Z^T Z+\\lambda I$ 一定是正定矩阵，即一定可逆。统计学上把这叫做ridge regression(岭回归)\n\n\n4.如果把公式（10）的反过来求积分，我们可以得到公式（11）。该表达式称为增广错误（augmented error）用 $E_{aug}(w)$ 表示，其中 $w^T w$ 为正则化项（regularizer）。之所以叫做增广错误，是因为比传统的多了一正则化项。\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & E_{aug}(w) =E_{in} + \\frac{\\lambda}{N} w^Tw \\\\\n\\Longrightarrow    & W_{REG} = \\argmin\\limits_w E_{in}(w) + \\frac{\\lambda}{N} w^Tw\n\\end{align}\n\\tag{$11$}\n$$\n\n所以我们只需要调整不同的 $\\lambda$ 的值就可以对模型复杂度进行一定的调整，如图三所示。\n\n![Result of Weith Decay Regularization](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ebda6e4b5050786832ddb317e28aaa7807be465c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-3%20Result%20of%20Weith%20Decay%20Regularization.png)\n<center> 图三 Result of Weith Decay Regularization <sup>[2]</sup></center>\n\n从图中可以看出，当λ=0时，发生了过拟合；当λ=0.0001时，拟合的效果很好；当λ=0.01和λ=1时，发生了欠拟合。我们可以把λ看成是一种penality，即对hypothesis复杂度的惩罚，λ越大，w就越小，对应于C值越小，即这种惩罚越大，拟合曲线就会越平滑，高阶项就会削弱，容易发生欠拟合。λ一般取比较小的值就能达到良好的拟合效果，过大过小都有问题，但究竟取什么值，要根据具体训练数据和模型进行分析与调试。\n\n这种regularization不仅可以用在多项式的hypothesis中，还可以应用在logistic regression等其他hypothesis中，都可以达到防止过拟合的效果。\n\n但是这种方法有一个问题：我们目前讨论的多项式是形如x,x2,x3,⋯,xn的形式，若x的范围限定在[-1,1]之间，那么可能导致 $x_n$ 相对于低阶的值要小得多，则其对于的w非常大，相当于要给高阶项设置很大的惩罚。 也就是说我们无论让每个w的元素设定不同的 $\\lambda$ ， 从而如果x的范围很大的话，那么会使得部分数据很小。\n\n> 克服这个问题的方法是用Legendre Polynomials代替x,x2,x3,⋯,xn这种形式，Legendre Polynomials各项之间是正交的，用它进行多项式拟合的效果更好。\n\n\n<br><br>\n----------------------------------\n\n\n## 3. Regularization and VC Theory\n本节介绍正则化与VC理论的关系。即从VC理论的角度说明为什么正则化的效果好\n> 我们将从2个角度来讨论这个问题： 1) 误差方程 2） VC Dimension\n\n\n1.首先对比 Augmented Error 和 VC Bound， 如图四所示\n\n![Augmented Error and VC Bound](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/50e614a04c16b422bc446eac1bca54f9306c630f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-4%20Augmented%20Error%20and%20VC%20Bound.png)\n<center> 图四 Augmented Error and VC Bound <sup>[3]</sup></center>\n\n根据Augmented Error和VC Bound的表达式，$\\Omega (w)$ 包含于 $Ω(H)$ 之内，所以，$E_{aug}(w)$ 比 $E_{in}$ 更接近于 $E_{out}(w)$\n\n\n2.从VC Dimension的角度。根据VC Dimension理论，整个hypothesis set的 $d_{vc}=d˘+1$ ，这是因为所有的w都考虑了，没有任何限制条件。而引入限定条件的 $d_{vc}(H(C))=d_{EFF}(H,A)$ ，即有效的VC Dimension。很显然，$d_{vc}$ 比较大，因为它代表了整个hypothesis set，但是 $d_{EFF}(H,A)$ 比较小，因为由于regularized的影响，限定了w只取一小部分。\n\n所以当 $\\lambda = 0$的时候，所有的w都没有收到惩罚，所以都考虑了，此时的 $d_{vc}$ 比较大，容易产生overfitting，当 $\\lambda > 0$ 的时候， 部分w的乘以0而被放弃考虑，所以  $d_{vc}$ 比较小，模型的复杂度就降下来了，就解决了overfitting的问题。当然如果 $\\lambda$ 太大，使得过多的w被舍弃，那么就会出现 underfitting的情况了\n\n\n<br><br>\n----------------------------------\n\n\n\n## 4. General Regularizers\nRegularizers主要有 L0, L1 和L2，前面用到的是 L2的Regularizer\n关于范数的概念老师课上没有讲的很明白，可以参考这两篇博客，后续我也会写关于范数的博客\n> @ TODO L0、L1与L2范数\n\n[机器学习中的范数规则化之（一）L0、L1与L2范数](http://blog.csdn.net/zouxy09/article/details/24971995)\n\n[机器学习中的范数规则化之（二）核范数与规则项参数选择](http://blog.csdn.net/zouxy09/article/details/24972869)\n\n<br><br>\n----------------------------------\n\n\n\n\n\n# Summary\n1. 这一节首先介绍了Regularization：在Hypothesis Set的基础上 加入 Regularizer 作为 Penality。使得最终结果中的部分w被惩罚掉而不被考虑，从而实现了降低模型复杂度的功能。\n2. 接着我们讨论了为什么 Regularization 能让模型复杂度降低，并且模型的泛化能力更强\n3. 最后我们讨论了常用的范数:L0 L1 L2 范数\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\14\\14 - 1 - Regularized Hypothesis Set (19-16)\n\n[2] 机器学习基石(台湾大学-林轩田)\\14\\14 - 2 - Weight Decay Regularization (24-08)\n\n[3] 机器学习基石(台湾大学-林轩田)\\14\\14 - 3 - Regularization and VC Theory (08-15)\n\n\n<br><br>\n----------------------------------\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-17-12.How can Machine Learn Better - Regularization.md","raw":"---\ntitle: 12.How can Machine Learn Better? - Regularization\ndate: 2017-10-17 11:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# How can Machine Learn Better? - Regularization\n\n\n## 1. Regularized Hypothesis Set\n正则化的主要思想：将假设函数从高次多项式的数降低到低次，即把复杂的模型变成简单模型。如图一所示的表示高次多项式函数，明显产生了过拟合现象，而左图的表示使用正则化后的低次函数。并且从图中的下方的Hypothesis Set的圈中可以看出，高次的多项式会包含低次的多项式。所以在转换的过程，就是把模型从外圈降至内圈的过程。\n\n> 但是：Regularization 不适用于多个解的模型，因为在降阶的过程中面临着选择最适解\n\n![Regularization Fit](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1ef39e622b59906f5831d3493e000c306845a087/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-1%20Regularization%20Fit.png)\n<center> 图一 Regularization Fit <sup>[1]</sup></center>\n\n\n下面来讨论如何进行降阶：\n1.首先我们在列出10次和2次的多项式，如公式（1）（2）所示。对比可以发现，其实 $H_2$ 可以看成是 $H_{10}$ 的3~10次项的系数为0，如公式（3）所示，其中 $s.t.$ 是subject to的意思，即约束条件\n\n$$\nH_{10} = w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10}\n\\tag{$1$}\n$$\n\n$$\nH_{2} = w_0 + w_1 x + w_2 x^2\n\\tag{$2$}\n$$\n\n\n$$\nH_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. w_3= w_4 = \\dots = w_{10} =0\n\\tag{$3$}\n$$\n\n2.接着我们稍微放宽一下条件：我们不限定说一定要 3~10次多项式系数为0，我们只要要求满足有8项为0，即3项不为零（包括常数项），如公式（4）所示。这种Hypothesis称为 $H^{\\prime}_2$。并且这个Hypothesis与 $H_2$ $H_{10}$ 的关系如公式（5）所示。显然，  $H^{\\prime}_2$ 比 $H_2$ 更加的Flexible， 而 $H^{\\prime}_2$ 比 $H_{10}$ 的复杂度更低。\n\n$$\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10}(w_q \\neq 0) \\leq 3\n\\tag{$4$}\n$$\n\n$$\nH_2 \\subset  H^{\\prime}_{2} \\subset H_{10}\n\\tag{$5$}\n$$\n\n3.但是这个Hypothesis $H^{\\prime}_2$ 的求解也是一个NP-Hard问题。所以我们继续寻找容易求解的宽松情况。如公式（6）所示，这种Hypothesis我们称为 $H(C)$ 其中C为常数，H(C)称为regularized hypothesis set。这个方程的限定条件是让 权重的平方和小于C，当C增大时，限定的条件越宽松。如果C接近于无穷大，那么就和 $H_{10}$ 没什么区别了,如公式（7）所示\n\n$$\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10} w_q^2 = ||w||^2 \\leq C\n\\tag{$6$}\n$$\n\n$$\nH(0) \\subset H(1.126) \\subset \\dots \\subset H(1126) \\subset \\dots \\subset H(\\infty) \\subset H(10)\n\\tag{$7$}\n$$\n\n这种形式的限定条件是可以进行求解的，我们把求解的满足限定条件的权重w记为wREG。接下来就要探讨如何求解wREG。\n\n\n<br><br>\n----------------------------------\n\n## 2. Weight Decay Regularization\n1.首先我们为了表示方便，把公式（6）做一定的调整：写成向量矩阵的形式，得到公式（8）\n\n$$\n\\min\\limits_{w \\in R^{Q+1}} E_{in}(w) = \\frac{1}{N} \\underbrace{\\sum\\limits_{n=1}{N} (w^Tz_n - y_n) ^ 2}_{(Zw-y)^T(Zw-y)} \\quad\n\ns.t. \\underbrace{\\sum\\limits_{q=0}^Q w_q^2}_{w^Tw} \\leq C\n\\tag{$8$}\n$$\n\n\n\n2.我们的目的是计算 $E_{in}(w)$ 的最小值，其中限定条件是 $||w2|| \\leq C$ 如图二所示，这个限定条件从几何角度上的意思是，权重w被限定在半径为 $\\sqrt C$ 的圆内（红色的圆），而球外的w都不符合要求，即便它是靠近 $E_{in}(w)$ 梯度为零的w。\n\n实际的变化方向如蓝色的向量 $- \\nabla E_{in}$ 所示，其中红色向量normal 限定了切线的法向量的方向，而绿色的向量 $W_{lin}$ 就是我们需要想方法找到让他最短的时刻。\n\n显然，红色和绿色的向量其实就是蓝色向量的相互垂直的分向量，由高中的数学知识，我们知道，当蓝色向量越接近于红色的向量，那么绿色的向量长度越小，即如公式（9）所示\n\n$$\n- \\nabla E_{in}(W_{REG}) \\propto W_{REG}\n\\tag{$9$}\n$$\n\n\n![The Lagrange Multiplier](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/097a94496bbb81ecd7927daf3b0a828b057929f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-2%20The%20Lagrange%20Multiplier.png)\n<center> 图二 The Lagrange Multiplier <sup>[2]</sup></center>\n\n\n3.然后我们队公式（9）加入拉格朗日算子 $\\lambda$ ， 进行调整得到公式（10）\n\n$$\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) \\propto \\frac{2 \\lambda}{N} W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & \\frac{2}{N} (Z^TZW_{REG} - Z^Ty) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & W_{REG} = (Z^T Z + \\lambda I )^{-1} Z^Ty\n\\end{align}\n\\tag{$10$}\n$$\n\n上式中包含了求逆矩阵的过程，因为 $Z^TZ$ 是半正定矩阵，如果 $\\lambda$ 大于零，那么 $Z^T Z+\\lambda I$ 一定是正定矩阵，即一定可逆。统计学上把这叫做ridge regression(岭回归)\n\n\n4.如果把公式（10）的反过来求积分，我们可以得到公式（11）。该表达式称为增广错误（augmented error）用 $E_{aug}(w)$ 表示，其中 $w^T w$ 为正则化项（regularizer）。之所以叫做增广错误，是因为比传统的多了一正则化项。\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & E_{aug}(w) =E_{in} + \\frac{\\lambda}{N} w^Tw \\\\\n\\Longrightarrow    & W_{REG} = \\argmin\\limits_w E_{in}(w) + \\frac{\\lambda}{N} w^Tw\n\\end{align}\n\\tag{$11$}\n$$\n\n所以我们只需要调整不同的 $\\lambda$ 的值就可以对模型复杂度进行一定的调整，如图三所示。\n\n![Result of Weith Decay Regularization](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ebda6e4b5050786832ddb317e28aaa7807be465c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-3%20Result%20of%20Weith%20Decay%20Regularization.png)\n<center> 图三 Result of Weith Decay Regularization <sup>[2]</sup></center>\n\n从图中可以看出，当λ=0时，发生了过拟合；当λ=0.0001时，拟合的效果很好；当λ=0.01和λ=1时，发生了欠拟合。我们可以把λ看成是一种penality，即对hypothesis复杂度的惩罚，λ越大，w就越小，对应于C值越小，即这种惩罚越大，拟合曲线就会越平滑，高阶项就会削弱，容易发生欠拟合。λ一般取比较小的值就能达到良好的拟合效果，过大过小都有问题，但究竟取什么值，要根据具体训练数据和模型进行分析与调试。\n\n这种regularization不仅可以用在多项式的hypothesis中，还可以应用在logistic regression等其他hypothesis中，都可以达到防止过拟合的效果。\n\n但是这种方法有一个问题：我们目前讨论的多项式是形如x,x2,x3,⋯,xn的形式，若x的范围限定在[-1,1]之间，那么可能导致 $x_n$ 相对于低阶的值要小得多，则其对于的w非常大，相当于要给高阶项设置很大的惩罚。 也就是说我们无论让每个w的元素设定不同的 $\\lambda$ ， 从而如果x的范围很大的话，那么会使得部分数据很小。\n\n> 克服这个问题的方法是用Legendre Polynomials代替x,x2,x3,⋯,xn这种形式，Legendre Polynomials各项之间是正交的，用它进行多项式拟合的效果更好。\n\n\n<br><br>\n----------------------------------\n\n\n## 3. Regularization and VC Theory\n本节介绍正则化与VC理论的关系。即从VC理论的角度说明为什么正则化的效果好\n> 我们将从2个角度来讨论这个问题： 1) 误差方程 2） VC Dimension\n\n\n1.首先对比 Augmented Error 和 VC Bound， 如图四所示\n\n![Augmented Error and VC Bound](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/50e614a04c16b422bc446eac1bca54f9306c630f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-4%20Augmented%20Error%20and%20VC%20Bound.png)\n<center> 图四 Augmented Error and VC Bound <sup>[3]</sup></center>\n\n根据Augmented Error和VC Bound的表达式，$\\Omega (w)$ 包含于 $Ω(H)$ 之内，所以，$E_{aug}(w)$ 比 $E_{in}$ 更接近于 $E_{out}(w)$\n\n\n2.从VC Dimension的角度。根据VC Dimension理论，整个hypothesis set的 $d_{vc}=d˘+1$ ，这是因为所有的w都考虑了，没有任何限制条件。而引入限定条件的 $d_{vc}(H(C))=d_{EFF}(H,A)$ ，即有效的VC Dimension。很显然，$d_{vc}$ 比较大，因为它代表了整个hypothesis set，但是 $d_{EFF}(H,A)$ 比较小，因为由于regularized的影响，限定了w只取一小部分。\n\n所以当 $\\lambda = 0$的时候，所有的w都没有收到惩罚，所以都考虑了，此时的 $d_{vc}$ 比较大，容易产生overfitting，当 $\\lambda > 0$ 的时候， 部分w的乘以0而被放弃考虑，所以  $d_{vc}$ 比较小，模型的复杂度就降下来了，就解决了overfitting的问题。当然如果 $\\lambda$ 太大，使得过多的w被舍弃，那么就会出现 underfitting的情况了\n\n\n<br><br>\n----------------------------------\n\n\n\n## 4. General Regularizers\nRegularizers主要有 L0, L1 和L2，前面用到的是 L2的Regularizer\n关于范数的概念老师课上没有讲的很明白，可以参考这两篇博客，后续我也会写关于范数的博客\n> @ TODO L0、L1与L2范数\n\n[机器学习中的范数规则化之（一）L0、L1与L2范数](http://blog.csdn.net/zouxy09/article/details/24971995)\n\n[机器学习中的范数规则化之（二）核范数与规则项参数选择](http://blog.csdn.net/zouxy09/article/details/24972869)\n\n<br><br>\n----------------------------------\n\n\n\n\n\n# Summary\n1. 这一节首先介绍了Regularization：在Hypothesis Set的基础上 加入 Regularizer 作为 Penality。使得最终结果中的部分w被惩罚掉而不被考虑，从而实现了降低模型复杂度的功能。\n2. 接着我们讨论了为什么 Regularization 能让模型复杂度降低，并且模型的泛化能力更强\n3. 最后我们讨论了常用的范数:L0 L1 L2 范数\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\14\\14 - 1 - Regularized Hypothesis Set (19-16)\n\n[2] 机器学习基石(台湾大学-林轩田)\\14\\14 - 2 - Weight Decay Regularization (24-08)\n\n[3] 机器学习基石(台湾大学-林轩田)\\14\\14 - 3 - Regularization and VC Theory (08-15)\n\n\n<br><br>\n----------------------------------\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-17-12.How can Machine Learn Better - Regularization","published":1,"updated":"2018-10-27T04:30:42.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0c0002ce0ows105c1c8","content":"<h1 id=\"How-can-Machine-Learn-Better-Regularization\"><a href=\"#How-can-Machine-Learn-Better-Regularization\" class=\"headerlink\" title=\"How can Machine Learn Better? - Regularization\"></a>How can Machine Learn Better? - Regularization</h1><h2 id=\"1-Regularized-Hypothesis-Set\"><a href=\"#1-Regularized-Hypothesis-Set\" class=\"headerlink\" title=\"1. Regularized Hypothesis Set\"></a>1. Regularized Hypothesis Set</h2><p>正则化的主要思想：将假设函数从高次多项式的数降低到低次，即把复杂的模型变成简单模型。如图一所示的表示高次多项式函数，明显产生了过拟合现象，而左图的表示使用正则化后的低次函数。并且从图中的下方的Hypothesis Set的圈中可以看出，高次的多项式会包含低次的多项式。所以在转换的过程，就是把模型从外圈降至内圈的过程。</p>\n<blockquote>\n<p>但是：Regularization 不适用于多个解的模型，因为在降阶的过程中面临着选择最适解</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1ef39e622b59906f5831d3493e000c306845a087/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-1%20Regularization%20Fit.png\" alt=\"Regularization Fit\"></p>\n<center> 图一 Regularization Fit <sup>[1]</sup></center>\n\n\n<p>下面来讨论如何进行降阶：<br>1.首先我们在列出10次和2次的多项式，如公式（1）（2）所示。对比可以发现，其实 $H_2$ 可以看成是 $H_{10}$ 的3~10次项的系数为0，如公式（3）所示，其中 $s.t.$ 是subject to的意思，即约束条件</p>\n<script type=\"math/tex; mode=display\">\nH_{10} = w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10}\n\\tag{$1$}</script><script type=\"math/tex; mode=display\">\nH_{2} = w_0 + w_1 x + w_2 x^2\n\\tag{$2$}</script><script type=\"math/tex; mode=display\">\nH_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. w_3= w_4 = \\dots = w_{10} =0\n\\tag{$3$}</script><p>2.接着我们稍微放宽一下条件：我们不限定说一定要 3~10次多项式系数为0，我们只要要求满足有8项为0，即3项不为零（包括常数项），如公式（4）所示。这种Hypothesis称为 $H^{\\prime}_2$。并且这个Hypothesis与 $H_2$ $H_{10}$ 的关系如公式（5）所示。显然，  $H^{\\prime}_2$ 比 $H_2$ 更加的Flexible， 而 $H^{\\prime}_2$ 比 $H_{10}$ 的复杂度更低。</p>\n<script type=\"math/tex; mode=display\">\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10}(w_q \\neq 0) \\leq 3\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\nH_2 \\subset  H^{\\prime}_{2} \\subset H_{10}\n\\tag{$5$}</script><p>3.但是这个Hypothesis $H^{\\prime}_2$ 的求解也是一个NP-Hard问题。所以我们继续寻找容易求解的宽松情况。如公式（6）所示，这种Hypothesis我们称为 $H(C)$ 其中C为常数，H(C)称为regularized hypothesis set。这个方程的限定条件是让 权重的平方和小于C，当C增大时，限定的条件越宽松。如果C接近于无穷大，那么就和 $H_{10}$ 没什么区别了,如公式（7）所示</p>\n<script type=\"math/tex; mode=display\">\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10} w_q^2 = ||w||^2 \\leq C\n\\tag{$6$}</script><script type=\"math/tex; mode=display\">\nH(0) \\subset H(1.126) \\subset \\dots \\subset H(1126) \\subset \\dots \\subset H(\\infty) \\subset H(10)\n\\tag{$7$}</script><p>这种形式的限定条件是可以进行求解的，我们把求解的满足限定条件的权重w记为wREG。接下来就要探讨如何求解wREG。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Weight-Decay-Regularization\"><a href=\"#2-Weight-Decay-Regularization\" class=\"headerlink\" title=\"2. Weight Decay Regularization\"></a>2. Weight Decay Regularization</h2><p>1.首先我们为了表示方便，把公式（6）做一定的调整：写成向量矩阵的形式，得到公式（8）</p>\n<script type=\"math/tex; mode=display\">\n\\min\\limits_{w \\in R^{Q+1}} E_{in}(w) = \\frac{1}{N} \\underbrace{\\sum\\limits_{n=1}{N} (w^Tz_n - y_n) ^ 2}_{(Zw-y)^T(Zw-y)} \\quad\n\ns.t. \\underbrace{\\sum\\limits_{q=0}^Q w_q^2}_{w^Tw} \\leq C\n\\tag{$8$}</script><p>2.我们的目的是计算 $E_{in}(w)$ 的最小值，其中限定条件是 $||w2|| \\leq C$ 如图二所示，这个限定条件从几何角度上的意思是，权重w被限定在半径为 $\\sqrt C$ 的圆内（红色的圆），而球外的w都不符合要求，即便它是靠近 $E_{in}(w)$ 梯度为零的w。</p>\n<p>实际的变化方向如蓝色的向量 $- \\nabla E_{in}$ 所示，其中红色向量normal 限定了切线的法向量的方向，而绿色的向量 $W_{lin}$ 就是我们需要想方法找到让他最短的时刻。</p>\n<p>显然，红色和绿色的向量其实就是蓝色向量的相互垂直的分向量，由高中的数学知识，我们知道，当蓝色向量越接近于红色的向量，那么绿色的向量长度越小，即如公式（9）所示</p>\n<script type=\"math/tex; mode=display\">\n- \\nabla E_{in}(W_{REG}) \\propto W_{REG}\n\\tag{$9$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/097a94496bbb81ecd7927daf3b0a828b057929f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-2%20The%20Lagrange%20Multiplier.png\" alt=\"The Lagrange Multiplier\"></p>\n<center> 图二 The Lagrange Multiplier <sup>[2]</sup></center>\n\n\n<p>3.然后我们队公式（9）加入拉格朗日算子 $\\lambda$ ， 进行调整得到公式（10）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) \\propto \\frac{2 \\lambda}{N} W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & \\frac{2}{N} (Z^TZW_{REG} - Z^Ty) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & W_{REG} = (Z^T Z + \\lambda I )^{-1} Z^Ty\n\\end{align}\n\\tag{$10$}</script><p>上式中包含了求逆矩阵的过程，因为 $Z^TZ$ 是半正定矩阵，如果 $\\lambda$ 大于零，那么 $Z^T Z+\\lambda I$ 一定是正定矩阵，即一定可逆。统计学上把这叫做ridge regression(岭回归)</p>\n<p>4.如果把公式（10）的反过来求积分，我们可以得到公式（11）。该表达式称为增广错误（augmented error）用 $E_{aug}(w)$ 表示，其中 $w^T w$ 为正则化项（regularizer）。之所以叫做增广错误，是因为比传统的多了一正则化项。</p>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & E_{aug}(w) =E_{in} + \\frac{\\lambda}{N} w^Tw \\\\\n\\Longrightarrow    & W_{REG} = \\argmin\\limits_w E_{in}(w) + \\frac{\\lambda}{N} w^Tw\n\\end{align}\n\\tag{$11$}</script><p>所以我们只需要调整不同的 $\\lambda$ 的值就可以对模型复杂度进行一定的调整，如图三所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ebda6e4b5050786832ddb317e28aaa7807be465c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-3%20Result%20of%20Weith%20Decay%20Regularization.png\" alt=\"Result of Weith Decay Regularization\"></p>\n<center> 图三 Result of Weith Decay Regularization <sup>[2]</sup></center>\n\n<p>从图中可以看出，当λ=0时，发生了过拟合；当λ=0.0001时，拟合的效果很好；当λ=0.01和λ=1时，发生了欠拟合。我们可以把λ看成是一种penality，即对hypothesis复杂度的惩罚，λ越大，w就越小，对应于C值越小，即这种惩罚越大，拟合曲线就会越平滑，高阶项就会削弱，容易发生欠拟合。λ一般取比较小的值就能达到良好的拟合效果，过大过小都有问题，但究竟取什么值，要根据具体训练数据和模型进行分析与调试。</p>\n<p>这种regularization不仅可以用在多项式的hypothesis中，还可以应用在logistic regression等其他hypothesis中，都可以达到防止过拟合的效果。</p>\n<p>但是这种方法有一个问题：我们目前讨论的多项式是形如x,x2,x3,⋯,xn的形式，若x的范围限定在[-1,1]之间，那么可能导致 $x_n$ 相对于低阶的值要小得多，则其对于的w非常大，相当于要给高阶项设置很大的惩罚。 也就是说我们无论让每个w的元素设定不同的 $\\lambda$ ， 从而如果x的范围很大的话，那么会使得部分数据很小。</p>\n<blockquote>\n<p>克服这个问题的方法是用Legendre Polynomials代替x,x2,x3,⋯,xn这种形式，Legendre Polynomials各项之间是正交的，用它进行多项式拟合的效果更好。</p>\n</blockquote>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Regularization-and-VC-Theory\"><a href=\"#3-Regularization-and-VC-Theory\" class=\"headerlink\" title=\"3. Regularization and VC Theory\"></a>3. Regularization and VC Theory</h2><p>本节介绍正则化与VC理论的关系。即从VC理论的角度说明为什么正则化的效果好</p>\n<blockquote>\n<p>我们将从2个角度来讨论这个问题： 1) 误差方程 2） VC Dimension</p>\n</blockquote>\n<p>1.首先对比 Augmented Error 和 VC Bound， 如图四所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/50e614a04c16b422bc446eac1bca54f9306c630f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-4%20Augmented%20Error%20and%20VC%20Bound.png\" alt=\"Augmented Error and VC Bound\"></p>\n<center> 图四 Augmented Error and VC Bound <sup>[3]</sup></center>\n\n<p>根据Augmented Error和VC Bound的表达式，$\\Omega (w)$ 包含于 $Ω(H)$ 之内，所以，$E_{aug}(w)$ 比 $E_{in}$ 更接近于 $E_{out}(w)$</p>\n<p>2.从VC Dimension的角度。根据VC Dimension理论，整个hypothesis set的 $d_{vc}=d˘+1$ ，这是因为所有的w都考虑了，没有任何限制条件。而引入限定条件的 $d_{vc}(H(C))=d_{EFF}(H,A)$ ，即有效的VC Dimension。很显然，$d_{vc}$ 比较大，因为它代表了整个hypothesis set，但是 $d_{EFF}(H,A)$ 比较小，因为由于regularized的影响，限定了w只取一小部分。</p>\n<p>所以当 $\\lambda = 0$的时候，所有的w都没有收到惩罚，所以都考虑了，此时的 $d_{vc}$ 比较大，容易产生overfitting，当 $\\lambda &gt; 0$ 的时候， 部分w的乘以0而被放弃考虑，所以  $d_{vc}$ 比较小，模型的复杂度就降下来了，就解决了overfitting的问题。当然如果 $\\lambda$ 太大，使得过多的w被舍弃，那么就会出现 underfitting的情况了</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-General-Regularizers\"><a href=\"#4-General-Regularizers\" class=\"headerlink\" title=\"4. General Regularizers\"></a>4. General Regularizers</h2><p>Regularizers主要有 L0, L1 和L2，前面用到的是 L2的Regularizer<br>关于范数的概念老师课上没有讲的很明白，可以参考这两篇博客，后续我也会写关于范数的博客</p>\n<blockquote>\n<p>@ TODO L0、L1与L2范数</p>\n</blockquote>\n<p><a href=\"http://blog.csdn.net/zouxy09/article/details/24971995\" target=\"_blank\" rel=\"external\">机器学习中的范数规则化之（一）L0、L1与L2范数</a></p>\n<p><a href=\"http://blog.csdn.net/zouxy09/article/details/24972869\" target=\"_blank\" rel=\"external\">机器学习中的范数规则化之（二）核范数与规则项参数选择</a></p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>这一节首先介绍了Regularization：在Hypothesis Set的基础上 加入 Regularizer 作为 Penality。使得最终结果中的部分w被惩罚掉而不被考虑，从而实现了降低模型复杂度的功能。</li>\n<li>接着我们讨论了为什么 Regularization 能让模型复杂度降低，并且模型的泛化能力更强</li>\n<li>最后我们讨论了常用的范数:L0 L1 L2 范数</li>\n</ol>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\14\\14 - 1 - Regularized Hypothesis Set (19-16)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\14\\14 - 2 - Weight Decay Regularization (24-08)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\14\\14 - 3 - Regularization and VC Theory (08-15)</p>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Better-Regularization\"><a href=\"#How-can-Machine-Learn-Better-Regularization\" class=\"headerlink\" title=\"How can Machine Learn Better? - Regularization\"></a>How can Machine Learn Better? - Regularization</h1><h2 id=\"1-Regularized-Hypothesis-Set\"><a href=\"#1-Regularized-Hypothesis-Set\" class=\"headerlink\" title=\"1. Regularized Hypothesis Set\"></a>1. Regularized Hypothesis Set</h2><p>正则化的主要思想：将假设函数从高次多项式的数降低到低次，即把复杂的模型变成简单模型。如图一所示的表示高次多项式函数，明显产生了过拟合现象，而左图的表示使用正则化后的低次函数。并且从图中的下方的Hypothesis Set的圈中可以看出，高次的多项式会包含低次的多项式。所以在转换的过程，就是把模型从外圈降至内圈的过程。</p>\n<blockquote>\n<p>但是：Regularization 不适用于多个解的模型，因为在降阶的过程中面临着选择最适解</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/1ef39e622b59906f5831d3493e000c306845a087/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-1%20Regularization%20Fit.png\" alt=\"Regularization Fit\"></p>\n<center> 图一 Regularization Fit <sup>[1]</sup></center>\n\n\n<p>下面来讨论如何进行降阶：<br>1.首先我们在列出10次和2次的多项式，如公式（1）（2）所示。对比可以发现，其实 $H_2$ 可以看成是 $H_{10}$ 的3~10次项的系数为0，如公式（3）所示，其中 $s.t.$ 是subject to的意思，即约束条件</p>\n<script type=\"math/tex; mode=display\">\nH_{10} = w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10}\n\\tag{$1$}</script><script type=\"math/tex; mode=display\">\nH_{2} = w_0 + w_1 x + w_2 x^2\n\\tag{$2$}</script><script type=\"math/tex; mode=display\">\nH_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. w_3= w_4 = \\dots = w_{10} =0\n\\tag{$3$}</script><p>2.接着我们稍微放宽一下条件：我们不限定说一定要 3~10次多项式系数为0，我们只要要求满足有8项为0，即3项不为零（包括常数项），如公式（4）所示。这种Hypothesis称为 $H^{\\prime}_2$。并且这个Hypothesis与 $H_2$ $H_{10}$ 的关系如公式（5）所示。显然，  $H^{\\prime}_2$ 比 $H_2$ 更加的Flexible， 而 $H^{\\prime}_2$ 比 $H_{10}$ 的复杂度更低。</p>\n<script type=\"math/tex; mode=display\">\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10}(w_q \\neq 0) \\leq 3\n\\tag{$4$}</script><script type=\"math/tex; mode=display\">\nH_2 \\subset  H^{\\prime}_{2} \\subset H_{10}\n\\tag{$5$}</script><p>3.但是这个Hypothesis $H^{\\prime}_2$ 的求解也是一个NP-Hard问题。所以我们继续寻找容易求解的宽松情况。如公式（6）所示，这种Hypothesis我们称为 $H(C)$ 其中C为常数，H(C)称为regularized hypothesis set。这个方程的限定条件是让 权重的平方和小于C，当C增大时，限定的条件越宽松。如果C接近于无穷大，那么就和 $H_{10}$ 没什么区别了,如公式（7）所示</p>\n<script type=\"math/tex; mode=display\">\nH^{\\prime}_{2} =  w_0 + w_1 x + w_2 x^2 + w_3 x^3 + \\dots + w_{10} x^{10} \\quad s.t. \\sum\\limits_{q=0}^{10} w_q^2 = ||w||^2 \\leq C\n\\tag{$6$}</script><script type=\"math/tex; mode=display\">\nH(0) \\subset H(1.126) \\subset \\dots \\subset H(1126) \\subset \\dots \\subset H(\\infty) \\subset H(10)\n\\tag{$7$}</script><p>这种形式的限定条件是可以进行求解的，我们把求解的满足限定条件的权重w记为wREG。接下来就要探讨如何求解wREG。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Weight-Decay-Regularization\"><a href=\"#2-Weight-Decay-Regularization\" class=\"headerlink\" title=\"2. Weight Decay Regularization\"></a>2. Weight Decay Regularization</h2><p>1.首先我们为了表示方便，把公式（6）做一定的调整：写成向量矩阵的形式，得到公式（8）</p>\n<script type=\"math/tex; mode=display\">\n\\min\\limits_{w \\in R^{Q+1}} E_{in}(w) = \\frac{1}{N} \\underbrace{\\sum\\limits_{n=1}{N} (w^Tz_n - y_n) ^ 2}_{(Zw-y)^T(Zw-y)} \\quad\n\ns.t. \\underbrace{\\sum\\limits_{q=0}^Q w_q^2}_{w^Tw} \\leq C\n\\tag{$8$}</script><p>2.我们的目的是计算 $E_{in}(w)$ 的最小值，其中限定条件是 $||w2|| \\leq C$ 如图二所示，这个限定条件从几何角度上的意思是，权重w被限定在半径为 $\\sqrt C$ 的圆内（红色的圆），而球外的w都不符合要求，即便它是靠近 $E_{in}(w)$ 梯度为零的w。</p>\n<p>实际的变化方向如蓝色的向量 $- \\nabla E_{in}$ 所示，其中红色向量normal 限定了切线的法向量的方向，而绿色的向量 $W_{lin}$ 就是我们需要想方法找到让他最短的时刻。</p>\n<p>显然，红色和绿色的向量其实就是蓝色向量的相互垂直的分向量，由高中的数学知识，我们知道，当蓝色向量越接近于红色的向量，那么绿色的向量长度越小，即如公式（9）所示</p>\n<script type=\"math/tex; mode=display\">\n- \\nabla E_{in}(W_{REG}) \\propto W_{REG}\n\\tag{$9$}</script><p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/097a94496bbb81ecd7927daf3b0a828b057929f6/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-2%20The%20Lagrange%20Multiplier.png\" alt=\"The Lagrange Multiplier\"></p>\n<center> 图二 The Lagrange Multiplier <sup>[2]</sup></center>\n\n\n<p>3.然后我们队公式（9）加入拉格朗日算子 $\\lambda$ ， 进行调整得到公式（10）</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) \\propto \\frac{2 \\lambda}{N} W_{REG} \\\\\n\\Longrightarrow    & - \\nabla E_{in}(W_{REG}) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & \\frac{2}{N} (Z^TZW_{REG} - Z^Ty) + \\frac{2 \\lambda}{N} W_{REG} = 0 \\\\\n\\Longrightarrow    & W_{REG} = (Z^T Z + \\lambda I )^{-1} Z^Ty\n\\end{align}\n\\tag{$10$}</script><p>上式中包含了求逆矩阵的过程，因为 $Z^TZ$ 是半正定矩阵，如果 $\\lambda$ 大于零，那么 $Z^T Z+\\lambda I$ 一定是正定矩阵，即一定可逆。统计学上把这叫做ridge regression(岭回归)</p>\n<p>4.如果把公式（10）的反过来求积分，我们可以得到公式（11）。该表达式称为增广错误（augmented error）用 $E_{aug}(w)$ 表示，其中 $w^T w$ 为正则化项（regularizer）。之所以叫做增广错误，是因为比传统的多了一正则化项。</p>\n<script type=\"math/tex; mode=display\">\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\begin{align}\n                   & - \\nabla E_{in}(W_{REG}) \\propto W_{REG} \\\\\n\\Longrightarrow    & E_{aug}(w) =E_{in} + \\frac{\\lambda}{N} w^Tw \\\\\n\\Longrightarrow    & W_{REG} = \\argmin\\limits_w E_{in}(w) + \\frac{\\lambda}{N} w^Tw\n\\end{align}\n\\tag{$11$}</script><p>所以我们只需要调整不同的 $\\lambda$ 的值就可以对模型复杂度进行一定的调整，如图三所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/ebda6e4b5050786832ddb317e28aaa7807be465c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-3%20Result%20of%20Weith%20Decay%20Regularization.png\" alt=\"Result of Weith Decay Regularization\"></p>\n<center> 图三 Result of Weith Decay Regularization <sup>[2]</sup></center>\n\n<p>从图中可以看出，当λ=0时，发生了过拟合；当λ=0.0001时，拟合的效果很好；当λ=0.01和λ=1时，发生了欠拟合。我们可以把λ看成是一种penality，即对hypothesis复杂度的惩罚，λ越大，w就越小，对应于C值越小，即这种惩罚越大，拟合曲线就会越平滑，高阶项就会削弱，容易发生欠拟合。λ一般取比较小的值就能达到良好的拟合效果，过大过小都有问题，但究竟取什么值，要根据具体训练数据和模型进行分析与调试。</p>\n<p>这种regularization不仅可以用在多项式的hypothesis中，还可以应用在logistic regression等其他hypothesis中，都可以达到防止过拟合的效果。</p>\n<p>但是这种方法有一个问题：我们目前讨论的多项式是形如x,x2,x3,⋯,xn的形式，若x的范围限定在[-1,1]之间，那么可能导致 $x_n$ 相对于低阶的值要小得多，则其对于的w非常大，相当于要给高阶项设置很大的惩罚。 也就是说我们无论让每个w的元素设定不同的 $\\lambda$ ， 从而如果x的范围很大的话，那么会使得部分数据很小。</p>\n<blockquote>\n<p>克服这个问题的方法是用Legendre Polynomials代替x,x2,x3,⋯,xn这种形式，Legendre Polynomials各项之间是正交的，用它进行多项式拟合的效果更好。</p>\n</blockquote>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Regularization-and-VC-Theory\"><a href=\"#3-Regularization-and-VC-Theory\" class=\"headerlink\" title=\"3. Regularization and VC Theory\"></a>3. Regularization and VC Theory</h2><p>本节介绍正则化与VC理论的关系。即从VC理论的角度说明为什么正则化的效果好</p>\n<blockquote>\n<p>我们将从2个角度来讨论这个问题： 1) 误差方程 2） VC Dimension</p>\n</blockquote>\n<p>1.首先对比 Augmented Error 和 VC Bound， 如图四所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/50e614a04c16b422bc446eac1bca54f9306c630f/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter12-4%20Augmented%20Error%20and%20VC%20Bound.png\" alt=\"Augmented Error and VC Bound\"></p>\n<center> 图四 Augmented Error and VC Bound <sup>[3]</sup></center>\n\n<p>根据Augmented Error和VC Bound的表达式，$\\Omega (w)$ 包含于 $Ω(H)$ 之内，所以，$E_{aug}(w)$ 比 $E_{in}$ 更接近于 $E_{out}(w)$</p>\n<p>2.从VC Dimension的角度。根据VC Dimension理论，整个hypothesis set的 $d_{vc}=d˘+1$ ，这是因为所有的w都考虑了，没有任何限制条件。而引入限定条件的 $d_{vc}(H(C))=d_{EFF}(H,A)$ ，即有效的VC Dimension。很显然，$d_{vc}$ 比较大，因为它代表了整个hypothesis set，但是 $d_{EFF}(H,A)$ 比较小，因为由于regularized的影响，限定了w只取一小部分。</p>\n<p>所以当 $\\lambda = 0$的时候，所有的w都没有收到惩罚，所以都考虑了，此时的 $d_{vc}$ 比较大，容易产生overfitting，当 $\\lambda &gt; 0$ 的时候， 部分w的乘以0而被放弃考虑，所以  $d_{vc}$ 比较小，模型的复杂度就降下来了，就解决了overfitting的问题。当然如果 $\\lambda$ 太大，使得过多的w被舍弃，那么就会出现 underfitting的情况了</p>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"4-General-Regularizers\"><a href=\"#4-General-Regularizers\" class=\"headerlink\" title=\"4. General Regularizers\"></a>4. General Regularizers</h2><p>Regularizers主要有 L0, L1 和L2，前面用到的是 L2的Regularizer<br>关于范数的概念老师课上没有讲的很明白，可以参考这两篇博客，后续我也会写关于范数的博客</p>\n<blockquote>\n<p>@ TODO L0、L1与L2范数</p>\n</blockquote>\n<p><a href=\"http://blog.csdn.net/zouxy09/article/details/24971995\" target=\"_blank\" rel=\"external\">机器学习中的范数规则化之（一）L0、L1与L2范数</a></p>\n<p><a href=\"http://blog.csdn.net/zouxy09/article/details/24972869\" target=\"_blank\" rel=\"external\">机器学习中的范数规则化之（二）核范数与规则项参数选择</a></p>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>这一节首先介绍了Regularization：在Hypothesis Set的基础上 加入 Regularizer 作为 Penality。使得最终结果中的部分w被惩罚掉而不被考虑，从而实现了降低模型复杂度的功能。</li>\n<li>接着我们讨论了为什么 Regularization 能让模型复杂度降低，并且模型的泛化能力更强</li>\n<li>最后我们讨论了常用的范数:L0 L1 L2 范数</li>\n</ol>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\14\\14 - 1 - Regularized Hypothesis Set (19-16)</p>\n<p>[2] 机器学习基石(台湾大学-林轩田)\\14\\14 - 2 - Weight Decay Regularization (24-08)</p>\n<p>[3] 机器学习基石(台湾大学-林轩田)\\14\\14 - 3 - Regularization and VC Theory (08-15)</p>\n<h2 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"14.How can Machine Learn Better? - Three Learning Principles","date":"2017-10-21T03:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# How can Machine Learn Better? - Three Learning Principles\n\n> 这节课， 主要是介绍提高机器学习性能三个实用方法 Occam’s Razor, Sampling Bias, Data Snooping。\n\n## 1. Occam’s Razor\n奥卡姆剃刀定律（Occam’s Razor），这个原理称为“如无必要，勿增实体”（Entities must not be multiplied unnecessarily），就像剃刀一样，将不必要的部分去除掉。将奥卡姆剃刀定律应用在机器学习上意思是使用的模型尽可能的简单。\n\n如下面图一的例子\n\n![Occam's Razor for Learning](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/e2023177a2fc2da3d14e0c799981c3525217a2bd/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter14-1%20Occam's%20Razor%20for%20Learning.png)\n<center> 图一 Occam's Razor for Learning <sup>[1]</sup></center>\n\n\n上图就是一个模型选择的例子，左边的模型很简单，可能有分错的情况；而右边的模型非常复杂，所有的训练样本都分类正确。但是，我们会选择左边的模型，它更简单，符合人类直觉的解释方式。\n这样的结果带来两个问题：\n- 什么模型称得上是简单的？\n- 为什么简单模型比复杂模型要好？\n\n因为机器学习的本质在于通过学习，寻找数据的规则，从而投入到实践中。要在一堆没有规律的数据中找到一个规律既能反映数据的本质规律，又能完全没有错误是非常非常困难的（甚至是不可能的），所以我们要做的并不是要100%完美的在训练数据中找到规律，让 $E_{in}$ 为0，而是应该找到数据本身符合的规律。加上噪音的无处不在，所以在合适的规律的模型中，出现一定的错误是很正常的。\n\n所以在运用模型时，能使用简单的模型，就用简单的模型。简单而又实用的才是最好的！\n\n\n<br><br>\n----------------------------------\n\n## 2. Sampling Bias\n课上举了1948年美国选举，2个候选人A和B。一家报刊提前通过电话采访得到的结果是A会赢B，但是实际的结果却反过来。这是因为这家报刊在抽样调查的过程中只对某一阶层的人进行采访，所以导致了这个错误。\n\n这个例子给我们的教训就是，如果抽样有偏差的话，那么学习的结果也产生了偏差，这种情形称之为抽样偏差Sampling Bias。从技术上来说，就是训练数据和验证数据要服从同一个分布，最好都是独立同分布的，这样训练得到的模型才能更好地具有代表性。\n\n\n<br><br>\n----------------------------------\n\n## 3. Data Snooping\n课上举的例子是偷窥数据造成对结果的影响。很显然，我们不应该提前去偷窥数据，但是这个实际上又是不可能避免的，因为我们在开始之前就会根据以往的经验选择性的偏向于某一类模型去处理问题，或者避免再用某一些模型去学习。\n\n有2个方法可能尽可能减少数据偷窥\n1. “看不见”数据。当我们在选择模型的时候，尽量用我们的经验和知识来做判断选择，而不是通过数据来选择。先选模型，再看数据。\n2. 保持怀疑。不要对别人的说法信以为真，要通过自己的研究与测试来进行模型选择，这样得到比较正确的结论。\n\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先介绍了Occam’s Razor - 越简单而有效的模型越好！\n2. 然后说明了Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的\n3. 最后说明了Data Snooping带来的坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 1 - Occam-'s Razor (10-08)\n\n<br><br>\n----------------------------------\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-21-14.How can Machine Learn Better - Three Learning Principles.md","raw":"---\ntitle: 14.How can Machine Learn Better? - Three Learning Principles\ndate: 2017-10-21 11:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# How can Machine Learn Better? - Three Learning Principles\n\n> 这节课， 主要是介绍提高机器学习性能三个实用方法 Occam’s Razor, Sampling Bias, Data Snooping。\n\n## 1. Occam’s Razor\n奥卡姆剃刀定律（Occam’s Razor），这个原理称为“如无必要，勿增实体”（Entities must not be multiplied unnecessarily），就像剃刀一样，将不必要的部分去除掉。将奥卡姆剃刀定律应用在机器学习上意思是使用的模型尽可能的简单。\n\n如下面图一的例子\n\n![Occam's Razor for Learning](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/e2023177a2fc2da3d14e0c799981c3525217a2bd/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter14-1%20Occam's%20Razor%20for%20Learning.png)\n<center> 图一 Occam's Razor for Learning <sup>[1]</sup></center>\n\n\n上图就是一个模型选择的例子，左边的模型很简单，可能有分错的情况；而右边的模型非常复杂，所有的训练样本都分类正确。但是，我们会选择左边的模型，它更简单，符合人类直觉的解释方式。\n这样的结果带来两个问题：\n- 什么模型称得上是简单的？\n- 为什么简单模型比复杂模型要好？\n\n因为机器学习的本质在于通过学习，寻找数据的规则，从而投入到实践中。要在一堆没有规律的数据中找到一个规律既能反映数据的本质规律，又能完全没有错误是非常非常困难的（甚至是不可能的），所以我们要做的并不是要100%完美的在训练数据中找到规律，让 $E_{in}$ 为0，而是应该找到数据本身符合的规律。加上噪音的无处不在，所以在合适的规律的模型中，出现一定的错误是很正常的。\n\n所以在运用模型时，能使用简单的模型，就用简单的模型。简单而又实用的才是最好的！\n\n\n<br><br>\n----------------------------------\n\n## 2. Sampling Bias\n课上举了1948年美国选举，2个候选人A和B。一家报刊提前通过电话采访得到的结果是A会赢B，但是实际的结果却反过来。这是因为这家报刊在抽样调查的过程中只对某一阶层的人进行采访，所以导致了这个错误。\n\n这个例子给我们的教训就是，如果抽样有偏差的话，那么学习的结果也产生了偏差，这种情形称之为抽样偏差Sampling Bias。从技术上来说，就是训练数据和验证数据要服从同一个分布，最好都是独立同分布的，这样训练得到的模型才能更好地具有代表性。\n\n\n<br><br>\n----------------------------------\n\n## 3. Data Snooping\n课上举的例子是偷窥数据造成对结果的影响。很显然，我们不应该提前去偷窥数据，但是这个实际上又是不可能避免的，因为我们在开始之前就会根据以往的经验选择性的偏向于某一类模型去处理问题，或者避免再用某一些模型去学习。\n\n有2个方法可能尽可能减少数据偷窥\n1. “看不见”数据。当我们在选择模型的时候，尽量用我们的经验和知识来做判断选择，而不是通过数据来选择。先选模型，再看数据。\n2. 保持怀疑。不要对别人的说法信以为真，要通过自己的研究与测试来进行模型选择，这样得到比较正确的结论。\n\n\n\n<br><br>\n----------------------------------\n\n# Summary\n1. 首先介绍了Occam’s Razor - 越简单而有效的模型越好！\n2. 然后说明了Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的\n3. 最后说明了Data Snooping带来的坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度\n\n\n<br><br>\n----------------------------------\n\n# Reference\n[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 1 - Occam-'s Razor (10-08)\n\n<br><br>\n----------------------------------\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-21-14.How can Machine Learn Better - Three Learning Principles","published":1,"updated":"2018-10-27T04:30:42.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0c1002fe0owigimkmsw","content":"<h1 id=\"How-can-Machine-Learn-Better-Three-Learning-Principles\"><a href=\"#How-can-Machine-Learn-Better-Three-Learning-Principles\" class=\"headerlink\" title=\"How can Machine Learn Better? - Three Learning Principles\"></a>How can Machine Learn Better? - Three Learning Principles</h1><blockquote>\n<p>这节课， 主要是介绍提高机器学习性能三个实用方法 Occam’s Razor, Sampling Bias, Data Snooping。</p>\n</blockquote>\n<h2 id=\"1-Occam’s-Razor\"><a href=\"#1-Occam’s-Razor\" class=\"headerlink\" title=\"1. Occam’s Razor\"></a>1. Occam’s Razor</h2><p>奥卡姆剃刀定律（Occam’s Razor），这个原理称为“如无必要，勿增实体”（Entities must not be multiplied unnecessarily），就像剃刀一样，将不必要的部分去除掉。将奥卡姆剃刀定律应用在机器学习上意思是使用的模型尽可能的简单。</p>\n<p>如下面图一的例子</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/e2023177a2fc2da3d14e0c799981c3525217a2bd/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter14-1%20Occam&#39;s%20Razor%20for%20Learning.png\" alt=\"Occam&#39;s Razor for Learning\"></p>\n<center> 图一 Occam's Razor for Learning <sup>[1]</sup></center>\n\n\n<p>上图就是一个模型选择的例子，左边的模型很简单，可能有分错的情况；而右边的模型非常复杂，所有的训练样本都分类正确。但是，我们会选择左边的模型，它更简单，符合人类直觉的解释方式。<br>这样的结果带来两个问题：</p>\n<ul>\n<li>什么模型称得上是简单的？</li>\n<li>为什么简单模型比复杂模型要好？</li>\n</ul>\n<p>因为机器学习的本质在于通过学习，寻找数据的规则，从而投入到实践中。要在一堆没有规律的数据中找到一个规律既能反映数据的本质规律，又能完全没有错误是非常非常困难的（甚至是不可能的），所以我们要做的并不是要100%完美的在训练数据中找到规律，让 $E_{in}$ 为0，而是应该找到数据本身符合的规律。加上噪音的无处不在，所以在合适的规律的模型中，出现一定的错误是很正常的。</p>\n<p>所以在运用模型时，能使用简单的模型，就用简单的模型。简单而又实用的才是最好的！</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Sampling-Bias\"><a href=\"#2-Sampling-Bias\" class=\"headerlink\" title=\"2. Sampling Bias\"></a>2. Sampling Bias</h2><p>课上举了1948年美国选举，2个候选人A和B。一家报刊提前通过电话采访得到的结果是A会赢B，但是实际的结果却反过来。这是因为这家报刊在抽样调查的过程中只对某一阶层的人进行采访，所以导致了这个错误。</p>\n<p>这个例子给我们的教训就是，如果抽样有偏差的话，那么学习的结果也产生了偏差，这种情形称之为抽样偏差Sampling Bias。从技术上来说，就是训练数据和验证数据要服从同一个分布，最好都是独立同分布的，这样训练得到的模型才能更好地具有代表性。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Data-Snooping\"><a href=\"#3-Data-Snooping\" class=\"headerlink\" title=\"3. Data Snooping\"></a>3. Data Snooping</h2><p>课上举的例子是偷窥数据造成对结果的影响。很显然，我们不应该提前去偷窥数据，但是这个实际上又是不可能避免的，因为我们在开始之前就会根据以往的经验选择性的偏向于某一类模型去处理问题，或者避免再用某一些模型去学习。</p>\n<p>有2个方法可能尽可能减少数据偷窥</p>\n<ol>\n<li>“看不见”数据。当我们在选择模型的时候，尽量用我们的经验和知识来做判断选择，而不是通过数据来选择。先选模型，再看数据。</li>\n<li>保持怀疑。不要对别人的说法信以为真，要通过自己的研究与测试来进行模型选择，这样得到比较正确的结论。</li>\n</ol>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Occam’s Razor - 越简单而有效的模型越好！</li>\n<li>然后说明了Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的</li>\n<li>最后说明了Data Snooping带来的坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度</li>\n</ol>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 1 - Occam-‘s Razor (10-08)</p>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-can-Machine-Learn-Better-Three-Learning-Principles\"><a href=\"#How-can-Machine-Learn-Better-Three-Learning-Principles\" class=\"headerlink\" title=\"How can Machine Learn Better? - Three Learning Principles\"></a>How can Machine Learn Better? - Three Learning Principles</h1><blockquote>\n<p>这节课， 主要是介绍提高机器学习性能三个实用方法 Occam’s Razor, Sampling Bias, Data Snooping。</p>\n</blockquote>\n<h2 id=\"1-Occam’s-Razor\"><a href=\"#1-Occam’s-Razor\" class=\"headerlink\" title=\"1. Occam’s Razor\"></a>1. Occam’s Razor</h2><p>奥卡姆剃刀定律（Occam’s Razor），这个原理称为“如无必要，勿增实体”（Entities must not be multiplied unnecessarily），就像剃刀一样，将不必要的部分去除掉。将奥卡姆剃刀定律应用在机器学习上意思是使用的模型尽可能的简单。</p>\n<p>如下面图一的例子</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/e2023177a2fc2da3d14e0c799981c3525217a2bd/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter14-1%20Occam&#39;s%20Razor%20for%20Learning.png\" alt=\"Occam&#39;s Razor for Learning\"></p>\n<center> 图一 Occam's Razor for Learning <sup>[1]</sup></center>\n\n\n<p>上图就是一个模型选择的例子，左边的模型很简单，可能有分错的情况；而右边的模型非常复杂，所有的训练样本都分类正确。但是，我们会选择左边的模型，它更简单，符合人类直觉的解释方式。<br>这样的结果带来两个问题：</p>\n<ul>\n<li>什么模型称得上是简单的？</li>\n<li>为什么简单模型比复杂模型要好？</li>\n</ul>\n<p>因为机器学习的本质在于通过学习，寻找数据的规则，从而投入到实践中。要在一堆没有规律的数据中找到一个规律既能反映数据的本质规律，又能完全没有错误是非常非常困难的（甚至是不可能的），所以我们要做的并不是要100%完美的在训练数据中找到规律，让 $E_{in}$ 为0，而是应该找到数据本身符合的规律。加上噪音的无处不在，所以在合适的规律的模型中，出现一定的错误是很正常的。</p>\n<p>所以在运用模型时，能使用简单的模型，就用简单的模型。简单而又实用的才是最好的！</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"2-Sampling-Bias\"><a href=\"#2-Sampling-Bias\" class=\"headerlink\" title=\"2. Sampling Bias\"></a>2. Sampling Bias</h2><p>课上举了1948年美国选举，2个候选人A和B。一家报刊提前通过电话采访得到的结果是A会赢B，但是实际的结果却反过来。这是因为这家报刊在抽样调查的过程中只对某一阶层的人进行采访，所以导致了这个错误。</p>\n<p>这个例子给我们的教训就是，如果抽样有偏差的话，那么学习的结果也产生了偏差，这种情形称之为抽样偏差Sampling Bias。从技术上来说，就是训练数据和验证数据要服从同一个分布，最好都是独立同分布的，这样训练得到的模型才能更好地具有代表性。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"3-Data-Snooping\"><a href=\"#3-Data-Snooping\" class=\"headerlink\" title=\"3. Data Snooping\"></a>3. Data Snooping</h2><p>课上举的例子是偷窥数据造成对结果的影响。很显然，我们不应该提前去偷窥数据，但是这个实际上又是不可能避免的，因为我们在开始之前就会根据以往的经验选择性的偏向于某一类模型去处理问题，或者避免再用某一些模型去学习。</p>\n<p>有2个方法可能尽可能减少数据偷窥</p>\n<ol>\n<li>“看不见”数据。当我们在选择模型的时候，尽量用我们的经验和知识来做判断选择，而不是通过数据来选择。先选模型，再看数据。</li>\n<li>保持怀疑。不要对别人的说法信以为真，要通过自己的研究与测试来进行模型选择，这样得到比较正确的结论。</li>\n</ol>\n<h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>首先介绍了Occam’s Razor - 越简单而有效的模型越好！</li>\n<li>然后说明了Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的</li>\n<li>最后说明了Data Snooping带来的坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度</li>\n</ol>\n<h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><br><br></h2><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 1 - Occam-‘s Razor (10-08)</p>\n<h2 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"\"></a><br><br></h2>"},{"title":"15.Summary - Power of Three","date":"2017-10-22T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Summary - Power of Three\n\n> 总结整个课程，发现很多内容数量刚好都是三。\n\n## 1. Three Related Fields\n对比三个相关的领域:\n- Data Mining\n- Artificial Intelligence\n- Statistic\n\n\n机器学习是学习问题，而不是优化问题，也就是说，机器学习不仅要求数据在训练集上求得一个较小的误差，而且在测试集上也要表现的好（因为模型最终是要部署在实际的场景中，数据也是没有训练过的），即机器学习既要低误差，又要很好地泛化能力，以保证实际的误差与训练误差相差不大。\n\n### 1) Machine Learning V.S. Data Mining\n机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。\n- 两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。\n- 两者是互助的：ML需要大数据的支持才能保持能“学到东西”。\n- 数据挖掘更关注于从大量的数据中的计算问题。\n总的来时，两者密不可分。\n\n### 2) Machine Learning V.S. Artificial Intelligence\nAI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式\n\n### 3) Machine Learning V.S. Statistic\n统计是通过对已知数据的处理，从而推断出未知的事件的属性\n所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## 2. Three Theoretical Bounds\n三个理论基础是保证了机器在满足数据量足够大，且有合适的算法的情况下，可以实现机器学习。\n三个理论基础如下：\n- Hoeffding Inequity（单一假设确认时使用）\n- Multi-Bin Hoffding Inequity（有限多个假设验证时使用）\n- VC Bound（无限多个假设训练时使用）\n\n------------------------------------------\n<br>\n<br>\n\n\n## 3. Three Linear Models\n前面我们讨论的Linear Model 有:\n- Linear Classification (PLA, Pocket)\n- Linear Regression\n- Logistic Regression\n\n具体如图一所示\n\n![Three Linear Models](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d3c8fe5c2f9329f339cd5577a6da9be9c5afacdb/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-1%20Three%20Linear%20Models.png)\n<center> 图一 Three Linear Models <sup>[1]</sup></center>\n\n------------------------------------------\n<br>\n<br>\n\n## 4. Three Key Tools\n3个重要的工具如：\n- Feature Transform - 遇到太复杂的模型，可以映射到线性的空间去做处理 (Nonlinear Transform)\n- Regularization - 通过加入惩罚项，来降低模型的复杂度 (Ridge Regression)\n- Validation - 通过拿出部分数据来作为验证集，用于评估模型，方法（Leave-One-Out Cross Validation, V-Fold Cross Validation\n\n具体如图二所示\n\n![Three Key Tools](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/895d348fc9bd1a9a08b11926ca181de1fa8cfcde/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-2%20Three%20Key%20Tools.png)\n<center> 图二 Three Key Tools <sup>[1]</sup></center>\n\n------------------------------------------\n<br>\n<br>\n\n## 5. Three Learning Principles\n- Occam’s Razor - 越简单而有效的模型越好！\n- Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的\n- Data Snooping坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度\n\n\n------------------------------------------\n<br>\n<br>\n\n## 6. Three Future Directions\n未来机器学习的方向也分为三种：\n- More Transform - 转换也能使得模型更加简单\n- More Regularization - 尽可能降低模型的复杂度\n- Less Label - 更少的Feature，那么模型将更好\n\n具体如图三所示\n\n![Three Key Tools](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cf0f34b806ade1492c029bfefc6ccbaf4dfc42c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-3%20Three%20Future%20Directions.png)\n<center> 图三 Three Future Directions <sup>[1]</sup></center>\n\n\n<br>\n<br>\n------------------------------------------\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## Summary\n1. 总结整个课程\n\n至此，Machine Learning Foundation （机器学习基石）的笔记总结完毕，有部分内容后续补充\n\n<br><br>\n----------------------------------\n\n## Reference\n[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 4 - Power of Three (08-49)\n","source":"_posts/ReadNote-Machine Learning Foudantion -NTU/2017-10-22-15.Summary - Power of Three.md","raw":"---\ntitle: 15.Summary - Power of Three\ndate: 2017-10-22 12:23:19\ncategories: [ReadNote]\ntags: [ReadNote-Machine-Learning-Foundation]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Summary - Power of Three\n\n> 总结整个课程，发现很多内容数量刚好都是三。\n\n## 1. Three Related Fields\n对比三个相关的领域:\n- Data Mining\n- Artificial Intelligence\n- Statistic\n\n\n机器学习是学习问题，而不是优化问题，也就是说，机器学习不仅要求数据在训练集上求得一个较小的误差，而且在测试集上也要表现的好（因为模型最终是要部署在实际的场景中，数据也是没有训练过的），即机器学习既要低误差，又要很好地泛化能力，以保证实际的误差与训练误差相差不大。\n\n### 1) Machine Learning V.S. Data Mining\n机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。\n- 两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。\n- 两者是互助的：ML需要大数据的支持才能保持能“学到东西”。\n- 数据挖掘更关注于从大量的数据中的计算问题。\n总的来时，两者密不可分。\n\n### 2) Machine Learning V.S. Artificial Intelligence\nAI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式\n\n### 3) Machine Learning V.S. Statistic\n统计是通过对已知数据的处理，从而推断出未知的事件的属性\n所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## 2. Three Theoretical Bounds\n三个理论基础是保证了机器在满足数据量足够大，且有合适的算法的情况下，可以实现机器学习。\n三个理论基础如下：\n- Hoeffding Inequity（单一假设确认时使用）\n- Multi-Bin Hoffding Inequity（有限多个假设验证时使用）\n- VC Bound（无限多个假设训练时使用）\n\n------------------------------------------\n<br>\n<br>\n\n\n## 3. Three Linear Models\n前面我们讨论的Linear Model 有:\n- Linear Classification (PLA, Pocket)\n- Linear Regression\n- Logistic Regression\n\n具体如图一所示\n\n![Three Linear Models](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d3c8fe5c2f9329f339cd5577a6da9be9c5afacdb/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-1%20Three%20Linear%20Models.png)\n<center> 图一 Three Linear Models <sup>[1]</sup></center>\n\n------------------------------------------\n<br>\n<br>\n\n## 4. Three Key Tools\n3个重要的工具如：\n- Feature Transform - 遇到太复杂的模型，可以映射到线性的空间去做处理 (Nonlinear Transform)\n- Regularization - 通过加入惩罚项，来降低模型的复杂度 (Ridge Regression)\n- Validation - 通过拿出部分数据来作为验证集，用于评估模型，方法（Leave-One-Out Cross Validation, V-Fold Cross Validation\n\n具体如图二所示\n\n![Three Key Tools](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/895d348fc9bd1a9a08b11926ca181de1fa8cfcde/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-2%20Three%20Key%20Tools.png)\n<center> 图二 Three Key Tools <sup>[1]</sup></center>\n\n------------------------------------------\n<br>\n<br>\n\n## 5. Three Learning Principles\n- Occam’s Razor - 越简单而有效的模型越好！\n- Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的\n- Data Snooping坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度\n\n\n------------------------------------------\n<br>\n<br>\n\n## 6. Three Future Directions\n未来机器学习的方向也分为三种：\n- More Transform - 转换也能使得模型更加简单\n- More Regularization - 尽可能降低模型的复杂度\n- Less Label - 更少的Feature，那么模型将更好\n\n具体如图三所示\n\n![Three Key Tools](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cf0f34b806ade1492c029bfefc6ccbaf4dfc42c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-3%20Three%20Future%20Directions.png)\n<center> 图三 Three Future Directions <sup>[1]</sup></center>\n\n\n<br>\n<br>\n------------------------------------------\n\n\n------------------------------------------\n<br>\n<br>\n\n\n## Summary\n1. 总结整个课程\n\n至此，Machine Learning Foundation （机器学习基石）的笔记总结完毕，有部分内容后续补充\n\n<br><br>\n----------------------------------\n\n## Reference\n[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 4 - Power of Three (08-49)\n","slug":"ReadNote-Machine Learning Foudantion -NTU/2017-10-22-15.Summary - Power of Three","published":1,"updated":"2018-10-27T04:30:42.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0c2002je0owcwyu0qob","content":"<h1 id=\"Summary-Power-of-Three\"><a href=\"#Summary-Power-of-Three\" class=\"headerlink\" title=\"Summary - Power of Three\"></a>Summary - Power of Three</h1><blockquote>\n<p>总结整个课程，发现很多内容数量刚好都是三。</p>\n</blockquote>\n<h2 id=\"1-Three-Related-Fields\"><a href=\"#1-Three-Related-Fields\" class=\"headerlink\" title=\"1. Three Related Fields\"></a>1. Three Related Fields</h2><p>对比三个相关的领域:</p>\n<ul>\n<li>Data Mining</li>\n<li>Artificial Intelligence</li>\n<li>Statistic</li>\n</ul>\n<p>机器学习是学习问题，而不是优化问题，也就是说，机器学习不仅要求数据在训练集上求得一个较小的误差，而且在测试集上也要表现的好（因为模型最终是要部署在实际的场景中，数据也是没有训练过的），即机器学习既要低误差，又要很好地泛化能力，以保证实际的误差与训练误差相差不大。</p>\n<h3 id=\"1-Machine-Learning-V-S-Data-Mining\"><a href=\"#1-Machine-Learning-V-S-Data-Mining\" class=\"headerlink\" title=\"1) Machine Learning V.S. Data Mining\"></a>1) Machine Learning V.S. Data Mining</h3><p>机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。</p>\n<ul>\n<li>两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。</li>\n<li>两者是互助的：ML需要大数据的支持才能保持能“学到东西”。</li>\n<li>数据挖掘更关注于从大量的数据中的计算问题。<br>总的来时，两者密不可分。</li>\n</ul>\n<h3 id=\"2-Machine-Learning-V-S-Artificial-Intelligence\"><a href=\"#2-Machine-Learning-V-S-Artificial-Intelligence\" class=\"headerlink\" title=\"2) Machine Learning V.S. Artificial Intelligence\"></a>2) Machine Learning V.S. Artificial Intelligence</h3><p>AI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式</p>\n<h3 id=\"3-Machine-Learning-V-S-Statistic\"><a href=\"#3-Machine-Learning-V-S-Statistic\" class=\"headerlink\" title=\"3) Machine Learning V.S. Statistic\"></a>3) Machine Learning V.S. Statistic</h3><p>统计是通过对已知数据的处理，从而推断出未知的事件的属性<br>所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。</p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-Three-Theoretical-Bounds\"><a href=\"#2-Three-Theoretical-Bounds\" class=\"headerlink\" title=\"2. Three Theoretical Bounds\"></a>2. Three Theoretical Bounds</h2><p>三个理论基础是保证了机器在满足数据量足够大，且有合适的算法的情况下，可以实现机器学习。<br>三个理论基础如下：</p>\n<ul>\n<li>Hoeffding Inequity（单一假设确认时使用）</li>\n<li>Multi-Bin Hoffding Inequity（有限多个假设验证时使用）</li>\n<li>VC Bound（无限多个假设训练时使用）</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"3-Three-Linear-Models\"><a href=\"#3-Three-Linear-Models\" class=\"headerlink\" title=\"3. Three Linear Models\"></a>3. Three Linear Models</h2><p>前面我们讨论的Linear Model 有:</p>\n<ul>\n<li>Linear Classification (PLA, Pocket)</li>\n<li>Linear Regression</li>\n<li>Logistic Regression</li>\n</ul>\n<p>具体如图一所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d3c8fe5c2f9329f339cd5577a6da9be9c5afacdb/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-1%20Three%20Linear%20Models.png\" alt=\"Three Linear Models\"></p>\n<center> 图一 Three Linear Models <sup>[1]</sup></center>\n\n<hr>\n<p><br><br><br></p>\n<h2 id=\"4-Three-Key-Tools\"><a href=\"#4-Three-Key-Tools\" class=\"headerlink\" title=\"4. Three Key Tools\"></a>4. Three Key Tools</h2><p>3个重要的工具如：</p>\n<ul>\n<li>Feature Transform - 遇到太复杂的模型，可以映射到线性的空间去做处理 (Nonlinear Transform)</li>\n<li>Regularization - 通过加入惩罚项，来降低模型的复杂度 (Ridge Regression)</li>\n<li>Validation - 通过拿出部分数据来作为验证集，用于评估模型，方法（Leave-One-Out Cross Validation, V-Fold Cross Validation</li>\n</ul>\n<p>具体如图二所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/895d348fc9bd1a9a08b11926ca181de1fa8cfcde/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-2%20Three%20Key%20Tools.png\" alt=\"Three Key Tools\"></p>\n<center> 图二 Three Key Tools <sup>[1]</sup></center>\n\n<hr>\n<p><br><br><br></p>\n<h2 id=\"5-Three-Learning-Principles\"><a href=\"#5-Three-Learning-Principles\" class=\"headerlink\" title=\"5. Three Learning Principles\"></a>5. Three Learning Principles</h2><ul>\n<li>Occam’s Razor - 越简单而有效的模型越好！</li>\n<li>Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的</li>\n<li>Data Snooping坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"6-Three-Future-Directions\"><a href=\"#6-Three-Future-Directions\" class=\"headerlink\" title=\"6. Three Future Directions\"></a>6. Three Future Directions</h2><p>未来机器学习的方向也分为三种：</p>\n<ul>\n<li>More Transform - 转换也能使得模型更加简单</li>\n<li>More Regularization - 尽可能降低模型的复杂度</li>\n<li>Less Label - 更少的Feature，那么模型将更好</li>\n</ul>\n<p>具体如图三所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cf0f34b806ade1492c029bfefc6ccbaf4dfc42c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-3%20Three%20Future%20Directions.png\" alt=\"Three Key Tools\"></p>\n<center> 图三 Three Future Directions <sup>[1]</sup></center>\n\n\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2><hr>\n<p><br><br><br></p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li>总结整个课程</li>\n</ol>\n<p>至此，Machine Learning Foundation （机器学习基石）的笔记总结完毕，有部分内容后续补充</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 4 - Power of Three (08-49)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Summary-Power-of-Three\"><a href=\"#Summary-Power-of-Three\" class=\"headerlink\" title=\"Summary - Power of Three\"></a>Summary - Power of Three</h1><blockquote>\n<p>总结整个课程，发现很多内容数量刚好都是三。</p>\n</blockquote>\n<h2 id=\"1-Three-Related-Fields\"><a href=\"#1-Three-Related-Fields\" class=\"headerlink\" title=\"1. Three Related Fields\"></a>1. Three Related Fields</h2><p>对比三个相关的领域:</p>\n<ul>\n<li>Data Mining</li>\n<li>Artificial Intelligence</li>\n<li>Statistic</li>\n</ul>\n<p>机器学习是学习问题，而不是优化问题，也就是说，机器学习不仅要求数据在训练集上求得一个较小的误差，而且在测试集上也要表现的好（因为模型最终是要部署在实际的场景中，数据也是没有训练过的），即机器学习既要低误差，又要很好地泛化能力，以保证实际的误差与训练误差相差不大。</p>\n<h3 id=\"1-Machine-Learning-V-S-Data-Mining\"><a href=\"#1-Machine-Learning-V-S-Data-Mining\" class=\"headerlink\" title=\"1) Machine Learning V.S. Data Mining\"></a>1) Machine Learning V.S. Data Mining</h3><p>机器学习与数据挖掘都叫知识发现（KDD Knowledge Discovery in Dataset）。</p>\n<ul>\n<li>两者是一致的：能够找出的有用信息就是我们要求得的近似目标函数的假设。</li>\n<li>两者是互助的：ML需要大数据的支持才能保持能“学到东西”。</li>\n<li>数据挖掘更关注于从大量的数据中的计算问题。<br>总的来时，两者密不可分。</li>\n</ul>\n<h3 id=\"2-Machine-Learning-V-S-Artificial-Intelligence\"><a href=\"#2-Machine-Learning-V-S-Artificial-Intelligence\" class=\"headerlink\" title=\"2) Machine Learning V.S. Artificial Intelligence\"></a>2) Machine Learning V.S. Artificial Intelligence</h3><p>AI是通过特定的方法让机器能做出Intelligent的行为，ML属于AI的一个分支，是AI实现的一种方式</p>\n<h3 id=\"3-Machine-Learning-V-S-Statistic\"><a href=\"#3-Machine-Learning-V-S-Statistic\" class=\"headerlink\" title=\"3) Machine Learning V.S. Statistic\"></a>3) Machine Learning V.S. Statistic</h3><p>统计是通过对已知数据的处理，从而推断出未知的事件的属性<br>所以统计学是实现ML的一种方法，统计学里面有许多实用的工具可以用于证明ML。</p>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"2-Three-Theoretical-Bounds\"><a href=\"#2-Three-Theoretical-Bounds\" class=\"headerlink\" title=\"2. Three Theoretical Bounds\"></a>2. Three Theoretical Bounds</h2><p>三个理论基础是保证了机器在满足数据量足够大，且有合适的算法的情况下，可以实现机器学习。<br>三个理论基础如下：</p>\n<ul>\n<li>Hoeffding Inequity（单一假设确认时使用）</li>\n<li>Multi-Bin Hoffding Inequity（有限多个假设验证时使用）</li>\n<li>VC Bound（无限多个假设训练时使用）</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"3-Three-Linear-Models\"><a href=\"#3-Three-Linear-Models\" class=\"headerlink\" title=\"3. Three Linear Models\"></a>3. Three Linear Models</h2><p>前面我们讨论的Linear Model 有:</p>\n<ul>\n<li>Linear Classification (PLA, Pocket)</li>\n<li>Linear Regression</li>\n<li>Logistic Regression</li>\n</ul>\n<p>具体如图一所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/d3c8fe5c2f9329f339cd5577a6da9be9c5afacdb/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-1%20Three%20Linear%20Models.png\" alt=\"Three Linear Models\"></p>\n<center> 图一 Three Linear Models <sup>[1]</sup></center>\n\n<hr>\n<p><br><br><br></p>\n<h2 id=\"4-Three-Key-Tools\"><a href=\"#4-Three-Key-Tools\" class=\"headerlink\" title=\"4. Three Key Tools\"></a>4. Three Key Tools</h2><p>3个重要的工具如：</p>\n<ul>\n<li>Feature Transform - 遇到太复杂的模型，可以映射到线性的空间去做处理 (Nonlinear Transform)</li>\n<li>Regularization - 通过加入惩罚项，来降低模型的复杂度 (Ridge Regression)</li>\n<li>Validation - 通过拿出部分数据来作为验证集，用于评估模型，方法（Leave-One-Out Cross Validation, V-Fold Cross Validation</li>\n</ul>\n<p>具体如图二所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/895d348fc9bd1a9a08b11926ca181de1fa8cfcde/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-2%20Three%20Key%20Tools.png\" alt=\"Three Key Tools\"></p>\n<center> 图二 Three Key Tools <sup>[1]</sup></center>\n\n<hr>\n<p><br><br><br></p>\n<h2 id=\"5-Three-Learning-Principles\"><a href=\"#5-Three-Learning-Principles\" class=\"headerlink\" title=\"5. Three Learning Principles\"></a>5. Three Learning Principles</h2><ul>\n<li>Occam’s Razor - 越简单而有效的模型越好！</li>\n<li>Sampling Bias的坏处 - 我们在训练时要保证数据的来源，最好是相互独立的</li>\n<li>Data Snooping坏处 - 尽量先选择模型，然后在去查看数据，然后在训练的过程要保持怀疑的态度</li>\n</ul>\n<hr>\n<p><br><br><br></p>\n<h2 id=\"6-Three-Future-Directions\"><a href=\"#6-Three-Future-Directions\" class=\"headerlink\" title=\"6. Three Future Directions\"></a>6. Three Future Directions</h2><p>未来机器学习的方向也分为三种：</p>\n<ul>\n<li>More Transform - 转换也能使得模型更加简单</li>\n<li>More Regularization - 尽可能降低模型的复杂度</li>\n<li>Less Label - 更少的Feature，那么模型将更好</li>\n</ul>\n<p>具体如图三所示</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/9cf0f34b806ade1492c029bfefc6ccbaf4dfc42c/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter15-3%20Three%20Future%20Directions.png\" alt=\"Three Key Tools\"></p>\n<center> 图三 Three Future Directions <sup>[1]</sup></center>\n\n\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2><hr>\n<p><br><br><br></p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><ol>\n<li>总结整个课程</li>\n</ol>\n<p>至此，Machine Learning Foundation （机器学习基石）的笔记总结完毕，有部分内容后续补充</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><br><br></h2><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] 机器学习基石(台湾大学-林轩田)\\16\\16 - 4 - Power of Three (08-49)</p>\n"},{"title":"Gradient Descent","date":"2017-12-12T09:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# Gradient Descent\n\n> There are three gradient descent we current have: batch gradient descent, mini-batch gradient descent, stochastic gradient descent.\n\n## 1. Batch Gradient Descent\n\nA compute intensive gradient descent to converge the value. This algorithm will compute all the data in each iteration.\n\nSee more at the following link.\n\n[Batch Gradient Descent](https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/)\n\n\n## 2. Stochastic Gradient Descent\n\nContrast to Batch Gradient Descent, Stochastic Gradient Descent (SGD) algorithm will compute only one the data in each iteration. To make the performance better. We will repeat the whole process for 1 to 10 times, according to the size of the data set.\n\nSee more at the following link.\n\n[Stochastic Gradient Descent](https://zhichengmle.github.io/2017/12/11/Algorithm/Optimize%20Algorithm/2017-12-11-Stochastic%20Gradient%20Descent/)\n\n\n\n## 3. Mini-Batch Gradient Descent\n\nMini-Batch Gradient Descent is a special algorithm which computes n (1≤n≤all) data in each iteration. That is to say, if the n=1, we got Stochastic Gradient Descent. And if the n=all, we got Batch Gradient Descent.\n\nSee more at the following link.\n\n[Mini-Batch Gradient Descent](https://zhichengmle.github.io/2017/12/12/Algorithm/Optimize%20Algorithm/2017-12-12-Mini-Batch%20Gradient%20Descent/)\n","source":"_posts/Algorithm/Optimize Algorithm/2017-12-12-Gradient Descent.md","raw":"---\ntitle:  Gradient Descent\ndate: 2017-12-12 17:23:19\ncategories: [Machine-Learning-Algorithm]\ntags: [Machine-Learning-Algorithm]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# Gradient Descent\n\n> There are three gradient descent we current have: batch gradient descent, mini-batch gradient descent, stochastic gradient descent.\n\n## 1. Batch Gradient Descent\n\nA compute intensive gradient descent to converge the value. This algorithm will compute all the data in each iteration.\n\nSee more at the following link.\n\n[Batch Gradient Descent](https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/)\n\n\n## 2. Stochastic Gradient Descent\n\nContrast to Batch Gradient Descent, Stochastic Gradient Descent (SGD) algorithm will compute only one the data in each iteration. To make the performance better. We will repeat the whole process for 1 to 10 times, according to the size of the data set.\n\nSee more at the following link.\n\n[Stochastic Gradient Descent](https://zhichengmle.github.io/2017/12/11/Algorithm/Optimize%20Algorithm/2017-12-11-Stochastic%20Gradient%20Descent/)\n\n\n\n## 3. Mini-Batch Gradient Descent\n\nMini-Batch Gradient Descent is a special algorithm which computes n (1≤n≤all) data in each iteration. That is to say, if the n=1, we got Stochastic Gradient Descent. And if the n=all, we got Batch Gradient Descent.\n\nSee more at the following link.\n\n[Mini-Batch Gradient Descent](https://zhichengmle.github.io/2017/12/12/Algorithm/Optimize%20Algorithm/2017-12-12-Mini-Batch%20Gradient%20Descent/)\n","slug":"Algorithm/Optimize Algorithm/2017-12-12-Gradient Descent","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0dt003ee0owf26ssr3f","content":"<h1 id=\"Gradient-Descent\"><a href=\"#Gradient-Descent\" class=\"headerlink\" title=\"Gradient Descent\"></a>Gradient Descent</h1><blockquote>\n<p>There are three gradient descent we current have: batch gradient descent, mini-batch gradient descent, stochastic gradient descent.</p>\n</blockquote>\n<h2 id=\"1-Batch-Gradient-Descent\"><a href=\"#1-Batch-Gradient-Descent\" class=\"headerlink\" title=\"1. Batch Gradient Descent\"></a>1. Batch Gradient Descent</h2><p>A compute intensive gradient descent to converge the value. This algorithm will compute all the data in each iteration.</p>\n<p>See more at the following link.</p>\n<p><a href=\"https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/\">Batch Gradient Descent</a></p>\n<h2 id=\"2-Stochastic-Gradient-Descent\"><a href=\"#2-Stochastic-Gradient-Descent\" class=\"headerlink\" title=\"2. Stochastic Gradient Descent\"></a>2. Stochastic Gradient Descent</h2><p>Contrast to Batch Gradient Descent, Stochastic Gradient Descent (SGD) algorithm will compute only one the data in each iteration. To make the performance better. We will repeat the whole process for 1 to 10 times, according to the size of the data set.</p>\n<p>See more at the following link.</p>\n<p><a href=\"https://zhichengmle.github.io/2017/12/11/Algorithm/Optimize%20Algorithm/2017-12-11-Stochastic%20Gradient%20Descent/\">Stochastic Gradient Descent</a></p>\n<h2 id=\"3-Mini-Batch-Gradient-Descent\"><a href=\"#3-Mini-Batch-Gradient-Descent\" class=\"headerlink\" title=\"3. Mini-Batch Gradient Descent\"></a>3. Mini-Batch Gradient Descent</h2><p>Mini-Batch Gradient Descent is a special algorithm which computes n (1≤n≤all) data in each iteration. That is to say, if the n=1, we got Stochastic Gradient Descent. And if the n=all, we got Batch Gradient Descent.</p>\n<p>See more at the following link.</p>\n<p><a href=\"https://zhichengmle.github.io/2017/12/12/Algorithm/Optimize%20Algorithm/2017-12-12-Mini-Batch%20Gradient%20Descent/\">Mini-Batch Gradient Descent</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Gradient-Descent\"><a href=\"#Gradient-Descent\" class=\"headerlink\" title=\"Gradient Descent\"></a>Gradient Descent</h1><blockquote>\n<p>There are three gradient descent we current have: batch gradient descent, mini-batch gradient descent, stochastic gradient descent.</p>\n</blockquote>\n<h2 id=\"1-Batch-Gradient-Descent\"><a href=\"#1-Batch-Gradient-Descent\" class=\"headerlink\" title=\"1. Batch Gradient Descent\"></a>1. Batch Gradient Descent</h2><p>A compute intensive gradient descent to converge the value. This algorithm will compute all the data in each iteration.</p>\n<p>See more at the following link.</p>\n<p><a href=\"https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/\">Batch Gradient Descent</a></p>\n<h2 id=\"2-Stochastic-Gradient-Descent\"><a href=\"#2-Stochastic-Gradient-Descent\" class=\"headerlink\" title=\"2. Stochastic Gradient Descent\"></a>2. Stochastic Gradient Descent</h2><p>Contrast to Batch Gradient Descent, Stochastic Gradient Descent (SGD) algorithm will compute only one the data in each iteration. To make the performance better. We will repeat the whole process for 1 to 10 times, according to the size of the data set.</p>\n<p>See more at the following link.</p>\n<p><a href=\"https://zhichengmle.github.io/2017/12/11/Algorithm/Optimize%20Algorithm/2017-12-11-Stochastic%20Gradient%20Descent/\">Stochastic Gradient Descent</a></p>\n<h2 id=\"3-Mini-Batch-Gradient-Descent\"><a href=\"#3-Mini-Batch-Gradient-Descent\" class=\"headerlink\" title=\"3. Mini-Batch Gradient Descent\"></a>3. Mini-Batch Gradient Descent</h2><p>Mini-Batch Gradient Descent is a special algorithm which computes n (1≤n≤all) data in each iteration. That is to say, if the n=1, we got Stochastic Gradient Descent. And if the n=all, we got Batch Gradient Descent.</p>\n<p>See more at the following link.</p>\n<p><a href=\"https://zhichengmle.github.io/2017/12/12/Algorithm/Optimize%20Algorithm/2017-12-12-Mini-Batch%20Gradient%20Descent/\">Mini-Batch Gradient Descent</a></p>\n"},{"title":"Stochastic Gradient Descent","date":"2017-12-11T07:25:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Stochastic Gradient Descent\n\n\n## 1. What is Stochastic Gradient Descent\n\nStochastic Gradient Descent(SGD) is similiar with [Batch Gradient Desent](https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/), but it used only 1 example for each iteration. So that it makes some different as well. However, the stochastic gradient descent will not exactly converge into the minimum point. It will bounds around some ratio of the minimum point. Also the cost function will not decrease all the time. It oscillates and tends to converge/expand account for the step size which you have choose.\n\n## 2. Stochastic Gradient Descent Algorithm\n\nSince we use only one example for each iteration, so the weights would be optimize with a random gradient, as a result the direction is unsure. But after loop all examples, the trend of the algorithm will lead to converge. So the this algorithm can never converge exactly to the minimum point. Choose an appropriate step size is of significant importance.\n\nAnother tips to make this algorithm performs better is loop the whole procedure for some times, say 1 to 10 times. This should depend on the dataset, since loop a large data set for 10 times is also compute intensive.\n\nThe algorithm procedure is shown below.\n\n![Sthochastic Gradient Descent Algorithm](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/9cac96cbafaeb85fbc5298a21ec223e43ed84197/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Stochastic%20Gradient%20Descent%20Algorithm.jpg)\n\nSthochastic Gradient Descent Algorithm\n\n\n\n\n## 3. Compute Effort\n\nSince the stochastic use only 1 example each iteration, the compute effort of this algorithm is O(N).\n\n| Batch Gradient Descent          | Stochastic Gradient Descent       |\n| ------------------------------- | --------------------------------- |\n| use 1 example in each iteration | use all example in each iteration |\n| relative compute loose          | relative compute intensive        |\n\n## 4. Visualize Algorithm\n\nThe images below shown the stochastic gradient descent in 1 features and 2 features. It shows that the cost is not alway converge and it eventually converge.\n\n![Visualize Algorithm](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/f0126a7845cc2943671576f3a5622305c1749cc2/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Visualize%203.jpg)\n","source":"_posts/Algorithm/Optimize Algorithm/2017-12-11-Stochastic Gradient Descent.md","raw":"---\ntitle: Stochastic Gradient Descent\ndate: 2017-12-11 15:25:19\ncategories: [Machine-Learning-Algorithm]\ntags: [Machine-Learning-Algorithm]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Stochastic Gradient Descent\n\n\n## 1. What is Stochastic Gradient Descent\n\nStochastic Gradient Descent(SGD) is similiar with [Batch Gradient Desent](https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/), but it used only 1 example for each iteration. So that it makes some different as well. However, the stochastic gradient descent will not exactly converge into the minimum point. It will bounds around some ratio of the minimum point. Also the cost function will not decrease all the time. It oscillates and tends to converge/expand account for the step size which you have choose.\n\n## 2. Stochastic Gradient Descent Algorithm\n\nSince we use only one example for each iteration, so the weights would be optimize with a random gradient, as a result the direction is unsure. But after loop all examples, the trend of the algorithm will lead to converge. So the this algorithm can never converge exactly to the minimum point. Choose an appropriate step size is of significant importance.\n\nAnother tips to make this algorithm performs better is loop the whole procedure for some times, say 1 to 10 times. This should depend on the dataset, since loop a large data set for 10 times is also compute intensive.\n\nThe algorithm procedure is shown below.\n\n![Sthochastic Gradient Descent Algorithm](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/9cac96cbafaeb85fbc5298a21ec223e43ed84197/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Stochastic%20Gradient%20Descent%20Algorithm.jpg)\n\nSthochastic Gradient Descent Algorithm\n\n\n\n\n## 3. Compute Effort\n\nSince the stochastic use only 1 example each iteration, the compute effort of this algorithm is O(N).\n\n| Batch Gradient Descent          | Stochastic Gradient Descent       |\n| ------------------------------- | --------------------------------- |\n| use 1 example in each iteration | use all example in each iteration |\n| relative compute loose          | relative compute intensive        |\n\n## 4. Visualize Algorithm\n\nThe images below shown the stochastic gradient descent in 1 features and 2 features. It shows that the cost is not alway converge and it eventually converge.\n\n![Visualize Algorithm](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/f0126a7845cc2943671576f3a5622305c1749cc2/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Visualize%203.jpg)\n","slug":"Algorithm/Optimize Algorithm/2017-12-11-Stochastic Gradient Descent","published":1,"updated":"2018-10-27T04:30:42.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0dt003fe0ow9zh3bpco","content":"<h1 id=\"Stochastic-Gradient-Descent\"><a href=\"#Stochastic-Gradient-Descent\" class=\"headerlink\" title=\"Stochastic Gradient Descent\"></a>Stochastic Gradient Descent</h1><h2 id=\"1-What-is-Stochastic-Gradient-Descent\"><a href=\"#1-What-is-Stochastic-Gradient-Descent\" class=\"headerlink\" title=\"1. What is Stochastic Gradient Descent\"></a>1. What is Stochastic Gradient Descent</h2><p>Stochastic Gradient Descent(SGD) is similiar with <a href=\"https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/\">Batch Gradient Desent</a>, but it used only 1 example for each iteration. So that it makes some different as well. However, the stochastic gradient descent will not exactly converge into the minimum point. It will bounds around some ratio of the minimum point. Also the cost function will not decrease all the time. It oscillates and tends to converge/expand account for the step size which you have choose.</p>\n<h2 id=\"2-Stochastic-Gradient-Descent-Algorithm\"><a href=\"#2-Stochastic-Gradient-Descent-Algorithm\" class=\"headerlink\" title=\"2. Stochastic Gradient Descent Algorithm\"></a>2. Stochastic Gradient Descent Algorithm</h2><p>Since we use only one example for each iteration, so the weights would be optimize with a random gradient, as a result the direction is unsure. But after loop all examples, the trend of the algorithm will lead to converge. So the this algorithm can never converge exactly to the minimum point. Choose an appropriate step size is of significant importance.</p>\n<p>Another tips to make this algorithm performs better is loop the whole procedure for some times, say 1 to 10 times. This should depend on the dataset, since loop a large data set for 10 times is also compute intensive.</p>\n<p>The algorithm procedure is shown below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/9cac96cbafaeb85fbc5298a21ec223e43ed84197/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Stochastic%20Gradient%20Descent%20Algorithm.jpg\" alt=\"Sthochastic Gradient Descent Algorithm\"></p>\n<p>Sthochastic Gradient Descent Algorithm</p>\n<h2 id=\"3-Compute-Effort\"><a href=\"#3-Compute-Effort\" class=\"headerlink\" title=\"3. Compute Effort\"></a>3. Compute Effort</h2><p>Since the stochastic use only 1 example each iteration, the compute effort of this algorithm is O(N).</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Batch Gradient Descent</th>\n<th>Stochastic Gradient Descent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use 1 example in each iteration</td>\n<td>use all example in each iteration</td>\n</tr>\n<tr>\n<td>relative compute loose</td>\n<td>relative compute intensive</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"4-Visualize-Algorithm\"><a href=\"#4-Visualize-Algorithm\" class=\"headerlink\" title=\"4. Visualize Algorithm\"></a>4. Visualize Algorithm</h2><p>The images below shown the stochastic gradient descent in 1 features and 2 features. It shows that the cost is not alway converge and it eventually converge.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/f0126a7845cc2943671576f3a5622305c1749cc2/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Visualize%203.jpg\" alt=\"Visualize Algorithm\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Stochastic-Gradient-Descent\"><a href=\"#Stochastic-Gradient-Descent\" class=\"headerlink\" title=\"Stochastic Gradient Descent\"></a>Stochastic Gradient Descent</h1><h2 id=\"1-What-is-Stochastic-Gradient-Descent\"><a href=\"#1-What-is-Stochastic-Gradient-Descent\" class=\"headerlink\" title=\"1. What is Stochastic Gradient Descent\"></a>1. What is Stochastic Gradient Descent</h2><p>Stochastic Gradient Descent(SGD) is similiar with <a href=\"https://zhichengmle.github.io/2017/11/30/Algorithm/Optimize%20Algorithm/2017-11-30-Batch%20Gradient%20Descent/\">Batch Gradient Desent</a>, but it used only 1 example for each iteration. So that it makes some different as well. However, the stochastic gradient descent will not exactly converge into the minimum point. It will bounds around some ratio of the minimum point. Also the cost function will not decrease all the time. It oscillates and tends to converge/expand account for the step size which you have choose.</p>\n<h2 id=\"2-Stochastic-Gradient-Descent-Algorithm\"><a href=\"#2-Stochastic-Gradient-Descent-Algorithm\" class=\"headerlink\" title=\"2. Stochastic Gradient Descent Algorithm\"></a>2. Stochastic Gradient Descent Algorithm</h2><p>Since we use only one example for each iteration, so the weights would be optimize with a random gradient, as a result the direction is unsure. But after loop all examples, the trend of the algorithm will lead to converge. So the this algorithm can never converge exactly to the minimum point. Choose an appropriate step size is of significant importance.</p>\n<p>Another tips to make this algorithm performs better is loop the whole procedure for some times, say 1 to 10 times. This should depend on the dataset, since loop a large data set for 10 times is also compute intensive.</p>\n<p>The algorithm procedure is shown below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/9cac96cbafaeb85fbc5298a21ec223e43ed84197/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Stochastic%20Gradient%20Descent%20Algorithm.jpg\" alt=\"Sthochastic Gradient Descent Algorithm\"></p>\n<p>Sthochastic Gradient Descent Algorithm</p>\n<h2 id=\"3-Compute-Effort\"><a href=\"#3-Compute-Effort\" class=\"headerlink\" title=\"3. Compute Effort\"></a>3. Compute Effort</h2><p>Since the stochastic use only 1 example each iteration, the compute effort of this algorithm is O(N).</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Batch Gradient Descent</th>\n<th>Stochastic Gradient Descent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use 1 example in each iteration</td>\n<td>use all example in each iteration</td>\n</tr>\n<tr>\n<td>relative compute loose</td>\n<td>relative compute intensive</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"4-Visualize-Algorithm\"><a href=\"#4-Visualize-Algorithm\" class=\"headerlink\" title=\"4. Visualize Algorithm\"></a>4. Visualize Algorithm</h2><p>The images below shown the stochastic gradient descent in 1 features and 2 features. It shows that the cost is not alway converge and it eventually converge.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/f0126a7845cc2943671576f3a5622305c1749cc2/__Blog/__Personal%20Understanding/_archive/_images/Stochastic%20Gradient%20Descent-Visualize%203.jpg\" alt=\"Visualize Algorithm\"></p>\n"},{"title":"Batch Gradient Descent","date":"2017-11-30T09:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Batch Gradient Descent\n\n> We use linear regression as example to explain this optimization algorithm.\n\n## 1. Formula\n\n### 1.1. Cost Function\n\n> We prefer residual sum of squared to evaluate linear regression.\n\n$$\n\\begin{align}\nJ(\\theta) &= \\frac{1}{2m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] ^ 2\n\\end{align}\n$$\n\n### 1.2. Visualize Cost Function\n\n\n> E.g. 1 :\n\none parameter only $\\theta_1$ --> $h_{\\theta}(x) = \\theta_1 x_1$\n\n![Learning Curve 1](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%201.png)\n<center> 1. Learning Curve 1 <sup>[1]</sup> </center>\n<br>\n\n> E.g. 2 :\n\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\n![Learning Curve 2](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%202.png)\n<center> 2. Learning Curve 2 <sup>[2]</sup> </center>\n<br>\n\nSwitch to contour plot\n\n![Learning Curve 2 - contour](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c3b875d12b29e0a7e4936f49a5529857be0f9474/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%203.png)\n<center> 3. Learning Curve 2 - contour<sup>[2]</sup> </center>\n<br>\n\n\n### 1.3. Gradient Descent Formula\n\nFor all $\\theta_i$\n$$\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}\n$$\n\n> E.g.,\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\nFor i = 0 :\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)\n$$\n\n\nFor i = 1:\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)\n$$\n\n```\n% Octave\n%% =================== Gradient Descent ===================\n% Add a column(x0) of ones to X\n\nX = [ones(len, 1), data(:,1)];\ntheta = zeros(2, 1);\nalpha = 0.01;\nITERATION = 1500;\njTheta = zeros(ITERATION, 1);\n\nfor iter = 1:ITERATION\n    % Perform a single gradient descent on the parameter vector\n    % Note: since the theta will be updated, a tempTheta is needed to store the data.\n    tempTheta = theta;\n    theta(1) = theta(1) - (alpha / len) * (sum(X * tempTheta - Y));  % ignore the X(:,1) since the values are all ones.\n    theta(2) = theta(2) - (alpha / len) * (sum((X * tempTheta - Y) .* X(:,2)));\n\n    %% =================== Compute Cost ===================\n    jTheta(iter) = sum((X * theta - Y) .^ 2) / (2 * len);\nendfor\n```\n\n## 2. Algorithm\nFor all $\\theta_i$\n$$\n\\begin{align}\n\\theta_i := \\theta_i - \\alpha \\frac{\\partial}{\\partial \\theta_i} J(\\theta_1, \\theta_2, \\dots ,\\theta_n)\n\\end{align}\n$$\n\n> E.g.,\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\nFor i = 0 :\n$$\n\\begin{align}\n\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\n\\end{align}\n$$\n\nFor i = 1 :\n$$\n\\begin{align}\n\\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]  \\cdot (x_1)\n\\end{align}\n$$\n\n\nIterative for multiple times (depends on data content, data size and step size). Finally, we could see the result as below.\n\n\n![Converge](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20visulize%20converge.jpg)\nVisualize Convergence\n\n## 3. Analyze\n\n\n| Pros                                         | Cons                      |\n| -------------------------------------------- | ------------------------- |\n| Controllable by manuplate stepsize, datasize | Computing effort is large |\n| Easy to program                              |                           |\n\n\n\n## 4. How to Choose Step Size?\n\nChoose an approriate step size is significant. If the step size is too small, it doesn't hurt the result, but it took even more times to converge. If the step size is too large, it may cause the algorithm diverge (not converge).\n\nThe graph below shows that the value is not converge since the step size is too big.\n\n![Large Step Size](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20large%20step%20size.jpg)\nLarge Step Size\n\n\nThe best way, as far as I know, is to decrease the step size according to the iteration times.\n\nE.g.,\n\n$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{t}$ \n\nor\n\n$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{\\sqrt t}$\n\n# Reference\n1. 机器学习基石(台湾大学-林轩田)\\lecture_slides-09_handout.pdf\n\n2. Coursera-Standard Ford CS229: Machine Learning - Andrew Ng\n","source":"_posts/Algorithm/Optimize Algorithm/2017-11-30-Batch Gradient Descent.md","raw":"---\ntitle: Batch Gradient Descent\ndate: 2017-11-30 17:23:19\ncategories: [Machine-Learning-Algorithm]\ntags: [Machine-Learning-Algorithm]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Batch Gradient Descent\n\n> We use linear regression as example to explain this optimization algorithm.\n\n## 1. Formula\n\n### 1.1. Cost Function\n\n> We prefer residual sum of squared to evaluate linear regression.\n\n$$\n\\begin{align}\nJ(\\theta) &= \\frac{1}{2m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] ^ 2\n\\end{align}\n$$\n\n### 1.2. Visualize Cost Function\n\n\n> E.g. 1 :\n\none parameter only $\\theta_1$ --> $h_{\\theta}(x) = \\theta_1 x_1$\n\n![Learning Curve 1](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%201.png)\n<center> 1. Learning Curve 1 <sup>[1]</sup> </center>\n<br>\n\n> E.g. 2 :\n\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\n![Learning Curve 2](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%202.png)\n<center> 2. Learning Curve 2 <sup>[2]</sup> </center>\n<br>\n\nSwitch to contour plot\n\n![Learning Curve 2 - contour](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c3b875d12b29e0a7e4936f49a5529857be0f9474/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%203.png)\n<center> 3. Learning Curve 2 - contour<sup>[2]</sup> </center>\n<br>\n\n\n### 1.3. Gradient Descent Formula\n\nFor all $\\theta_i$\n$$\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}\n$$\n\n> E.g.,\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\nFor i = 0 :\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)\n$$\n\n\nFor i = 1:\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)\n$$\n\n```\n% Octave\n%% =================== Gradient Descent ===================\n% Add a column(x0) of ones to X\n\nX = [ones(len, 1), data(:,1)];\ntheta = zeros(2, 1);\nalpha = 0.01;\nITERATION = 1500;\njTheta = zeros(ITERATION, 1);\n\nfor iter = 1:ITERATION\n    % Perform a single gradient descent on the parameter vector\n    % Note: since the theta will be updated, a tempTheta is needed to store the data.\n    tempTheta = theta;\n    theta(1) = theta(1) - (alpha / len) * (sum(X * tempTheta - Y));  % ignore the X(:,1) since the values are all ones.\n    theta(2) = theta(2) - (alpha / len) * (sum((X * tempTheta - Y) .* X(:,2)));\n\n    %% =================== Compute Cost ===================\n    jTheta(iter) = sum((X * theta - Y) .^ 2) / (2 * len);\nendfor\n```\n\n## 2. Algorithm\nFor all $\\theta_i$\n$$\n\\begin{align}\n\\theta_i := \\theta_i - \\alpha \\frac{\\partial}{\\partial \\theta_i} J(\\theta_1, \\theta_2, \\dots ,\\theta_n)\n\\end{align}\n$$\n\n> E.g.,\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\nFor i = 0 :\n$$\n\\begin{align}\n\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\n\\end{align}\n$$\n\nFor i = 1 :\n$$\n\\begin{align}\n\\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]  \\cdot (x_1)\n\\end{align}\n$$\n\n\nIterative for multiple times (depends on data content, data size and step size). Finally, we could see the result as below.\n\n\n![Converge](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20visulize%20converge.jpg)\nVisualize Convergence\n\n## 3. Analyze\n\n\n| Pros                                         | Cons                      |\n| -------------------------------------------- | ------------------------- |\n| Controllable by manuplate stepsize, datasize | Computing effort is large |\n| Easy to program                              |                           |\n\n\n\n## 4. How to Choose Step Size?\n\nChoose an approriate step size is significant. If the step size is too small, it doesn't hurt the result, but it took even more times to converge. If the step size is too large, it may cause the algorithm diverge (not converge).\n\nThe graph below shows that the value is not converge since the step size is too big.\n\n![Large Step Size](https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20large%20step%20size.jpg)\nLarge Step Size\n\n\nThe best way, as far as I know, is to decrease the step size according to the iteration times.\n\nE.g.,\n\n$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{t}$ \n\nor\n\n$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{\\sqrt t}$\n\n# Reference\n1. 机器学习基石(台湾大学-林轩田)\\lecture_slides-09_handout.pdf\n\n2. Coursera-Standard Ford CS229: Machine Learning - Andrew Ng\n","slug":"Algorithm/Optimize Algorithm/2017-11-30-Batch Gradient Descent","published":1,"updated":"2018-10-27T04:30:42.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0du003ie0owk3dqvqil","content":"<h1 id=\"Batch-Gradient-Descent\"><a href=\"#Batch-Gradient-Descent\" class=\"headerlink\" title=\"Batch Gradient Descent\"></a>Batch Gradient Descent</h1><blockquote>\n<p>We use linear regression as example to explain this optimization algorithm.</p>\n</blockquote>\n<h2 id=\"1-Formula\"><a href=\"#1-Formula\" class=\"headerlink\" title=\"1. Formula\"></a>1. Formula</h2><h3 id=\"1-1-Cost-Function\"><a href=\"#1-1-Cost-Function\" class=\"headerlink\" title=\"1.1. Cost Function\"></a>1.1. Cost Function</h3><blockquote>\n<p>We prefer residual sum of squared to evaluate linear regression.</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nJ(\\theta) &= \\frac{1}{2m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] ^ 2\n\\end{align}</script><h3 id=\"1-2-Visualize-Cost-Function\"><a href=\"#1-2-Visualize-Cost-Function\" class=\"headerlink\" title=\"1.2. Visualize Cost Function\"></a>1.2. Visualize Cost Function</h3><blockquote>\n<p>E.g. 1 :</p>\n</blockquote>\n<p>one parameter only $\\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_1 x_1$</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%201.png\" alt=\"Learning Curve 1\"></p>\n<p><center> 1. Learning Curve 1 <sup>[1]</sup> </center><br><br></p>\n<blockquote>\n<p>E.g. 2 :</p>\n</blockquote>\n<p>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%202.png\" alt=\"Learning Curve 2\"></p>\n<p><center> 2. Learning Curve 2 <sup>[2]</sup> </center><br><br></p>\n<p>Switch to contour plot</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c3b875d12b29e0a7e4936f49a5529857be0f9474/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%203.png\" alt=\"Learning Curve 2 - contour\"></p>\n<p><center> 3. Learning Curve 2 - contour<sup>[2]</sup> </center><br><br></p>\n<h3 id=\"1-3-Gradient-Descent-Formula\"><a href=\"#1-3-Gradient-Descent-Formula\" class=\"headerlink\" title=\"1.3. Gradient Descent Formula\"></a>1.3. Gradient Descent Formula</h3><p>For all $\\theta_i$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}</script><blockquote>\n<p>E.g.,<br>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n</blockquote>\n<p>For i = 0 :</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)</script><p>For i = 1:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)</script><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">% Octave</div><div class=\"line\">%% =================== Gradient Descent ===================</div><div class=\"line\">% Add a column(x0) of ones to X</div><div class=\"line\"></div><div class=\"line\">X = [ones(len, 1), data(:,1)];</div><div class=\"line\">theta = zeros(2, 1);</div><div class=\"line\">alpha = 0.01;</div><div class=\"line\">ITERATION = 1500;</div><div class=\"line\">jTheta = zeros(ITERATION, 1);</div><div class=\"line\"></div><div class=\"line\">for iter = 1:ITERATION</div><div class=\"line\">    % Perform a single gradient descent on the parameter vector</div><div class=\"line\">    % Note: since the theta will be updated, a tempTheta is needed to store the data.</div><div class=\"line\">    tempTheta = theta;</div><div class=\"line\">    theta(1) = theta(1) - (alpha / len) * (sum(X * tempTheta - Y));  % ignore the X(:,1) since the values are all ones.</div><div class=\"line\">    theta(2) = theta(2) - (alpha / len) * (sum((X * tempTheta - Y) .* X(:,2)));</div><div class=\"line\"></div><div class=\"line\">    %% =================== Compute Cost ===================</div><div class=\"line\">    jTheta(iter) = sum((X * theta - Y) .^ 2) / (2 * len);</div><div class=\"line\">endfor</div></pre></td></tr></table></figure>\n<h2 id=\"2-Algorithm\"><a href=\"#2-Algorithm\" class=\"headerlink\" title=\"2. Algorithm\"></a>2. Algorithm</h2><p>For all $\\theta_i$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\theta_i := \\theta_i - \\alpha \\frac{\\partial}{\\partial \\theta_i} J(\\theta_1, \\theta_2, \\dots ,\\theta_n)\n\\end{align}</script><blockquote>\n<p>E.g.,<br>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n</blockquote>\n<p>For i = 0 :</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\n\\end{align}</script><p>For i = 1 :</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]  \\cdot (x_1)\n\\end{align}</script><p>Iterative for multiple times (depends on data content, data size and step size). Finally, we could see the result as below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20visulize%20converge.jpg\" alt=\"Converge\"><br>Visualize Convergence</p>\n<h2 id=\"3-Analyze\"><a href=\"#3-Analyze\" class=\"headerlink\" title=\"3. Analyze\"></a>3. Analyze</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Controllable by manuplate stepsize, datasize</td>\n<td>Computing effort is large</td>\n</tr>\n<tr>\n<td>Easy to program</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"4-How-to-Choose-Step-Size\"><a href=\"#4-How-to-Choose-Step-Size\" class=\"headerlink\" title=\"4. How to Choose Step Size?\"></a>4. How to Choose Step Size?</h2><p>Choose an approriate step size is significant. If the step size is too small, it doesn’t hurt the result, but it took even more times to converge. If the step size is too large, it may cause the algorithm diverge (not converge).</p>\n<p>The graph below shows that the value is not converge since the step size is too big.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20large%20step%20size.jpg\" alt=\"Large Step Size\"><br>Large Step Size</p>\n<p>The best way, as far as I know, is to decrease the step size according to the iteration times.</p>\n<p>E.g.,</p>\n<p>$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{t}$ </p>\n<p>or</p>\n<p>$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{\\sqrt t}$</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ol>\n<li><p>机器学习基石(台湾大学-林轩田)\\lecture_slides-09_handout.pdf</p>\n</li>\n<li><p>Coursera-Standard Ford CS229: Machine Learning - Andrew Ng</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Batch-Gradient-Descent\"><a href=\"#Batch-Gradient-Descent\" class=\"headerlink\" title=\"Batch Gradient Descent\"></a>Batch Gradient Descent</h1><blockquote>\n<p>We use linear regression as example to explain this optimization algorithm.</p>\n</blockquote>\n<h2 id=\"1-Formula\"><a href=\"#1-Formula\" class=\"headerlink\" title=\"1. Formula\"></a>1. Formula</h2><h3 id=\"1-1-Cost-Function\"><a href=\"#1-1-Cost-Function\" class=\"headerlink\" title=\"1.1. Cost Function\"></a>1.1. Cost Function</h3><blockquote>\n<p>We prefer residual sum of squared to evaluate linear regression.</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nJ(\\theta) &= \\frac{1}{2m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] ^ 2\n\\end{align}</script><h3 id=\"1-2-Visualize-Cost-Function\"><a href=\"#1-2-Visualize-Cost-Function\" class=\"headerlink\" title=\"1.2. Visualize Cost Function\"></a>1.2. Visualize Cost Function</h3><blockquote>\n<p>E.g. 1 :</p>\n</blockquote>\n<p>one parameter only $\\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_1 x_1$</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%201.png\" alt=\"Learning Curve 1\"></p>\n<p><center> 1. Learning Curve 1 <sup>[1]</sup> </center><br><br></p>\n<blockquote>\n<p>E.g. 2 :</p>\n</blockquote>\n<p>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b970141d5bbebfd8dfe3f11a17536afea6de3b48/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%202.png\" alt=\"Learning Curve 2\"></p>\n<p><center> 2. Learning Curve 2 <sup>[2]</sup> </center><br><br></p>\n<p>Switch to contour plot</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/c3b875d12b29e0a7e4936f49a5529857be0f9474/__Blog/__Personal%20Understanding/Algorithm/Supervised%20Learning/linear%20model/images/1.Linear%20Model%203.png\" alt=\"Learning Curve 2 - contour\"></p>\n<p><center> 3. Learning Curve 2 - contour<sup>[2]</sup> </center><br><br></p>\n<h3 id=\"1-3-Gradient-Descent-Formula\"><a href=\"#1-3-Gradient-Descent-Formula\" class=\"headerlink\" title=\"1.3. Gradient Descent Formula\"></a>1.3. Gradient Descent Formula</h3><p>For all $\\theta_i$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}</script><blockquote>\n<p>E.g.,<br>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n</blockquote>\n<p>For i = 0 :</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)</script><p>For i = 1:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)</script><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">% Octave</div><div class=\"line\">%% =================== Gradient Descent ===================</div><div class=\"line\">% Add a column(x0) of ones to X</div><div class=\"line\"></div><div class=\"line\">X = [ones(len, 1), data(:,1)];</div><div class=\"line\">theta = zeros(2, 1);</div><div class=\"line\">alpha = 0.01;</div><div class=\"line\">ITERATION = 1500;</div><div class=\"line\">jTheta = zeros(ITERATION, 1);</div><div class=\"line\"></div><div class=\"line\">for iter = 1:ITERATION</div><div class=\"line\">    % Perform a single gradient descent on the parameter vector</div><div class=\"line\">    % Note: since the theta will be updated, a tempTheta is needed to store the data.</div><div class=\"line\">    tempTheta = theta;</div><div class=\"line\">    theta(1) = theta(1) - (alpha / len) * (sum(X * tempTheta - Y));  % ignore the X(:,1) since the values are all ones.</div><div class=\"line\">    theta(2) = theta(2) - (alpha / len) * (sum((X * tempTheta - Y) .* X(:,2)));</div><div class=\"line\"></div><div class=\"line\">    %% =================== Compute Cost ===================</div><div class=\"line\">    jTheta(iter) = sum((X * theta - Y) .^ 2) / (2 * len);</div><div class=\"line\">endfor</div></pre></td></tr></table></figure>\n<h2 id=\"2-Algorithm\"><a href=\"#2-Algorithm\" class=\"headerlink\" title=\"2. Algorithm\"></a>2. Algorithm</h2><p>For all $\\theta_i$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\theta_i := \\theta_i - \\alpha \\frac{\\partial}{\\partial \\theta_i} J(\\theta_1, \\theta_2, \\dots ,\\theta_n)\n\\end{align}</script><blockquote>\n<p>E.g.,<br>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n</blockquote>\n<p>For i = 0 :</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]\n\\end{align}</script><p>For i = 1 :</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\theta_1 := \\theta_1 - \\alpha \\frac{1}{m} \\sum\\limits_{i=1}^{n} \\left[ h_{\\theta}(x_i) - y_i \\right]  \\cdot (x_1)\n\\end{align}</script><p>Iterative for multiple times (depends on data content, data size and step size). Finally, we could see the result as below.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20visulize%20converge.jpg\" alt=\"Converge\"><br>Visualize Convergence</p>\n<h2 id=\"3-Analyze\"><a href=\"#3-Analyze\" class=\"headerlink\" title=\"3. Analyze\"></a>3. Analyze</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Controllable by manuplate stepsize, datasize</td>\n<td>Computing effort is large</td>\n</tr>\n<tr>\n<td>Easy to program</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"4-How-to-Choose-Step-Size\"><a href=\"#4-How-to-Choose-Step-Size\" class=\"headerlink\" title=\"4. How to Choose Step Size?\"></a>4. How to Choose Step Size?</h2><p>Choose an approriate step size is significant. If the step size is too small, it doesn’t hurt the result, but it took even more times to converge. If the step size is too large, it may cause the algorithm diverge (not converge).</p>\n<p>The graph below shows that the value is not converge since the step size is too big.</p>\n<p><img src=\"https://raw.githubusercontent.com/zhichengMLE/MarkdownPhoto/1409d8d48185b2e1dc42315ed56bd61e340b3831/__Blog/__Personal%20Understanding/_archive/_images/Batch%20Gradient%20Descent%20-%20large%20step%20size.jpg\" alt=\"Large Step Size\"><br>Large Step Size</p>\n<p>The best way, as far as I know, is to decrease the step size according to the iteration times.</p>\n<p>E.g.,</p>\n<p>$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{t}$ </p>\n<p>or</p>\n<p>$\\alpha^{(t+1)} = \\frac{\\alpha^{t}}{\\sqrt t}$</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ol>\n<li><p>机器学习基石(台湾大学-林轩田)\\lecture_slides-09_handout.pdf</p>\n</li>\n<li><p>Coursera-Standard Ford CS229: Machine Learning - Andrew Ng</p>\n</li>\n</ol>\n"},{"title":"Maximum Likelihood Estimation","date":"2017-12-12T13:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Maximum Likelihood Estimation\n\n## 1. What is Maximum Likelihood Estimation?\n\nMaximum likelihood estimation (MLE) is a methods which estimats the parameters of a statistical model given data, by exploiting the parameter that maximize the likelihood.[1]\n\nSo by giving specific observation, MLE is a way to figure out the value to make the probability maximum.\n\n### 1.1. What is Likelihood?\n\nGiven an independent and identically distributed sample, we could get the probablity, which is shown as formula (1).\n\n$$\n\\begin{align}\nf(x_1,x_2,...,x_n|\\theta)\n&= f(x_1|\\theta) \\times f(x_2|\\theta) \\times ... \\times f(x_n|\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{1}\n$$\n\nThis could also be written as formula (2).\n\n$$\nL(\\theta;x_1,x_2,...,x_n) = f(x_1,x_2,...,x_n|\\theta) = \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\tag{2}\n$$\n\n### 1.2. What is Log Likelihood?\n\nFor more convenient, we usually use log likelihood which applys natural logarithm onto likelihood. The Logarithm product rule is $\\log(a \\cdot b) = log(a) + log(b)$ [2] By doing that, the product turns to the sum problem.\n\n$$\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n}f(x_i|\\theta) \\\\\n&= \\sum\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{3}\n$$\n\n\n\n## 2. Maximum Likelihood Estimation in Regression\n\nIn regression, all the data are independence: therefore the hypothesis accounts for Gaussian Distribution $p(y|x,\\theta) ∼ N(\\epsilon, \\sigma^2)$. To make the correct probability maximum, we apply MLE into this. So the probability of correct could be written as formula (4).\n\n$$\n\\begin{align}\nL(\\theta;x_1,x_2,...,x_n)\n&= \\prod\\limits_{i=1}^{n}p(y|x,\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)}) }{2\\sigma ^2}\\right)\\\\\n\\end{align}\n\\tag{4}\n$$\n\nThen we use log likelihood to make the problem easier to compute. See formula (5).\n\n\n$$\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right)\\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right) \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\log \\left(\\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right)\\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) - \\underbrace {\\frac{1}{2\\sigma ^2}\\sum\\limits_{1}^{n}\\left( -(y^{(i)} - \\theta ^ T x^{(i)}) \\right)}_{Cost-Function}\\\\\n\\end{align}\n\\tag{5}\n$$\n\nTo make the probability maximum, we need to make the cost function minimum, which is also known as cost function in regression model.\n\n\n\n# Reference\n[1] [Wikipedia-Maximum Likelihood Estimation](https://en.wikipedia.org/wiki/Maximum_likelihood_estimation)\n\n[2] [RapidTables\n-Logarithm Rules](https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules)\n","source":"_posts/Algorithm/Optimize Algorithm/2017-12-12-Maximum Likelihood Estimation.md","raw":"---\ntitle: Maximum Likelihood Estimation\ndate: 2017-12-12 21:23:19\ncategories: [Machine-Learning-Algorithm]\ntags: [Machine-Learning-Algorithm]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Maximum Likelihood Estimation\n\n## 1. What is Maximum Likelihood Estimation?\n\nMaximum likelihood estimation (MLE) is a methods which estimats the parameters of a statistical model given data, by exploiting the parameter that maximize the likelihood.[1]\n\nSo by giving specific observation, MLE is a way to figure out the value to make the probability maximum.\n\n### 1.1. What is Likelihood?\n\nGiven an independent and identically distributed sample, we could get the probablity, which is shown as formula (1).\n\n$$\n\\begin{align}\nf(x_1,x_2,...,x_n|\\theta)\n&= f(x_1|\\theta) \\times f(x_2|\\theta) \\times ... \\times f(x_n|\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{1}\n$$\n\nThis could also be written as formula (2).\n\n$$\nL(\\theta;x_1,x_2,...,x_n) = f(x_1,x_2,...,x_n|\\theta) = \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\tag{2}\n$$\n\n### 1.2. What is Log Likelihood?\n\nFor more convenient, we usually use log likelihood which applys natural logarithm onto likelihood. The Logarithm product rule is $\\log(a \\cdot b) = log(a) + log(b)$ [2] By doing that, the product turns to the sum problem.\n\n$$\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n}f(x_i|\\theta) \\\\\n&= \\sum\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{3}\n$$\n\n\n\n## 2. Maximum Likelihood Estimation in Regression\n\nIn regression, all the data are independence: therefore the hypothesis accounts for Gaussian Distribution $p(y|x,\\theta) ∼ N(\\epsilon, \\sigma^2)$. To make the correct probability maximum, we apply MLE into this. So the probability of correct could be written as formula (4).\n\n$$\n\\begin{align}\nL(\\theta;x_1,x_2,...,x_n)\n&= \\prod\\limits_{i=1}^{n}p(y|x,\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)}) }{2\\sigma ^2}\\right)\\\\\n\\end{align}\n\\tag{4}\n$$\n\nThen we use log likelihood to make the problem easier to compute. See formula (5).\n\n\n$$\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right)\\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right) \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\log \\left(\\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right)\\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) - \\underbrace {\\frac{1}{2\\sigma ^2}\\sum\\limits_{1}^{n}\\left( -(y^{(i)} - \\theta ^ T x^{(i)}) \\right)}_{Cost-Function}\\\\\n\\end{align}\n\\tag{5}\n$$\n\nTo make the probability maximum, we need to make the cost function minimum, which is also known as cost function in regression model.\n\n\n\n# Reference\n[1] [Wikipedia-Maximum Likelihood Estimation](https://en.wikipedia.org/wiki/Maximum_likelihood_estimation)\n\n[2] [RapidTables\n-Logarithm Rules](https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules)\n","slug":"Algorithm/Optimize Algorithm/2017-12-12-Maximum Likelihood Estimation","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0dv003je0ow2m3gupmy","content":"<h1 id=\"Maximum-Likelihood-Estimation\"><a href=\"#Maximum-Likelihood-Estimation\" class=\"headerlink\" title=\"Maximum Likelihood Estimation\"></a>Maximum Likelihood Estimation</h1><h2 id=\"1-What-is-Maximum-Likelihood-Estimation\"><a href=\"#1-What-is-Maximum-Likelihood-Estimation\" class=\"headerlink\" title=\"1. What is Maximum Likelihood Estimation?\"></a>1. What is Maximum Likelihood Estimation?</h2><p>Maximum likelihood estimation (MLE) is a methods which estimats the parameters of a statistical model given data, by exploiting the parameter that maximize the likelihood.[1]</p>\n<p>So by giving specific observation, MLE is a way to figure out the value to make the probability maximum.</p>\n<h3 id=\"1-1-What-is-Likelihood\"><a href=\"#1-1-What-is-Likelihood\" class=\"headerlink\" title=\"1.1. What is Likelihood?\"></a>1.1. What is Likelihood?</h3><p>Given an independent and identically distributed sample, we could get the probablity, which is shown as formula (1).</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf(x_1,x_2,...,x_n|\\theta)\n&= f(x_1|\\theta) \\times f(x_2|\\theta) \\times ... \\times f(x_n|\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{1}</script><p>This could also be written as formula (2).</p>\n<script type=\"math/tex; mode=display\">\nL(\\theta;x_1,x_2,...,x_n) = f(x_1,x_2,...,x_n|\\theta) = \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\tag{2}</script><h3 id=\"1-2-What-is-Log-Likelihood\"><a href=\"#1-2-What-is-Log-Likelihood\" class=\"headerlink\" title=\"1.2. What is Log Likelihood?\"></a>1.2. What is Log Likelihood?</h3><p>For more convenient, we usually use log likelihood which applys natural logarithm onto likelihood. The Logarithm product rule is $\\log(a \\cdot b) = log(a) + log(b)$ [2] By doing that, the product turns to the sum problem.</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n}f(x_i|\\theta) \\\\\n&= \\sum\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{3}</script><h2 id=\"2-Maximum-Likelihood-Estimation-in-Regression\"><a href=\"#2-Maximum-Likelihood-Estimation-in-Regression\" class=\"headerlink\" title=\"2. Maximum Likelihood Estimation in Regression\"></a>2. Maximum Likelihood Estimation in Regression</h2><p>In regression, all the data are independence: therefore the hypothesis accounts for Gaussian Distribution $p(y|x,\\theta) ∼ N(\\epsilon, \\sigma^2)$. To make the correct probability maximum, we apply MLE into this. So the probability of correct could be written as formula (4).</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nL(\\theta;x_1,x_2,...,x_n)\n&= \\prod\\limits_{i=1}^{n}p(y|x,\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)}) }{2\\sigma ^2}\\right)\\\\\n\\end{align}\n\\tag{4}</script><p>Then we use log likelihood to make the problem easier to compute. See formula (5).</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right)\\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right) \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\log \\left(\\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right)\\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) - \\underbrace {\\frac{1}{2\\sigma ^2}\\sum\\limits_{1}^{n}\\left( -(y^{(i)} - \\theta ^ T x^{(i)}) \\right)}_{Cost-Function}\\\\\n\\end{align}\n\\tag{5}</script><p>To make the probability maximum, we need to make the cost function minimum, which is also known as cost function in regression model.</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] <a href=\"https://en.wikipedia.org/wiki/Maximum_likelihood_estimation\" target=\"_blank\" rel=\"external\">Wikipedia-Maximum Likelihood Estimation</a></p>\n<p>[2] <a href=\"https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules\" target=\"_blank\" rel=\"external\">RapidTables<br>-Logarithm Rules</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Maximum-Likelihood-Estimation\"><a href=\"#Maximum-Likelihood-Estimation\" class=\"headerlink\" title=\"Maximum Likelihood Estimation\"></a>Maximum Likelihood Estimation</h1><h2 id=\"1-What-is-Maximum-Likelihood-Estimation\"><a href=\"#1-What-is-Maximum-Likelihood-Estimation\" class=\"headerlink\" title=\"1. What is Maximum Likelihood Estimation?\"></a>1. What is Maximum Likelihood Estimation?</h2><p>Maximum likelihood estimation (MLE) is a methods which estimats the parameters of a statistical model given data, by exploiting the parameter that maximize the likelihood.[1]</p>\n<p>So by giving specific observation, MLE is a way to figure out the value to make the probability maximum.</p>\n<h3 id=\"1-1-What-is-Likelihood\"><a href=\"#1-1-What-is-Likelihood\" class=\"headerlink\" title=\"1.1. What is Likelihood?\"></a>1.1. What is Likelihood?</h3><p>Given an independent and identically distributed sample, we could get the probablity, which is shown as formula (1).</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf(x_1,x_2,...,x_n|\\theta)\n&= f(x_1|\\theta) \\times f(x_2|\\theta) \\times ... \\times f(x_n|\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{1}</script><p>This could also be written as formula (2).</p>\n<script type=\"math/tex; mode=display\">\nL(\\theta;x_1,x_2,...,x_n) = f(x_1,x_2,...,x_n|\\theta) = \\prod\\limits_{i=1}^{n}f(x_i|\\theta)\n\\tag{2}</script><h3 id=\"1-2-What-is-Log-Likelihood\"><a href=\"#1-2-What-is-Log-Likelihood\" class=\"headerlink\" title=\"1.2. What is Log Likelihood?\"></a>1.2. What is Log Likelihood?</h3><p>For more convenient, we usually use log likelihood which applys natural logarithm onto likelihood. The Logarithm product rule is $\\log(a \\cdot b) = log(a) + log(b)$ [2] By doing that, the product turns to the sum problem.</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n}f(x_i|\\theta) \\\\\n&= \\sum\\limits_{i=1}^{n}f(x_i|\\theta)\n\\end{align}\n\\tag{3}</script><h2 id=\"2-Maximum-Likelihood-Estimation-in-Regression\"><a href=\"#2-Maximum-Likelihood-Estimation-in-Regression\" class=\"headerlink\" title=\"2. Maximum Likelihood Estimation in Regression\"></a>2. Maximum Likelihood Estimation in Regression</h2><p>In regression, all the data are independence: therefore the hypothesis accounts for Gaussian Distribution $p(y|x,\\theta) ∼ N(\\epsilon, \\sigma^2)$. To make the correct probability maximum, we apply MLE into this. So the probability of correct could be written as formula (4).</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nL(\\theta;x_1,x_2,...,x_n)\n&= \\prod\\limits_{i=1}^{n}p(y|x,\\theta) \\\\\n&= \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)}) }{2\\sigma ^2}\\right)\\\\\n\\end{align}\n\\tag{4}</script><p>Then we use log likelihood to make the problem easier to compute. See formula (5).</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\ln L(\\theta;x_1,x_2,...,x_n)\n&= \\ln \\prod\\limits_{i=1}^{n} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right)\\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2}\\right) \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\log \\left(\\exp\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right)\\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) + \\sum\\limits_{1}^{n}\\left( \\frac{-(y^{(i)} - \\theta ^ T x^{(i)})}{2\\sigma ^2} \\right) \\\\\n&= \\sum\\limits_{1}^{n} \\log\\left( \\frac{1}{\\sqrt{2\\pi}\\sigma} \\right) - \\underbrace {\\frac{1}{2\\sigma ^2}\\sum\\limits_{1}^{n}\\left( -(y^{(i)} - \\theta ^ T x^{(i)}) \\right)}_{Cost-Function}\\\\\n\\end{align}\n\\tag{5}</script><p>To make the probability maximum, we need to make the cost function minimum, which is also known as cost function in regression model.</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] <a href=\"https://en.wikipedia.org/wiki/Maximum_likelihood_estimation\" target=\"_blank\" rel=\"external\">Wikipedia-Maximum Likelihood Estimation</a></p>\n<p>[2] <a href=\"https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules\" target=\"_blank\" rel=\"external\">RapidTables<br>-Logarithm Rules</a></p>\n"},{"title":"Mini-Batch Gradient Descent","date":"2017-12-12T05:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n\n# Mini-Batch Gradient Descent\n\n## 1. What is Mini-Batch Gradient Descent?\n\nMini-Batch Gradient Descent is an algorithm between the Batch Gradient Descent and Stochastic Gradient Descent. Concretly, this use some(not one or all) examples(M) for each iteration.\n\n\n## 2. Compute Effort\n\nThe compute time of this algorithm depends on the examples. It not stable, but the worst case is like Batch Gradient Descent: O($N^2$)\n\nThe table below shows the different among these there Gradient Descent\n\n| Batch Gradient Descent          | Mini-Batch Gradient Descent | Stochastic Gradient Descent       |\n| ------------------------------- | --------------------------- | --------------------------------- |\n| use 1 example in each iteration | use some examples           | use all example in each iteration |\n| relative compute loose          | somewhat in between         | relative compute intensive        |\n\n\n\n### 3. Gradient Descent Formula\n\nFor all $\\theta_i$\n$$\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}\n$$\n\n> E.g.,\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\nFor i = 0 :\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)\n$$\n\n\nFor i = 1:\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)\n$$\n\n\nNote that the datasets need to be shuffled before iteration.\n","source":"_posts/Algorithm/Optimize Algorithm/2017-12-12-Mini-Batch Gradient Descent.md","raw":"---\ntitle:  Mini-Batch Gradient Descent\ndate: 2017-12-12 13:23:19\ncategories: [Machine-Learning-Algorithm]\ntags: [Machine-Learning-Algorithm]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n\n# Mini-Batch Gradient Descent\n\n## 1. What is Mini-Batch Gradient Descent?\n\nMini-Batch Gradient Descent is an algorithm between the Batch Gradient Descent and Stochastic Gradient Descent. Concretly, this use some(not one or all) examples(M) for each iteration.\n\n\n## 2. Compute Effort\n\nThe compute time of this algorithm depends on the examples. It not stable, but the worst case is like Batch Gradient Descent: O($N^2$)\n\nThe table below shows the different among these there Gradient Descent\n\n| Batch Gradient Descent          | Mini-Batch Gradient Descent | Stochastic Gradient Descent       |\n| ------------------------------- | --------------------------- | --------------------------------- |\n| use 1 example in each iteration | use some examples           | use all example in each iteration |\n| relative compute loose          | somewhat in between         | relative compute intensive        |\n\n\n\n### 3. Gradient Descent Formula\n\nFor all $\\theta_i$\n$$\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}\n$$\n\n> E.g.,\ntwo parameters $\\theta_0, \\theta_1$ --> $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$\n\nFor i = 0 :\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)\n$$\n\n\nFor i = 1:\n$$\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)\n$$\n\n\nNote that the datasets need to be shuffled before iteration.\n","slug":"Algorithm/Optimize Algorithm/2017-12-12-Mini-Batch Gradient Descent","published":1,"updated":"2018-10-27T04:30:42.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0dw003ke0owlpl5fupi","content":"<h1 id=\"Mini-Batch-Gradient-Descent\"><a href=\"#Mini-Batch-Gradient-Descent\" class=\"headerlink\" title=\"Mini-Batch Gradient Descent\"></a>Mini-Batch Gradient Descent</h1><h2 id=\"1-What-is-Mini-Batch-Gradient-Descent\"><a href=\"#1-What-is-Mini-Batch-Gradient-Descent\" class=\"headerlink\" title=\"1. What is Mini-Batch Gradient Descent?\"></a>1. What is Mini-Batch Gradient Descent?</h2><p>Mini-Batch Gradient Descent is an algorithm between the Batch Gradient Descent and Stochastic Gradient Descent. Concretly, this use some(not one or all) examples(M) for each iteration.</p>\n<h2 id=\"2-Compute-Effort\"><a href=\"#2-Compute-Effort\" class=\"headerlink\" title=\"2. Compute Effort\"></a>2. Compute Effort</h2><p>The compute time of this algorithm depends on the examples. It not stable, but the worst case is like Batch Gradient Descent: O($N^2$)</p>\n<p>The table below shows the different among these there Gradient Descent</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Batch Gradient Descent</th>\n<th>Mini-Batch Gradient Descent</th>\n<th>Stochastic Gradient Descent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use 1 example in each iteration</td>\n<td>use some examples</td>\n<td>use all example in each iteration</td>\n</tr>\n<tr>\n<td>relative compute loose</td>\n<td>somewhat in between</td>\n<td>relative compute intensive</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-Gradient-Descent-Formula\"><a href=\"#3-Gradient-Descent-Formula\" class=\"headerlink\" title=\"3. Gradient Descent Formula\"></a>3. Gradient Descent Formula</h3><p>For all $\\theta_i$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}</script><blockquote>\n<p>E.g.,<br>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n</blockquote>\n<p>For i = 0 :</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)</script><p>For i = 1:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)</script><p>Note that the datasets need to be shuffled before iteration.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mini-Batch-Gradient-Descent\"><a href=\"#Mini-Batch-Gradient-Descent\" class=\"headerlink\" title=\"Mini-Batch Gradient Descent\"></a>Mini-Batch Gradient Descent</h1><h2 id=\"1-What-is-Mini-Batch-Gradient-Descent\"><a href=\"#1-What-is-Mini-Batch-Gradient-Descent\" class=\"headerlink\" title=\"1. What is Mini-Batch Gradient Descent?\"></a>1. What is Mini-Batch Gradient Descent?</h2><p>Mini-Batch Gradient Descent is an algorithm between the Batch Gradient Descent and Stochastic Gradient Descent. Concretly, this use some(not one or all) examples(M) for each iteration.</p>\n<h2 id=\"2-Compute-Effort\"><a href=\"#2-Compute-Effort\" class=\"headerlink\" title=\"2. Compute Effort\"></a>2. Compute Effort</h2><p>The compute time of this algorithm depends on the examples. It not stable, but the worst case is like Batch Gradient Descent: O($N^2$)</p>\n<p>The table below shows the different among these there Gradient Descent</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Batch Gradient Descent</th>\n<th>Mini-Batch Gradient Descent</th>\n<th>Stochastic Gradient Descent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use 1 example in each iteration</td>\n<td>use some examples</td>\n<td>use all example in each iteration</td>\n</tr>\n<tr>\n<td>relative compute loose</td>\n<td>somewhat in between</td>\n<td>relative compute intensive</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"3-Gradient-Descent-Formula\"><a href=\"#3-Gradient-Descent-Formula\" class=\"headerlink\" title=\"3. Gradient Descent Formula\"></a>3. Gradient Descent Formula</h3><p>For all $\\theta_i$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\frac{\\partial J_\\theta}{\\partial \\theta_i} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_i)\n\\end{align}</script><blockquote>\n<p>E.g.,<br>two parameters $\\theta_0, \\theta_1$ —&gt; $h_{\\theta}(x) = \\theta_0 + \\theta_1 x_1$</p>\n</blockquote>\n<p>For i = 0 :</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_0} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right] \\cdot (x_0)</script><p>For i = 1:</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_\\theta}{\\partial \\theta_1} = \\frac{1}{m} \\sum\\limits_{i=1}^{M} \\left[ h_{\\theta}(x_i) - y_i \\right]\\cdot (x_1)</script><p>Note that the datasets need to be shuffled before iteration.</p>\n"},{"title":"Differentiation Rules","date":"2017-11-02T04:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Differentiation Rules\n\n## 1. The Sum Rule\n\nIn calculus, the sum rule in differentiation is a method of finding the derivative of a function that is the sum of two other functions for which derivatives exist.[1]\n\nGiven: $h\\left( x \\right) = f\\left( x \\right) + g\\left( x \\right)$\n\nProofs: $h'\\left( x \\right) = f'\\left( x \\right) + g'\\left( x \\right)$\n\n$$\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) + g\\left(x + \\Delta x\\right) - f \\left( x \\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) + g\\left(x + \\Delta x\\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) }{\\Delta x} + \\frac{ g\\left(x + \\Delta x\\right)  - g \\left( x \\right) }{\\Delta x} \\\\\n&= f'\\left( x \\right) + g'\\left( x \\right)\n\\end{align}\n$$\n\n## 2. The Product Rule\n\nIn calculus, the product rule is a formula used to find the derivatives of products of two or more functions.[2]\n\nGiven: $h\\left( x \\right) = f\\left( x \\right) \\cdot g\\left( x \\right)$\n\nProofs: $h'\\left( x \\right) = f'\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g'\\left( x \\right)$\n\n$$\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - \\left[ f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right) + f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right)\\right] - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left[f\\left(x + \\Delta x\\right) -f\\left( x \\right)\\right] \\cdot g\\left(x + \\Delta x\\right) +  f\\left( x \\right) \\cdot \\left[g\\left(x + \\Delta x\\right) -g\\left( x \\right)\\right] }{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x + \\Delta x\\right) + \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x + \\Delta x\\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x} \\\\\n&= f'\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g'\\left( x \\right)\n\\end{align}\n$$\n\n\n## 3. The Quotient Rule\n\nIn calculus, the quotient rule is a method of finding the derivative of a function that is the ratio of two differentiable functions.[3]\n\nGiven: $h\\left( x \\right) = \\frac {f\\left( x \\right)} {g\\left( x \\right)}$\n\nProofs: $h'\\left( x \\right) = \\frac{f'\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g'\\left( x \\right)}{g\\left( x \\right)^2}$\n\n$$\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{\\frac {f\\left( x + \\Delta x \\right)} {g\\left( x + \\Delta x \\right)} - \\frac{f\\left( x \\right)}{g\\left( x \\right)}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x \\cdot g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x}  \\cdot \\frac{1}{g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\left[\\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x\\right) - \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x \\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x}\\right] \\cdot \\frac{1}{g\\left( x \\right)^2}\\\\\n&= \\frac{f'\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g'\\left( x \\right)}{g\\left( x \\right)^2}\n\\end{align}\n$$\n\n## Reference\n[1] [Wikipedia-Sum rule in differentiation](https://en.wikipedia.org/wiki/Sum_rule_in_differentiation)\n\n[2] [Wikipedia-Product rule](https://en.wikipedia.org/wiki/Product_rule)\n\n[3] [Wikipedia-Quotient_rule](https://en.wikipedia.org/wiki/Quotient_rule)\n\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/Calculus/2017-11-02-Differentiation Rules.md","raw":"---\ntitle: Differentiation Rules\ndate: 2017-11-02 12:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics, Calculus]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Differentiation Rules\n\n## 1. The Sum Rule\n\nIn calculus, the sum rule in differentiation is a method of finding the derivative of a function that is the sum of two other functions for which derivatives exist.[1]\n\nGiven: $h\\left( x \\right) = f\\left( x \\right) + g\\left( x \\right)$\n\nProofs: $h'\\left( x \\right) = f'\\left( x \\right) + g'\\left( x \\right)$\n\n$$\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) + g\\left(x + \\Delta x\\right) - f \\left( x \\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) + g\\left(x + \\Delta x\\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) }{\\Delta x} + \\frac{ g\\left(x + \\Delta x\\right)  - g \\left( x \\right) }{\\Delta x} \\\\\n&= f'\\left( x \\right) + g'\\left( x \\right)\n\\end{align}\n$$\n\n## 2. The Product Rule\n\nIn calculus, the product rule is a formula used to find the derivatives of products of two or more functions.[2]\n\nGiven: $h\\left( x \\right) = f\\left( x \\right) \\cdot g\\left( x \\right)$\n\nProofs: $h'\\left( x \\right) = f'\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g'\\left( x \\right)$\n\n$$\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - \\left[ f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right) + f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right)\\right] - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left[f\\left(x + \\Delta x\\right) -f\\left( x \\right)\\right] \\cdot g\\left(x + \\Delta x\\right) +  f\\left( x \\right) \\cdot \\left[g\\left(x + \\Delta x\\right) -g\\left( x \\right)\\right] }{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x + \\Delta x\\right) + \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x + \\Delta x\\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x} \\\\\n&= f'\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g'\\left( x \\right)\n\\end{align}\n$$\n\n\n## 3. The Quotient Rule\n\nIn calculus, the quotient rule is a method of finding the derivative of a function that is the ratio of two differentiable functions.[3]\n\nGiven: $h\\left( x \\right) = \\frac {f\\left( x \\right)} {g\\left( x \\right)}$\n\nProofs: $h'\\left( x \\right) = \\frac{f'\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g'\\left( x \\right)}{g\\left( x \\right)^2}$\n\n$$\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{\\frac {f\\left( x + \\Delta x \\right)} {g\\left( x + \\Delta x \\right)} - \\frac{f\\left( x \\right)}{g\\left( x \\right)}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x \\cdot g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x}  \\cdot \\frac{1}{g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\left[\\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x\\right) - \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x \\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x}\\right] \\cdot \\frac{1}{g\\left( x \\right)^2}\\\\\n&= \\frac{f'\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g'\\left( x \\right)}{g\\left( x \\right)^2}\n\\end{align}\n$$\n\n## Reference\n[1] [Wikipedia-Sum rule in differentiation](https://en.wikipedia.org/wiki/Sum_rule_in_differentiation)\n\n[2] [Wikipedia-Product rule](https://en.wikipedia.org/wiki/Product_rule)\n\n[3] [Wikipedia-Quotient_rule](https://en.wikipedia.org/wiki/Quotient_rule)\n\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/Calculus/2017-11-02-Differentiation Rules","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0dx003oe0owzm7ki0lw","content":"<h1 id=\"Differentiation-Rules\"><a href=\"#Differentiation-Rules\" class=\"headerlink\" title=\"Differentiation Rules\"></a>Differentiation Rules</h1><h2 id=\"1-The-Sum-Rule\"><a href=\"#1-The-Sum-Rule\" class=\"headerlink\" title=\"1. The Sum Rule\"></a>1. The Sum Rule</h2><p>In calculus, the sum rule in differentiation is a method of finding the derivative of a function that is the sum of two other functions for which derivatives exist.[1]</p>\n<p>Given: $h\\left( x \\right) = f\\left( x \\right) + g\\left( x \\right)$</p>\n<p>Proofs: $h’\\left( x \\right) = f’\\left( x \\right) + g’\\left( x \\right)$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) + g\\left(x + \\Delta x\\right) - f \\left( x \\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) + g\\left(x + \\Delta x\\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) }{\\Delta x} + \\frac{ g\\left(x + \\Delta x\\right)  - g \\left( x \\right) }{\\Delta x} \\\\\n&= f'\\left( x \\right) + g'\\left( x \\right)\n\\end{align}</script><h2 id=\"2-The-Product-Rule\"><a href=\"#2-The-Product-Rule\" class=\"headerlink\" title=\"2. The Product Rule\"></a>2. The Product Rule</h2><p>In calculus, the product rule is a formula used to find the derivatives of products of two or more functions.[2]</p>\n<p>Given: $h\\left( x \\right) = f\\left( x \\right) \\cdot g\\left( x \\right)$</p>\n<p>Proofs: $h’\\left( x \\right) = f’\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g’\\left( x \\right)$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - \\left[ f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right) + f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right)\\right] - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left[f\\left(x + \\Delta x\\right) -f\\left( x \\right)\\right] \\cdot g\\left(x + \\Delta x\\right) +  f\\left( x \\right) \\cdot \\left[g\\left(x + \\Delta x\\right) -g\\left( x \\right)\\right] }{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x + \\Delta x\\right) + \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x + \\Delta x\\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x} \\\\\n&= f'\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g'\\left( x \\right)\n\\end{align}</script><h2 id=\"3-The-Quotient-Rule\"><a href=\"#3-The-Quotient-Rule\" class=\"headerlink\" title=\"3. The Quotient Rule\"></a>3. The Quotient Rule</h2><p>In calculus, the quotient rule is a method of finding the derivative of a function that is the ratio of two differentiable functions.[3]</p>\n<p>Given: $h\\left( x \\right) = \\frac {f\\left( x \\right)} {g\\left( x \\right)}$</p>\n<p>Proofs: $h’\\left( x \\right) = \\frac{f’\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g’\\left( x \\right)}{g\\left( x \\right)^2}$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{\\frac {f\\left( x + \\Delta x \\right)} {g\\left( x + \\Delta x \\right)} - \\frac{f\\left( x \\right)}{g\\left( x \\right)}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x \\cdot g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x}  \\cdot \\frac{1}{g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\left[\\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x\\right) - \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x \\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x}\\right] \\cdot \\frac{1}{g\\left( x \\right)^2}\\\\\n&= \\frac{f'\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g'\\left( x \\right)}{g\\left( x \\right)^2}\n\\end{align}</script><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] <a href=\"https://en.wikipedia.org/wiki/Sum_rule_in_differentiation\" target=\"_blank\" rel=\"external\">Wikipedia-Sum rule in differentiation</a></p>\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/Product_rule\" target=\"_blank\" rel=\"external\">Wikipedia-Product rule</a></p>\n<p>[3] <a href=\"https://en.wikipedia.org/wiki/Quotient_rule\" target=\"_blank\" rel=\"external\">Wikipedia-Quotient_rule</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Differentiation-Rules\"><a href=\"#Differentiation-Rules\" class=\"headerlink\" title=\"Differentiation Rules\"></a>Differentiation Rules</h1><h2 id=\"1-The-Sum-Rule\"><a href=\"#1-The-Sum-Rule\" class=\"headerlink\" title=\"1. The Sum Rule\"></a>1. The Sum Rule</h2><p>In calculus, the sum rule in differentiation is a method of finding the derivative of a function that is the sum of two other functions for which derivatives exist.[1]</p>\n<p>Given: $h\\left( x \\right) = f\\left( x \\right) + g\\left( x \\right)$</p>\n<p>Proofs: $h’\\left( x \\right) = f’\\left( x \\right) + g’\\left( x \\right)$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) + g\\left(x + \\Delta x\\right) - f \\left( x \\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) + g\\left(x + \\Delta x\\right) - g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right)  - f \\left( x \\right) }{\\Delta x} + \\frac{ g\\left(x + \\Delta x\\right)  - g \\left( x \\right) }{\\Delta x} \\\\\n&= f'\\left( x \\right) + g'\\left( x \\right)\n\\end{align}</script><h2 id=\"2-The-Product-Rule\"><a href=\"#2-The-Product-Rule\" class=\"headerlink\" title=\"2. The Product Rule\"></a>2. The Product Rule</h2><p>In calculus, the product rule is a formula used to find the derivatives of products of two or more functions.[2]</p>\n<p>Given: $h\\left( x \\right) = f\\left( x \\right) \\cdot g\\left( x \\right)$</p>\n<p>Proofs: $h’\\left( x \\right) = f’\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g’\\left( x \\right)$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) \\cdot g\\left(x + \\Delta x\\right) - \\left[ f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right) + f\\left(x \\right) \\cdot g\\left(x + \\Delta x \\right)\\right] - f \\left( x \\right) \\cdot g \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left[f\\left(x + \\Delta x\\right) -f\\left( x \\right)\\right] \\cdot g\\left(x + \\Delta x\\right) +  f\\left( x \\right) \\cdot \\left[g\\left(x + \\Delta x\\right) -g\\left( x \\right)\\right] }{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x + \\Delta x\\right) + \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x + \\Delta x\\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x} \\\\\n&= f'\\left( x \\right)g\\left( x \\right) + f\\left( x \\right)g'\\left( x \\right)\n\\end{align}</script><h2 id=\"3-The-Quotient-Rule\"><a href=\"#3-The-Quotient-Rule\" class=\"headerlink\" title=\"3. The Quotient Rule\"></a>3. The Quotient Rule</h2><p>In calculus, the quotient rule is a method of finding the derivative of a function that is the ratio of two differentiable functions.[3]</p>\n<p>Given: $h\\left( x \\right) = \\frac {f\\left( x \\right)} {g\\left( x \\right)}$</p>\n<p>Proofs: $h’\\left( x \\right) = \\frac{f’\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g’\\left( x \\right)}{g\\left( x \\right)^2}$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nh'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ h\\left(x + \\Delta x\\right) - h \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{\\frac {f\\left( x + \\Delta x \\right)} {g\\left( x + \\Delta x \\right)} - \\frac{f\\left( x \\right)}{g\\left( x \\right)}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x \\cdot g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{f\\left( x + \\Delta x \\right) g\\left( x \\right) - f\\left( x \\right)g\\left( x + \\Delta x \\right)}{\\Delta x}  \\cdot \\frac{1}{g\\left( x \\right)g\\left( x + \\Delta x \\right)}\\\\\n&= \\left[\\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) -f\\left( x \\right)}{\\Delta x} \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} g\\left(x\\right) - \\lim\\limits_{\\Delta x \\rightarrow0} f\\left(x \\right)  \\cdot \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ g\\left(x + \\Delta x\\right) -g\\left( x \\right)}{\\Delta x}\\right] \\cdot \\frac{1}{g\\left( x \\right)^2}\\\\\n&= \\frac{f'\\left( x \\right)g\\left( x \\right) -f\\left( x \\right) g'\\left( x \\right)}{g\\left( x \\right)^2}\n\\end{align}</script><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] <a href=\"https://en.wikipedia.org/wiki/Sum_rule_in_differentiation\" target=\"_blank\" rel=\"external\">Wikipedia-Sum rule in differentiation</a></p>\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/Product_rule\" target=\"_blank\" rel=\"external\">Wikipedia-Product rule</a></p>\n<p>[3] <a href=\"https://en.wikipedia.org/wiki/Quotient_rule\" target=\"_blank\" rel=\"external\">Wikipedia-Quotient_rule</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Function and Limit","date":"2017-11-02T00:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Function and Limit\n\n## 1. Function\n### 1) What is a Function?\nIn mathematics, a function is a relation between a set of inputs and a set of permissible outputs with the property that each input is related to exactly one output.[1]\n\nThink about a water dispenser, on the one side, we have a busket full of water, which inputs those water into the water dispenser fast. On the other side, the tag drains the water with much small speed. In this case, the water dispenser is somewhat a function of the speed of water. The input is fast, and the output is relatively slower.\n\nWe usually call the input as $x$, the function as $f$, and the output of $f$ corresponding to an input $x$ is denoted by $f(x)$ (read \"f of x\").[1]\n\n\n### 2) What does a Function do?\nA function map input (each number in its domain) to one and only output.\n\nFor example, $f(x) = x + 1 \\text( $x ∈ {\\rm I\\!R}$)$\n\n| x   | f(x) |\n| --- | ---- |\n| 1   | 2    |\n| 2   | 3    |\n| 3   | 4    |\n| 5   | 6    |\n| ... | ...  |\n| x   | x+1  |\n\n\n\n\n\n\n## 2. Limit\n### 1) What is a Limit?\nA limit is the function with a variable approach some value. Limits are essential to calculus (and mathematical analysis in general) and are used to define continuity, derivatives, and integrals.[2].\n\n### 2) What is one-sided limit?\n\nIn short, one-sided limit is the limition with one value approach from one side, and different will may have way different result of the formula because, the value is always bigger/small than the other value.\n\nWhen one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.\n\nSee more at this blog [What is one-sided limit](https://zhichengmle.github.io/2017/11/02/Mathematics/Calculus/2017-11-02-What%20is%20a%20one-sided%20limit/)\n\n### 3) Some Rules of Limits\n\n> There are basically 4 types of limits\n\n1. $\\frac{0}{0}(\\frac{\\infty}{\\infty})$\n2. $\\infty \\times 0$\n3. Exponential  e.g., $1^\\infty$, $0^0$, $\\infty^0$\n4. $\\infty - \\infty$\n\n\nNote that, Tylor expansion could deal with all kinds of types.\n\n#### ① $\\frac{0}{0}(\\frac{\\infty}{\\infty})$\n\nUse l'Hôpital's rule to get the derivative of nominator and demoninator. That is $\\frac{0'}{0'}(\\frac{\\infty'}{\\infty'})$\n\n\n#### ② $\\infty \\times 0$\n\nTransform to type ①, and then use the method offered in type ①. For example, $\\infty \\times 0 \\Rightarrow \\frac{\\frac{0}{1}}{\\infty}$ or $\\frac{\\frac{\\infty}{1}}{0}$\n\n#### ③ Exponential\n\nTransform exponential to logarithm, then you get type ②。Using this rule $u^v = e^(vlnu)$ .For example, $1^\\infty \\Rightarrow e^{\\infty ln1}$, $0^\\infty \\Rightarrow e^{0ln0}$, $1^\\infty \\Rightarrow e^{0 ln\\infty}$\n\n#### ④ $\\infty - \\infty$\n\nThere are several detail for this type. But using Tylor expansion is the most powerful way for this type. Because Tylor expansion is an equation, so that you don't need to worry about the other complicate prerequisite.\n\n\n\n\n\n# Summary\n\n# Reference\n[1] Wikipedia - Function (mathematics) [https://en.wikipedia.org/wiki/Function_(mathematics)](https://en.wikipedia.org/wiki/Function_(mathematics))\n\n[2] Wikipedia - Limit (mathematics) [https://en.wikipedia.org/wiki/Limit_(mathematics)](https://en.wikipedia.org/wiki/Limit_(mathematics))\n\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/Calculus/2017-11-02-Function and limit.md","raw":"---\ntitle: Function and Limit\ndate: 2017-11-02 08:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics, Calculus]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Function and Limit\n\n## 1. Function\n### 1) What is a Function?\nIn mathematics, a function is a relation between a set of inputs and a set of permissible outputs with the property that each input is related to exactly one output.[1]\n\nThink about a water dispenser, on the one side, we have a busket full of water, which inputs those water into the water dispenser fast. On the other side, the tag drains the water with much small speed. In this case, the water dispenser is somewhat a function of the speed of water. The input is fast, and the output is relatively slower.\n\nWe usually call the input as $x$, the function as $f$, and the output of $f$ corresponding to an input $x$ is denoted by $f(x)$ (read \"f of x\").[1]\n\n\n### 2) What does a Function do?\nA function map input (each number in its domain) to one and only output.\n\nFor example, $f(x) = x + 1 \\text( $x ∈ {\\rm I\\!R}$)$\n\n| x   | f(x) |\n| --- | ---- |\n| 1   | 2    |\n| 2   | 3    |\n| 3   | 4    |\n| 5   | 6    |\n| ... | ...  |\n| x   | x+1  |\n\n\n\n\n\n\n## 2. Limit\n### 1) What is a Limit?\nA limit is the function with a variable approach some value. Limits are essential to calculus (and mathematical analysis in general) and are used to define continuity, derivatives, and integrals.[2].\n\n### 2) What is one-sided limit?\n\nIn short, one-sided limit is the limition with one value approach from one side, and different will may have way different result of the formula because, the value is always bigger/small than the other value.\n\nWhen one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.\n\nSee more at this blog [What is one-sided limit](https://zhichengmle.github.io/2017/11/02/Mathematics/Calculus/2017-11-02-What%20is%20a%20one-sided%20limit/)\n\n### 3) Some Rules of Limits\n\n> There are basically 4 types of limits\n\n1. $\\frac{0}{0}(\\frac{\\infty}{\\infty})$\n2. $\\infty \\times 0$\n3. Exponential  e.g., $1^\\infty$, $0^0$, $\\infty^0$\n4. $\\infty - \\infty$\n\n\nNote that, Tylor expansion could deal with all kinds of types.\n\n#### ① $\\frac{0}{0}(\\frac{\\infty}{\\infty})$\n\nUse l'Hôpital's rule to get the derivative of nominator and demoninator. That is $\\frac{0'}{0'}(\\frac{\\infty'}{\\infty'})$\n\n\n#### ② $\\infty \\times 0$\n\nTransform to type ①, and then use the method offered in type ①. For example, $\\infty \\times 0 \\Rightarrow \\frac{\\frac{0}{1}}{\\infty}$ or $\\frac{\\frac{\\infty}{1}}{0}$\n\n#### ③ Exponential\n\nTransform exponential to logarithm, then you get type ②。Using this rule $u^v = e^(vlnu)$ .For example, $1^\\infty \\Rightarrow e^{\\infty ln1}$, $0^\\infty \\Rightarrow e^{0ln0}$, $1^\\infty \\Rightarrow e^{0 ln\\infty}$\n\n#### ④ $\\infty - \\infty$\n\nThere are several detail for this type. But using Tylor expansion is the most powerful way for this type. Because Tylor expansion is an equation, so that you don't need to worry about the other complicate prerequisite.\n\n\n\n\n\n# Summary\n\n# Reference\n[1] Wikipedia - Function (mathematics) [https://en.wikipedia.org/wiki/Function_(mathematics)](https://en.wikipedia.org/wiki/Function_(mathematics))\n\n[2] Wikipedia - Limit (mathematics) [https://en.wikipedia.org/wiki/Limit_(mathematics)](https://en.wikipedia.org/wiki/Limit_(mathematics))\n\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/Calculus/2017-11-02-Function and limit","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0dy003qe0owh7mmrxe1","content":"<h1 id=\"Function-and-Limit\"><a href=\"#Function-and-Limit\" class=\"headerlink\" title=\"Function and Limit\"></a>Function and Limit</h1><h2 id=\"1-Function\"><a href=\"#1-Function\" class=\"headerlink\" title=\"1. Function\"></a>1. Function</h2><h3 id=\"1-What-is-a-Function\"><a href=\"#1-What-is-a-Function\" class=\"headerlink\" title=\"1) What is a Function?\"></a>1) What is a Function?</h3><p>In mathematics, a function is a relation between a set of inputs and a set of permissible outputs with the property that each input is related to exactly one output.[1]</p>\n<p>Think about a water dispenser, on the one side, we have a busket full of water, which inputs those water into the water dispenser fast. On the other side, the tag drains the water with much small speed. In this case, the water dispenser is somewhat a function of the speed of water. The input is fast, and the output is relatively slower.</p>\n<p>We usually call the input as $x$, the function as $f$, and the output of $f$ corresponding to an input $x$ is denoted by $f(x)$ (read “f of x”).[1]</p>\n<h3 id=\"2-What-does-a-Function-do\"><a href=\"#2-What-does-a-Function-do\" class=\"headerlink\" title=\"2) What does a Function do?\"></a>2) What does a Function do?</h3><p>A function map input (each number in its domain) to one and only output.</p>\n<p>For example, $f(x) = x + 1 \\text( $x ∈ {\\rm I!R}$)$</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>x</th>\n<th>f(x)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>5</td>\n<td>6</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>x</td>\n<td>x+1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"2-Limit\"><a href=\"#2-Limit\" class=\"headerlink\" title=\"2. Limit\"></a>2. Limit</h2><h3 id=\"1-What-is-a-Limit\"><a href=\"#1-What-is-a-Limit\" class=\"headerlink\" title=\"1) What is a Limit?\"></a>1) What is a Limit?</h3><p>A limit is the function with a variable approach some value. Limits are essential to calculus (and mathematical analysis in general) and are used to define continuity, derivatives, and integrals.[2].</p>\n<h3 id=\"2-What-is-one-sided-limit\"><a href=\"#2-What-is-one-sided-limit\" class=\"headerlink\" title=\"2) What is one-sided limit?\"></a>2) What is one-sided limit?</h3><p>In short, one-sided limit is the limition with one value approach from one side, and different will may have way different result of the formula because, the value is always bigger/small than the other value.</p>\n<p>When one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.</p>\n<p>See more at this blog <a href=\"https://zhichengmle.github.io/2017/11/02/Mathematics/Calculus/2017-11-02-What%20is%20a%20one-sided%20limit/\">What is one-sided limit</a></p>\n<h3 id=\"3-Some-Rules-of-Limits\"><a href=\"#3-Some-Rules-of-Limits\" class=\"headerlink\" title=\"3) Some Rules of Limits\"></a>3) Some Rules of Limits</h3><blockquote>\n<p>There are basically 4 types of limits</p>\n</blockquote>\n<ol>\n<li>$\\frac{0}{0}(\\frac{\\infty}{\\infty})$</li>\n<li>$\\infty \\times 0$</li>\n<li>Exponential  e.g., $1^\\infty$, $0^0$, $\\infty^0$</li>\n<li>$\\infty - \\infty$</li>\n</ol>\n<p>Note that, Tylor expansion could deal with all kinds of types.</p>\n<h4 id=\"①-frac-0-0-frac-infty-infty\"><a href=\"#①-frac-0-0-frac-infty-infty\" class=\"headerlink\" title=\"① $\\frac{0}{0}(\\frac{\\infty}{\\infty})$\"></a>① $\\frac{0}{0}(\\frac{\\infty}{\\infty})$</h4><p>Use l’Hôpital’s rule to get the derivative of nominator and demoninator. That is $\\frac{0’}{0’}(\\frac{\\infty’}{\\infty’})$</p>\n<h4 id=\"②-infty-times-0\"><a href=\"#②-infty-times-0\" class=\"headerlink\" title=\"② $\\infty \\times 0$\"></a>② $\\infty \\times 0$</h4><p>Transform to type ①, and then use the method offered in type ①. For example, $\\infty \\times 0 \\Rightarrow \\frac{\\frac{0}{1}}{\\infty}$ or $\\frac{\\frac{\\infty}{1}}{0}$</p>\n<h4 id=\"③-Exponential\"><a href=\"#③-Exponential\" class=\"headerlink\" title=\"③ Exponential\"></a>③ Exponential</h4><p>Transform exponential to logarithm, then you get type ②。Using this rule $u^v = e^(vlnu)$ .For example, $1^\\infty \\Rightarrow e^{\\infty ln1}$, $0^\\infty \\Rightarrow e^{0ln0}$, $1^\\infty \\Rightarrow e^{0 ln\\infty}$</p>\n<h4 id=\"④-infty-infty\"><a href=\"#④-infty-infty\" class=\"headerlink\" title=\"④ $\\infty - \\infty$\"></a>④ $\\infty - \\infty$</h4><p>There are several detail for this type. But using Tylor expansion is the most powerful way for this type. Because Tylor expansion is an equation, so that you don’t need to worry about the other complicate prerequisite.</p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] Wikipedia - Function (mathematics) <a href=\"https://en.wikipedia.org/wiki/Function_(mathematics\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Function_(mathematics)</a>)</p>\n<p>[2] Wikipedia - Limit (mathematics) <a href=\"https://en.wikipedia.org/wiki/Limit_(mathematics\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Limit_(mathematics)</a>)</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Function-and-Limit\"><a href=\"#Function-and-Limit\" class=\"headerlink\" title=\"Function and Limit\"></a>Function and Limit</h1><h2 id=\"1-Function\"><a href=\"#1-Function\" class=\"headerlink\" title=\"1. Function\"></a>1. Function</h2><h3 id=\"1-What-is-a-Function\"><a href=\"#1-What-is-a-Function\" class=\"headerlink\" title=\"1) What is a Function?\"></a>1) What is a Function?</h3><p>In mathematics, a function is a relation between a set of inputs and a set of permissible outputs with the property that each input is related to exactly one output.[1]</p>\n<p>Think about a water dispenser, on the one side, we have a busket full of water, which inputs those water into the water dispenser fast. On the other side, the tag drains the water with much small speed. In this case, the water dispenser is somewhat a function of the speed of water. The input is fast, and the output is relatively slower.</p>\n<p>We usually call the input as $x$, the function as $f$, and the output of $f$ corresponding to an input $x$ is denoted by $f(x)$ (read “f of x”).[1]</p>\n<h3 id=\"2-What-does-a-Function-do\"><a href=\"#2-What-does-a-Function-do\" class=\"headerlink\" title=\"2) What does a Function do?\"></a>2) What does a Function do?</h3><p>A function map input (each number in its domain) to one and only output.</p>\n<p>For example, $f(x) = x + 1 \\text( $x ∈ {\\rm I!R}$)$</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>x</th>\n<th>f(x)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>4</td>\n</tr>\n<tr>\n<td>5</td>\n<td>6</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>x</td>\n<td>x+1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"2-Limit\"><a href=\"#2-Limit\" class=\"headerlink\" title=\"2. Limit\"></a>2. Limit</h2><h3 id=\"1-What-is-a-Limit\"><a href=\"#1-What-is-a-Limit\" class=\"headerlink\" title=\"1) What is a Limit?\"></a>1) What is a Limit?</h3><p>A limit is the function with a variable approach some value. Limits are essential to calculus (and mathematical analysis in general) and are used to define continuity, derivatives, and integrals.[2].</p>\n<h3 id=\"2-What-is-one-sided-limit\"><a href=\"#2-What-is-one-sided-limit\" class=\"headerlink\" title=\"2) What is one-sided limit?\"></a>2) What is one-sided limit?</h3><p>In short, one-sided limit is the limition with one value approach from one side, and different will may have way different result of the formula because, the value is always bigger/small than the other value.</p>\n<p>When one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.</p>\n<p>See more at this blog <a href=\"https://zhichengmle.github.io/2017/11/02/Mathematics/Calculus/2017-11-02-What%20is%20a%20one-sided%20limit/\">What is one-sided limit</a></p>\n<h3 id=\"3-Some-Rules-of-Limits\"><a href=\"#3-Some-Rules-of-Limits\" class=\"headerlink\" title=\"3) Some Rules of Limits\"></a>3) Some Rules of Limits</h3><blockquote>\n<p>There are basically 4 types of limits</p>\n</blockquote>\n<ol>\n<li>$\\frac{0}{0}(\\frac{\\infty}{\\infty})$</li>\n<li>$\\infty \\times 0$</li>\n<li>Exponential  e.g., $1^\\infty$, $0^0$, $\\infty^0$</li>\n<li>$\\infty - \\infty$</li>\n</ol>\n<p>Note that, Tylor expansion could deal with all kinds of types.</p>\n<h4 id=\"①-frac-0-0-frac-infty-infty\"><a href=\"#①-frac-0-0-frac-infty-infty\" class=\"headerlink\" title=\"① $\\frac{0}{0}(\\frac{\\infty}{\\infty})$\"></a>① $\\frac{0}{0}(\\frac{\\infty}{\\infty})$</h4><p>Use l’Hôpital’s rule to get the derivative of nominator and demoninator. That is $\\frac{0’}{0’}(\\frac{\\infty’}{\\infty’})$</p>\n<h4 id=\"②-infty-times-0\"><a href=\"#②-infty-times-0\" class=\"headerlink\" title=\"② $\\infty \\times 0$\"></a>② $\\infty \\times 0$</h4><p>Transform to type ①, and then use the method offered in type ①. For example, $\\infty \\times 0 \\Rightarrow \\frac{\\frac{0}{1}}{\\infty}$ or $\\frac{\\frac{\\infty}{1}}{0}$</p>\n<h4 id=\"③-Exponential\"><a href=\"#③-Exponential\" class=\"headerlink\" title=\"③ Exponential\"></a>③ Exponential</h4><p>Transform exponential to logarithm, then you get type ②。Using this rule $u^v = e^(vlnu)$ .For example, $1^\\infty \\Rightarrow e^{\\infty ln1}$, $0^\\infty \\Rightarrow e^{0ln0}$, $1^\\infty \\Rightarrow e^{0 ln\\infty}$</p>\n<h4 id=\"④-infty-infty\"><a href=\"#④-infty-infty\" class=\"headerlink\" title=\"④ $\\infty - \\infty$\"></a>④ $\\infty - \\infty$</h4><p>There are several detail for this type. But using Tylor expansion is the most powerful way for this type. Because Tylor expansion is an equation, so that you don’t need to worry about the other complicate prerequisite.</p>\n<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] Wikipedia - Function (mathematics) <a href=\"https://en.wikipedia.org/wiki/Function_(mathematics\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Function_(mathematics)</a>)</p>\n<p>[2] Wikipedia - Limit (mathematics) <a href=\"https://en.wikipedia.org/wiki/Limit_(mathematics\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Limit_(mathematics)</a>)</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"What is a one-sided limits?","date":"2017-11-02T02:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# What is a one-sided limits?\n\n## Introduction\n### One-sided Limits and Two-sided Limits\nPeople are familiar with two sided limits, shown below.\n\n$$\n\\lim\\limits_{x->a} f(x) = L\n\\tag{$1$}\n$$\n\nBut here, we are going to introduce one-sided limits and shown the correlative between them.\nThe expression of one-sided limits are shown below.\n$$\n\\lim\\limits_{x->a^+} f(x) = L\n\\tag{$2$}\n$$\n$$\n\\lim\\limits_{x->a^-} f(x) = L\n\\tag{$3$}\n$$\n\nThe different is the superscript of a, which means the direction of approaching. E.g., the formula (2) means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the right hand side.\n\nAnd the same as formula (3), which means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the left hand side.\n\n\n<br>\n<br>\n\n## Graph\nSee the graph down there.\n\n![one-sided limits](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b285f3c9bf4387518c42780c3f3d615de0b78a13/__Blog/__Personal%20Understanding/Mathematics/Calculus/Introduction%20of%20Calculus/images/1.%20one-sided%20limit%20graph.jpg)\n<center> 1. one-sided limits </center>\n<br>\n\nCompare graph with formula (2) and (3). You can say that $f(x)$ is getting close to 1 if $x$ approach 2 from the left-hand side. And you can also say that $f(x)$ is getting close to 3 if $x$ approach 2 from the right-hand side.\n\n\n\n<br>\n<br>\n## Correlation between One-sided Limits and Two-sided Limits\nWhen one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.\n\n\nE.g.,\n\n$$\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L \\\\\n\\lim\\limits_{x->a^-} f(x) = L\n\\end{align}\n\\right.\n\\Longrightarrow\n\\lim\\limits_{x->a} f(x) = L\n$$\n\n$$\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L_1 \\\\\n\\lim\\limits_{x->a^-} f(x) = L_2\n\\end{align}\n\\right.\n\\text{($L_1 \\neq L_2$)}\n\\nRightarrow\n\\lim\\limits_{x->a} f(x) = L\n$$\n\n# Summary\n1. One-sided limits is not equal to two-sided limits.\n2. If both sides of one-sided limits have the same value, we could make it two-sided limits.\n\n# Reference\n[1] Introduction of Calculus in Coursera by Jim Fowler\n\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/Calculus/2017-11-02-What is a one-sided limit.md","raw":"---\ntitle: What is a one-sided limits?\ndate: 2017-11-02 10:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics, Calculus]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# What is a one-sided limits?\n\n## Introduction\n### One-sided Limits and Two-sided Limits\nPeople are familiar with two sided limits, shown below.\n\n$$\n\\lim\\limits_{x->a} f(x) = L\n\\tag{$1$}\n$$\n\nBut here, we are going to introduce one-sided limits and shown the correlative between them.\nThe expression of one-sided limits are shown below.\n$$\n\\lim\\limits_{x->a^+} f(x) = L\n\\tag{$2$}\n$$\n$$\n\\lim\\limits_{x->a^-} f(x) = L\n\\tag{$3$}\n$$\n\nThe different is the superscript of a, which means the direction of approaching. E.g., the formula (2) means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the right hand side.\n\nAnd the same as formula (3), which means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the left hand side.\n\n\n<br>\n<br>\n\n## Graph\nSee the graph down there.\n\n![one-sided limits](https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b285f3c9bf4387518c42780c3f3d615de0b78a13/__Blog/__Personal%20Understanding/Mathematics/Calculus/Introduction%20of%20Calculus/images/1.%20one-sided%20limit%20graph.jpg)\n<center> 1. one-sided limits </center>\n<br>\n\nCompare graph with formula (2) and (3). You can say that $f(x)$ is getting close to 1 if $x$ approach 2 from the left-hand side. And you can also say that $f(x)$ is getting close to 3 if $x$ approach 2 from the right-hand side.\n\n\n\n<br>\n<br>\n## Correlation between One-sided Limits and Two-sided Limits\nWhen one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.\n\n\nE.g.,\n\n$$\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L \\\\\n\\lim\\limits_{x->a^-} f(x) = L\n\\end{align}\n\\right.\n\\Longrightarrow\n\\lim\\limits_{x->a} f(x) = L\n$$\n\n$$\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L_1 \\\\\n\\lim\\limits_{x->a^-} f(x) = L_2\n\\end{align}\n\\right.\n\\text{($L_1 \\neq L_2$)}\n\\nRightarrow\n\\lim\\limits_{x->a} f(x) = L\n$$\n\n# Summary\n1. One-sided limits is not equal to two-sided limits.\n2. If both sides of one-sided limits have the same value, we could make it two-sided limits.\n\n# Reference\n[1] Introduction of Calculus in Coursera by Jim Fowler\n\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/Calculus/2017-11-02-What is a one-sided limit","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0e0003ve0ow73ij0ucx","content":"<h1 id=\"What-is-a-one-sided-limits\"><a href=\"#What-is-a-one-sided-limits\" class=\"headerlink\" title=\"What is a one-sided limits?\"></a>What is a one-sided limits?</h1><h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><h3 id=\"One-sided-Limits-and-Two-sided-Limits\"><a href=\"#One-sided-Limits-and-Two-sided-Limits\" class=\"headerlink\" title=\"One-sided Limits and Two-sided Limits\"></a>One-sided Limits and Two-sided Limits</h3><p>People are familiar with two sided limits, shown below.</p>\n<script type=\"math/tex; mode=display\">\n\\lim\\limits_{x->a} f(x) = L\n\\tag{$1$}</script><p>But here, we are going to introduce one-sided limits and shown the correlative between them.<br>The expression of one-sided limits are shown below.</p>\n<script type=\"math/tex; mode=display\">\n\\lim\\limits_{x->a^+} f(x) = L\n\\tag{$2$}</script><script type=\"math/tex; mode=display\">\n\\lim\\limits_{x->a^-} f(x) = L\n\\tag{$3$}</script><p>The different is the superscript of a, which means the direction of approaching. E.g., the formula (2) means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the right hand side.</p>\n<p>And the same as formula (3), which means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the left hand side.</p>\n<p><br><br><br></p>\n<h2 id=\"Graph\"><a href=\"#Graph\" class=\"headerlink\" title=\"Graph\"></a>Graph</h2><p>See the graph down there.</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b285f3c9bf4387518c42780c3f3d615de0b78a13/__Blog/__Personal%20Understanding/Mathematics/Calculus/Introduction%20of%20Calculus/images/1.%20one-sided%20limit%20graph.jpg\" alt=\"one-sided limits\"></p>\n<p><center> 1. one-sided limits </center><br><br></p>\n<p>Compare graph with formula (2) and (3). You can say that $f(x)$ is getting close to 1 if $x$ approach 2 from the left-hand side. And you can also say that $f(x)$ is getting close to 3 if $x$ approach 2 from the right-hand side.</p>\n<p><br><br><br></p>\n<h2 id=\"Correlation-between-One-sided-Limits-and-Two-sided-Limits\"><a href=\"#Correlation-between-One-sided-Limits-and-Two-sided-Limits\" class=\"headerlink\" title=\"Correlation between One-sided Limits and Two-sided Limits\"></a>Correlation between One-sided Limits and Two-sided Limits</h2><p>When one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.</p>\n<p>E.g.,</p>\n<script type=\"math/tex; mode=display\">\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L \\\\\n\\lim\\limits_{x->a^-} f(x) = L\n\\end{align}\n\\right.\n\\Longrightarrow\n\\lim\\limits_{x->a} f(x) = L</script><script type=\"math/tex; mode=display\">\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L_1 \\\\\n\\lim\\limits_{x->a^-} f(x) = L_2\n\\end{align}\n\\right.\n\\text{($L_1 \\neq L_2$)}\n\\nRightarrow\n\\lim\\limits_{x->a} f(x) = L</script><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>One-sided limits is not equal to two-sided limits.</li>\n<li>If both sides of one-sided limits have the same value, we could make it two-sided limits.</li>\n</ol>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] Introduction of Calculus in Coursera by Jim Fowler</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"What-is-a-one-sided-limits\"><a href=\"#What-is-a-one-sided-limits\" class=\"headerlink\" title=\"What is a one-sided limits?\"></a>What is a one-sided limits?</h1><h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><h3 id=\"One-sided-Limits-and-Two-sided-Limits\"><a href=\"#One-sided-Limits-and-Two-sided-Limits\" class=\"headerlink\" title=\"One-sided Limits and Two-sided Limits\"></a>One-sided Limits and Two-sided Limits</h3><p>People are familiar with two sided limits, shown below.</p>\n<script type=\"math/tex; mode=display\">\n\\lim\\limits_{x->a} f(x) = L\n\\tag{$1$}</script><p>But here, we are going to introduce one-sided limits and shown the correlative between them.<br>The expression of one-sided limits are shown below.</p>\n<script type=\"math/tex; mode=display\">\n\\lim\\limits_{x->a^+} f(x) = L\n\\tag{$2$}</script><script type=\"math/tex; mode=display\">\n\\lim\\limits_{x->a^-} f(x) = L\n\\tag{$3$}</script><p>The different is the superscript of a, which means the direction of approaching. E.g., the formula (2) means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the right hand side.</p>\n<p>And the same as formula (3), which means that $f(x)$ is close to $L$, as the provided $x$ is approach $a$ from the left hand side.</p>\n<p><br><br><br></p>\n<h2 id=\"Graph\"><a href=\"#Graph\" class=\"headerlink\" title=\"Graph\"></a>Graph</h2><p>See the graph down there.</p>\n<p><img src=\"https://raw.githubusercontent.com/JasonDean-1/MarkdownPhoto/b285f3c9bf4387518c42780c3f3d615de0b78a13/__Blog/__Personal%20Understanding/Mathematics/Calculus/Introduction%20of%20Calculus/images/1.%20one-sided%20limit%20graph.jpg\" alt=\"one-sided limits\"></p>\n<p><center> 1. one-sided limits </center><br><br></p>\n<p>Compare graph with formula (2) and (3). You can say that $f(x)$ is getting close to 1 if $x$ approach 2 from the left-hand side. And you can also say that $f(x)$ is getting close to 3 if $x$ approach 2 from the right-hand side.</p>\n<p><br><br><br></p>\n<h2 id=\"Correlation-between-One-sided-Limits-and-Two-sided-Limits\"><a href=\"#Correlation-between-One-sided-Limits-and-Two-sided-Limits\" class=\"headerlink\" title=\"Correlation between One-sided Limits and Two-sided Limits\"></a>Correlation between One-sided Limits and Two-sided Limits</h2><p>When one-sided limits from both sides are equal to the same value, we could simply use two-sided limits to express. Whereas, the one-sided limits is not exactly the same, we have use one-sided limits.</p>\n<p>E.g.,</p>\n<script type=\"math/tex; mode=display\">\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L \\\\\n\\lim\\limits_{x->a^-} f(x) = L\n\\end{align}\n\\right.\n\\Longrightarrow\n\\lim\\limits_{x->a} f(x) = L</script><script type=\"math/tex; mode=display\">\nif\n\\left\\{\n\\begin{align}\n\\lim\\limits_{x->a^+} f(x) = L_1 \\\\\n\\lim\\limits_{x->a^-} f(x) = L_2\n\\end{align}\n\\right.\n\\text{($L_1 \\neq L_2$)}\n\\nRightarrow\n\\lim\\limits_{x->a} f(x) = L</script><h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ol>\n<li>One-sided limits is not equal to two-sided limits.</li>\n<li>If both sides of one-sided limits have the same value, we could make it two-sided limits.</li>\n</ol>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] Introduction of Calculus in Coursera by Jim Fowler</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Practical Derivatives","date":"2017-11-03T09:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Practical Derivatives\n\n\n## 1. Power Function\n\nGiven : $f \\left( x \\right) = x^a \\text(a \\in Q)$\n\nProofs : $f'\\left( x \\right) = a \\cdot x^{a-1}$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(x + \\Delta x\\right)^a - x^a}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a+C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) - x^a}{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a- x^a \\right) + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 0 + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} { C_a^1x^{a-1} + \\cdots \\Delta x^{a-1} } \\\\\n& = C_a^1x^{a-1} \\\\\n& = a x^{a-1}\n\\end{align}\n$$\n\n\n## 2. Sinus Function\nGiven : $f \\left( x \\right) = sin\\left(x\\right)$\n\nProofs : $f'\\left( x \\right) = cos\\left(x\\right)$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin \\left(x + \\Delta x\\right) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} +  \\cos x \\sin {\\Delta x}) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} - \\sin x) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x( \\cos {\\Delta x} - 1) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x \\left[\\left( 1-2 \\sin^2{\\frac{\\Delta x}{2}} \\right) -1 \\right] + \\cos x \\left( 2 \\sin{\\frac{\\Delta x}{2} \\cos{\\frac{\\Delta x}{2}}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ -2 \\sin x  \\sin^2{\\frac{\\Delta x}{2}} + 2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}} - \\sin x  \\sin^2{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\frac{\\Delta x}{2}} \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\cos\\left( x + \\frac{\\Delta x}{2} \\right) = \\cos \\left( x  + 0\\right) = \\cos x \\\\\n&\\therefore f'(\\sin x) = \\cos x\n\\end{align}\n$$\n\n\n\n\n\n## 3. Cosinus Function\nGiven : $f \\left( x \\right) = \\cos(x)$\n\nProofs : $f'\\left( x \\right) = - \\sin(x)$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos\\left(x + \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x  - \\cos x \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left( \\cos \\Delta x  - 1 \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left[\\left( 1 - 2 \\sin^2\\frac{\\Delta x}{2} \\right) -1 \\right] - \\sin x \\left( 2 \\sin \\frac{\\Delta x}{2} \\cos\\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{2 \\sin^2 \\frac{\\Delta x}{2} \\cos x - 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin x \\cos \\frac{\\Delta x}{2} \\right)}{\\Delta x}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin \\frac{\\Delta x}{2} \\cos x - \\cos \\frac{\\Delta x}{2} \\sin x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\sin \\left( \\frac{\\Delta x}{2} -x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\left[ \\sin \\left( \\frac{\\Delta x}{2} - x  \\right) \\frac{\\sin\\frac{\\Delta x}{2}}{\\frac{\\Delta x}{2}} \\right] \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\sin\\left( \\frac{\\Delta x}{2} - x \\right) = \\sin \\left( 0 - x \\right) = \\sin (-x)  = - \\sin x\\\\\n&\\therefore f'(\\cos x) = - \\sin x\n\\end{align}\n$$\n\n\n\n\n## 4. Exponential Function\nGiven : $f \\left( x \\right) = a ^ x \\text( a>0 \\&  a \\neq 1 )$\n\nProofs : $f'\\left( x \\right) = a^x \\ln a$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left( x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^{x + \\Delta x} - a^x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^x \\left( a^{\\Delta x} -1 \\right)}{\\Delta x} \\\\\nintroduce \\quad\n& t = a^{\\Delta x} - 1, then \\quad a^{\\Delta x} = t + 1, \\quad \\Delta x = \\log_a\\left( t+1 \\right)\\\\\nequation  \\quad\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x t}{\\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\frac{1}{t} \\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a(t+1)^{\\frac{1}{t} }}\\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} (t+1)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a\\left( t+1 \\right)^{\\frac{1}{t} }} = \\frac{ a^x}{\\log_ae}  = a^x \\cdot \\frac{ \\ln a }{\\ln e} = a^x \\ln a\\\\\n&\\therefore f'(a ^ x ) = - a^x \\ln a\n\\end{align}\n$$\n\n\n## 5. Logarithmic function\nGiven : $f \\left( x \\right) = \\log_a x \\text( x>0 \\&  a \\neq 1 )$\n\nProofs : $f'\\left( x \\right) = \\frac{1}{x\\ln a}$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f \\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a \\left(x + \\Delta x \\right) - \\log_a x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a(\\frac{x + \\Delta x}{x})}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x}\\frac{x }{\\Delta x} \\log_a \\left(\\frac{x + \\Delta x}{x}\\right) \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ \\frac{  \\Delta x}{x} \\right)^{\\frac{x }{\\Delta x}} \\\\\nintroduce \\quad\n& t = \\frac{  \\Delta x}{x}\\\\\nequation  \\quad\n&=\\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} \\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} \\left( t+1 \\right)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} = \\frac{1}{x} \\frac{\\ln e}{\\ln a} = \\frac{1}{ x \\ln a} \\\\\n&\\therefore f'\\left(\\log_a x\\right) = \\frac{1}{x\\ln a}\n\\end{align}\n$$\n\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/Calculus/2017-11-03-Practical Derivatives.md","raw":"---\ntitle: Practical Derivatives\ndate: 2017-11-03 17:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics, Calculus]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Practical Derivatives\n\n\n## 1. Power Function\n\nGiven : $f \\left( x \\right) = x^a \\text(a \\in Q)$\n\nProofs : $f'\\left( x \\right) = a \\cdot x^{a-1}$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(x + \\Delta x\\right)^a - x^a}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a+C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) - x^a}{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a- x^a \\right) + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 0 + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} { C_a^1x^{a-1} + \\cdots \\Delta x^{a-1} } \\\\\n& = C_a^1x^{a-1} \\\\\n& = a x^{a-1}\n\\end{align}\n$$\n\n\n## 2. Sinus Function\nGiven : $f \\left( x \\right) = sin\\left(x\\right)$\n\nProofs : $f'\\left( x \\right) = cos\\left(x\\right)$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin \\left(x + \\Delta x\\right) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} +  \\cos x \\sin {\\Delta x}) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} - \\sin x) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x( \\cos {\\Delta x} - 1) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x \\left[\\left( 1-2 \\sin^2{\\frac{\\Delta x}{2}} \\right) -1 \\right] + \\cos x \\left( 2 \\sin{\\frac{\\Delta x}{2} \\cos{\\frac{\\Delta x}{2}}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ -2 \\sin x  \\sin^2{\\frac{\\Delta x}{2}} + 2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}} - \\sin x  \\sin^2{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\frac{\\Delta x}{2}} \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\cos\\left( x + \\frac{\\Delta x}{2} \\right) = \\cos \\left( x  + 0\\right) = \\cos x \\\\\n&\\therefore f'(\\sin x) = \\cos x\n\\end{align}\n$$\n\n\n\n\n\n## 3. Cosinus Function\nGiven : $f \\left( x \\right) = \\cos(x)$\n\nProofs : $f'\\left( x \\right) = - \\sin(x)$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos\\left(x + \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x  - \\cos x \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left( \\cos \\Delta x  - 1 \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left[\\left( 1 - 2 \\sin^2\\frac{\\Delta x}{2} \\right) -1 \\right] - \\sin x \\left( 2 \\sin \\frac{\\Delta x}{2} \\cos\\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{2 \\sin^2 \\frac{\\Delta x}{2} \\cos x - 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin x \\cos \\frac{\\Delta x}{2} \\right)}{\\Delta x}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin \\frac{\\Delta x}{2} \\cos x - \\cos \\frac{\\Delta x}{2} \\sin x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\sin \\left( \\frac{\\Delta x}{2} -x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\left[ \\sin \\left( \\frac{\\Delta x}{2} - x  \\right) \\frac{\\sin\\frac{\\Delta x}{2}}{\\frac{\\Delta x}{2}} \\right] \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\sin\\left( \\frac{\\Delta x}{2} - x \\right) = \\sin \\left( 0 - x \\right) = \\sin (-x)  = - \\sin x\\\\\n&\\therefore f'(\\cos x) = - \\sin x\n\\end{align}\n$$\n\n\n\n\n## 4. Exponential Function\nGiven : $f \\left( x \\right) = a ^ x \\text( a>0 \\&  a \\neq 1 )$\n\nProofs : $f'\\left( x \\right) = a^x \\ln a$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left( x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^{x + \\Delta x} - a^x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^x \\left( a^{\\Delta x} -1 \\right)}{\\Delta x} \\\\\nintroduce \\quad\n& t = a^{\\Delta x} - 1, then \\quad a^{\\Delta x} = t + 1, \\quad \\Delta x = \\log_a\\left( t+1 \\right)\\\\\nequation  \\quad\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x t}{\\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\frac{1}{t} \\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a(t+1)^{\\frac{1}{t} }}\\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} (t+1)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a\\left( t+1 \\right)^{\\frac{1}{t} }} = \\frac{ a^x}{\\log_ae}  = a^x \\cdot \\frac{ \\ln a }{\\ln e} = a^x \\ln a\\\\\n&\\therefore f'(a ^ x ) = - a^x \\ln a\n\\end{align}\n$$\n\n\n## 5. Logarithmic function\nGiven : $f \\left( x \\right) = \\log_a x \\text( x>0 \\&  a \\neq 1 )$\n\nProofs : $f'\\left( x \\right) = \\frac{1}{x\\ln a}$\n\n> Deduction\n\n$$\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f \\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a \\left(x + \\Delta x \\right) - \\log_a x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a(\\frac{x + \\Delta x}{x})}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x}\\frac{x }{\\Delta x} \\log_a \\left(\\frac{x + \\Delta x}{x}\\right) \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ \\frac{  \\Delta x}{x} \\right)^{\\frac{x }{\\Delta x}} \\\\\nintroduce \\quad\n& t = \\frac{  \\Delta x}{x}\\\\\nequation  \\quad\n&=\\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} \\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} \\left( t+1 \\right)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} = \\frac{1}{x} \\frac{\\ln e}{\\ln a} = \\frac{1}{ x \\ln a} \\\\\n&\\therefore f'\\left(\\log_a x\\right) = \\frac{1}{x\\ln a}\n\\end{align}\n$$\n\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/Calculus/2017-11-03-Practical Derivatives","published":1,"updated":"2018-10-27T04:30:42.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0e1003ye0ow96x5tt73","content":"<h1 id=\"Practical-Derivatives\"><a href=\"#Practical-Derivatives\" class=\"headerlink\" title=\"Practical Derivatives\"></a>Practical Derivatives</h1><h2 id=\"1-Power-Function\"><a href=\"#1-Power-Function\" class=\"headerlink\" title=\"1. Power Function\"></a>1. Power Function</h2><p>Given : $f \\left( x \\right) = x^a \\text(a \\in Q)$</p>\n<p>Proofs : $f’\\left( x \\right) = a \\cdot x^{a-1}$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(x + \\Delta x\\right)^a - x^a}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a+C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) - x^a}{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a- x^a \\right) + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 0 + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} { C_a^1x^{a-1} + \\cdots \\Delta x^{a-1} } \\\\\n& = C_a^1x^{a-1} \\\\\n& = a x^{a-1}\n\\end{align}</script><h2 id=\"2-Sinus-Function\"><a href=\"#2-Sinus-Function\" class=\"headerlink\" title=\"2. Sinus Function\"></a>2. Sinus Function</h2><p>Given : $f \\left( x \\right) = sin\\left(x\\right)$</p>\n<p>Proofs : $f’\\left( x \\right) = cos\\left(x\\right)$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin \\left(x + \\Delta x\\right) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} +  \\cos x \\sin {\\Delta x}) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} - \\sin x) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x( \\cos {\\Delta x} - 1) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x \\left[\\left( 1-2 \\sin^2{\\frac{\\Delta x}{2}} \\right) -1 \\right] + \\cos x \\left( 2 \\sin{\\frac{\\Delta x}{2} \\cos{\\frac{\\Delta x}{2}}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ -2 \\sin x  \\sin^2{\\frac{\\Delta x}{2}} + 2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}} - \\sin x  \\sin^2{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\frac{\\Delta x}{2}} \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\cos\\left( x + \\frac{\\Delta x}{2} \\right) = \\cos \\left( x  + 0\\right) = \\cos x \\\\\n&\\therefore f'(\\sin x) = \\cos x\n\\end{align}</script><h2 id=\"3-Cosinus-Function\"><a href=\"#3-Cosinus-Function\" class=\"headerlink\" title=\"3. Cosinus Function\"></a>3. Cosinus Function</h2><p>Given : $f \\left( x \\right) = \\cos(x)$</p>\n<p>Proofs : $f’\\left( x \\right) = - \\sin(x)$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos\\left(x + \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x  - \\cos x \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left( \\cos \\Delta x  - 1 \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left[\\left( 1 - 2 \\sin^2\\frac{\\Delta x}{2} \\right) -1 \\right] - \\sin x \\left( 2 \\sin \\frac{\\Delta x}{2} \\cos\\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{2 \\sin^2 \\frac{\\Delta x}{2} \\cos x - 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin x \\cos \\frac{\\Delta x}{2} \\right)}{\\Delta x}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin \\frac{\\Delta x}{2} \\cos x - \\cos \\frac{\\Delta x}{2} \\sin x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\sin \\left( \\frac{\\Delta x}{2} -x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\left[ \\sin \\left( \\frac{\\Delta x}{2} - x  \\right) \\frac{\\sin\\frac{\\Delta x}{2}}{\\frac{\\Delta x}{2}} \\right] \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\sin\\left( \\frac{\\Delta x}{2} - x \\right) = \\sin \\left( 0 - x \\right) = \\sin (-x)  = - \\sin x\\\\\n&\\therefore f'(\\cos x) = - \\sin x\n\\end{align}</script><h2 id=\"4-Exponential-Function\"><a href=\"#4-Exponential-Function\" class=\"headerlink\" title=\"4. Exponential Function\"></a>4. Exponential Function</h2><p>Given : $f \\left( x \\right) = a ^ x \\text( a&gt;0 \\&amp;  a \\neq 1 )$</p>\n<p>Proofs : $f’\\left( x \\right) = a^x \\ln a$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left( x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^{x + \\Delta x} - a^x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^x \\left( a^{\\Delta x} -1 \\right)}{\\Delta x} \\\\\nintroduce \\quad\n& t = a^{\\Delta x} - 1, then \\quad a^{\\Delta x} = t + 1, \\quad \\Delta x = \\log_a\\left( t+1 \\right)\\\\\nequation  \\quad\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x t}{\\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\frac{1}{t} \\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a(t+1)^{\\frac{1}{t} }}\\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} (t+1)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a\\left( t+1 \\right)^{\\frac{1}{t} }} = \\frac{ a^x}{\\log_ae}  = a^x \\cdot \\frac{ \\ln a }{\\ln e} = a^x \\ln a\\\\\n&\\therefore f'(a ^ x ) = - a^x \\ln a\n\\end{align}</script><h2 id=\"5-Logarithmic-function\"><a href=\"#5-Logarithmic-function\" class=\"headerlink\" title=\"5. Logarithmic function\"></a>5. Logarithmic function</h2><p>Given : $f \\left( x \\right) = \\log_a x \\text( x&gt;0 \\&amp;  a \\neq 1 )$</p>\n<p>Proofs : $f’\\left( x \\right) = \\frac{1}{x\\ln a}$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f \\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a \\left(x + \\Delta x \\right) - \\log_a x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a(\\frac{x + \\Delta x}{x})}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x}\\frac{x }{\\Delta x} \\log_a \\left(\\frac{x + \\Delta x}{x}\\right) \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ \\frac{  \\Delta x}{x} \\right)^{\\frac{x }{\\Delta x}} \\\\\nintroduce \\quad\n& t = \\frac{  \\Delta x}{x}\\\\\nequation  \\quad\n&=\\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} \\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} \\left( t+1 \\right)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} = \\frac{1}{x} \\frac{\\ln e}{\\ln a} = \\frac{1}{ x \\ln a} \\\\\n&\\therefore f'\\left(\\log_a x\\right) = \\frac{1}{x\\ln a}\n\\end{align}</script><p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Practical-Derivatives\"><a href=\"#Practical-Derivatives\" class=\"headerlink\" title=\"Practical Derivatives\"></a>Practical Derivatives</h1><h2 id=\"1-Power-Function\"><a href=\"#1-Power-Function\" class=\"headerlink\" title=\"1. Power Function\"></a>1. Power Function</h2><p>Given : $f \\left( x \\right) = x^a \\text(a \\in Q)$</p>\n<p>Proofs : $f’\\left( x \\right) = a \\cdot x^{a-1}$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(x + \\Delta x\\right)^a - x^a}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a+C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) - x^a}{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left(C_a^a x^a- x^a \\right) + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 0 + \\left(C_a^1x^{a-1}\\Delta x + \\cdots \\Delta x^a\\right) }{\\Delta x} \\\\\n& = \\lim\\limits_{\\Delta x \\rightarrow0} { C_a^1x^{a-1} + \\cdots \\Delta x^{a-1} } \\\\\n& = C_a^1x^{a-1} \\\\\n& = a x^{a-1}\n\\end{align}</script><h2 id=\"2-Sinus-Function\"><a href=\"#2-Sinus-Function\" class=\"headerlink\" title=\"2. Sinus Function\"></a>2. Sinus Function</h2><p>Given : $f \\left( x \\right) = sin\\left(x\\right)$</p>\n<p>Proofs : $f’\\left( x \\right) = cos\\left(x\\right)$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x\\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin \\left(x + \\Delta x\\right) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} +  \\cos x \\sin {\\Delta x}) - \\sin x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ (\\sin x \\cos {\\Delta x} - \\sin x) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x( \\cos {\\Delta x} - 1) +  \\cos x \\sin {\\Delta x}}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin x \\left[\\left( 1-2 \\sin^2{\\frac{\\Delta x}{2}} \\right) -1 \\right] + \\cos x \\left( 2 \\sin{\\frac{\\Delta x}{2} \\cos{\\frac{\\Delta x}{2}}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ -2 \\sin x  \\sin^2{\\frac{\\Delta x}{2}} + 2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\left( \\cos x  \\cos{\\frac{\\Delta x}{2}} - \\sin x  \\sin^2{\\frac{\\Delta x}{2}}\\right)\n}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{  2 \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\sin{\\frac{\\Delta x}{2}} \\cos\\left( x + \\frac{\\Delta x}{2} \\right)}{\\frac{\\Delta x}{2}} \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\cos\\left( x + \\frac{\\Delta x}{2} \\right) = \\cos \\left( x  + 0\\right) = \\cos x \\\\\n&\\therefore f'(\\sin x) = \\cos x\n\\end{align}</script><h2 id=\"3-Cosinus-Function\"><a href=\"#3-Cosinus-Function\" class=\"headerlink\" title=\"3. Cosinus Function\"></a>3. Cosinus Function</h2><p>Given : $f \\left( x \\right) = \\cos(x)$</p>\n<p>Proofs : $f’\\left( x \\right) = - \\sin(x)$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos\\left(x + \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x - \\sin x \\sin \\Delta x\\right) - \\cos x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\left( \\cos x \\cos \\Delta x  - \\cos x \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left( \\cos \\Delta x  - 1 \\right) - \\sin x \\sin \\Delta x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\cos x \\left[\\left( 1 - 2 \\sin^2\\frac{\\Delta x}{2} \\right) -1 \\right] - \\sin x \\left( 2 \\sin \\frac{\\Delta x}{2} \\cos\\frac{\\Delta x}{2} \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{2 \\sin^2 \\frac{\\Delta x}{2} \\cos x - 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin x \\cos \\frac{\\Delta x}{2} \\right)}{\\Delta x}\\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\left( \\sin \\frac{\\Delta x}{2} \\cos x - \\cos \\frac{\\Delta x}{2} \\sin x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ 2 \\sin \\frac{\\Delta x}{2} \\sin \\left( \\frac{\\Delta x}{2} -x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\left[ \\sin \\left( \\frac{\\Delta x}{2} - x  \\right) \\frac{\\sin\\frac{\\Delta x}{2}}{\\frac{\\Delta x}{2}} \\right] \\\\\n&\\because \\lim\\limits_{\\Delta x \\rightarrow0} \\sin \\frac{\\Delta x}{2} =  \\frac{\\Delta x}{2} \\\\\n&\\therefore  \\frac{  \\sin{\\frac{\\Delta x}{2}} }{\\frac{\\Delta x}{2}} = 1 \\\\\n&\\because  \\lim\\limits_{\\Delta x \\rightarrow0} \\sin\\left( \\frac{\\Delta x}{2} - x \\right) = \\sin \\left( 0 - x \\right) = \\sin (-x)  = - \\sin x\\\\\n&\\therefore f'(\\cos x) = - \\sin x\n\\end{align}</script><h2 id=\"4-Exponential-Function\"><a href=\"#4-Exponential-Function\" class=\"headerlink\" title=\"4. Exponential Function\"></a>4. Exponential Function</h2><p>Given : $f \\left( x \\right) = a ^ x \\text( a&gt;0 \\&amp;  a \\neq 1 )$</p>\n<p>Proofs : $f’\\left( x \\right) = a^x \\ln a$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f\\left( x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^{x + \\Delta x} - a^x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ a^x \\left( a^{\\Delta x} -1 \\right)}{\\Delta x} \\\\\nintroduce \\quad\n& t = a^{\\Delta x} - 1, then \\quad a^{\\Delta x} = t + 1, \\quad \\Delta x = \\log_a\\left( t+1 \\right)\\\\\nequation  \\quad\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x t}{\\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\frac{1}{t} \\log_a(t+1)}\\\\\n&= \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a(t+1)^{\\frac{1}{t} }}\\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} (t+1)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{t \\rightarrow0} \\frac{ a^x}{\\log_a\\left( t+1 \\right)^{\\frac{1}{t} }} = \\frac{ a^x}{\\log_ae}  = a^x \\cdot \\frac{ \\ln a }{\\ln e} = a^x \\ln a\\\\\n&\\therefore f'(a ^ x ) = - a^x \\ln a\n\\end{align}</script><h2 id=\"5-Logarithmic-function\"><a href=\"#5-Logarithmic-function\" class=\"headerlink\" title=\"5. Logarithmic function\"></a>5. Logarithmic function</h2><p>Given : $f \\left( x \\right) = \\log_a x \\text( x&gt;0 \\&amp;  a \\neq 1 )$</p>\n<p>Proofs : $f’\\left( x \\right) = \\frac{1}{x\\ln a}$</p>\n<blockquote>\n<p>Deduction</p>\n</blockquote>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\nf'\\left( x \\right)\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ f \\left(x + \\Delta x \\right) - f \\left( x \\right)}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a \\left(x + \\Delta x \\right) - \\log_a x}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0} \\frac{ \\log_a(\\frac{x + \\Delta x}{x})}{\\Delta x} \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x}\\frac{x }{\\Delta x} \\log_a \\left(\\frac{x + \\Delta x}{x}\\right) \\\\\n&= \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ \\frac{  \\Delta x}{x} \\right)^{\\frac{x }{\\Delta x}} \\\\\nintroduce \\quad\n& t = \\frac{  \\Delta x}{x}\\\\\nequation  \\quad\n&=\\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} \\\\\n&\\because  \\lim\\limits_{t \\rightarrow0} \\left( t+1 \\right)^{\\frac{1}{t}} = e \\\\\n&\\therefore  \\lim\\limits_{\\Delta x \\rightarrow0}  \\frac{1}{x} \\log_a \\left( 1+ t \\right)^{\\frac{1 }{t}} = \\frac{1}{x} \\frac{\\ln e}{\\ln a} = \\frac{1}{ x \\ln a} \\\\\n&\\therefore f'\\left(\\log_a x\\right) = \\frac{1}{x\\ln a}\n\\end{align}</script><p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Tylor Expansion Example","date":"2017-11-04T07:23:19.000Z","mathjax":true,"copyright":true,"top":100,"_content":"\n# Tylor Expansion Example\n\n> Tylor Expansion is a powerful tool to deal with limits. Some examples are showed below.\n\n## Prerequisite\n\nSee more about how to calculate derivative at this link and differential rules at this link.\n\n## Definition[1]\n\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}\n$$\n\n\nWhen a = 0, the formula is showed below.\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n\n\\end{align}\n$$\n\n\n## Examples\n### 1. Example 1\n\n$f(x) = e^x$\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{e^0}{ 0 !}x^0 + \\frac{e^0}{ 1 !}x^1 + \\frac{e^0}{ 2 !}x^2  + \\cdots + \\frac{e^0}{ n !}x^n \\\\\n&= \\frac{x^0}{ 0 !} + \\frac{x^1}{ 1 !} + \\frac{x^2}{ 2 !}  + \\cdots + \\frac{x^n}{ n !} \\\\\n\\end{align}\n$$\n\n\n### 1. Example 2\n\n$f(x) = \\sin x$\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{\\sin 0}{ 0 !}x^0 + \\frac{\\cos 0}{ 1 !}x^1 + \\frac{-\\sin 0}{ 2 !}x^2  + \\cdots\\\\\n&= \\frac{0}{ 0 !} + \\frac{1}{ 1 !}x^1 + \\frac{0}{ 2 !}  + \\cdots + \\frac{x^n}{ n !}  + \\cdots\\\\\n&= \\frac{x^1}{ 1 !} - \\frac{x^3}{ 3 !} + \\frac{x^5}{ 5 !} - \\frac{x^7}{ 7 !} + \\cdots \\\\\n\\end{align}\n$$\n\n\n\n## Reference\n[1] [wikipedia-Taylor series](https://en.wikipedia.org/wiki/Taylor_series)\n\n\n<br>\n<br>\n------------------------------------------","source":"_posts/Mathematics/Calculus/2017-11-04-Typlor Expansion Example.md","raw":"---\ntitle: Tylor Expansion Example\ndate: 2017-11-04 15:23:19\ncategories: [Machine-Learning-Mathematics]\ntags: [Machine-Learning, Mathematics, Calculus]\nmathjax: true\ncopyright: true\ntop: 100\n---\n\n# Tylor Expansion Example\n\n> Tylor Expansion is a powerful tool to deal with limits. Some examples are showed below.\n\n## Prerequisite\n\nSee more about how to calculate derivative at this link and differential rules at this link.\n\n## Definition[1]\n\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}\n$$\n\n\nWhen a = 0, the formula is showed below.\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n\n\\end{align}\n$$\n\n\n## Examples\n### 1. Example 1\n\n$f(x) = e^x$\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{e^0}{ 0 !}x^0 + \\frac{e^0}{ 1 !}x^1 + \\frac{e^0}{ 2 !}x^2  + \\cdots + \\frac{e^0}{ n !}x^n \\\\\n&= \\frac{x^0}{ 0 !} + \\frac{x^1}{ 1 !} + \\frac{x^2}{ 2 !}  + \\cdots + \\frac{x^n}{ n !} \\\\\n\\end{align}\n$$\n\n\n### 1. Example 2\n\n$f(x) = \\sin x$\n$$\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{\\sin 0}{ 0 !}x^0 + \\frac{\\cos 0}{ 1 !}x^1 + \\frac{-\\sin 0}{ 2 !}x^2  + \\cdots\\\\\n&= \\frac{0}{ 0 !} + \\frac{1}{ 1 !}x^1 + \\frac{0}{ 2 !}  + \\cdots + \\frac{x^n}{ n !}  + \\cdots\\\\\n&= \\frac{x^1}{ 1 !} - \\frac{x^3}{ 3 !} + \\frac{x^5}{ 5 !} - \\frac{x^7}{ 7 !} + \\cdots \\\\\n\\end{align}\n$$\n\n\n\n## Reference\n[1] [wikipedia-Taylor series](https://en.wikipedia.org/wiki/Taylor_series)\n\n\n<br>\n<br>\n------------------------------------------","slug":"Mathematics/Calculus/2017-11-04-Typlor Expansion Example","published":1,"updated":"2018-10-27T04:30:42.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0e20042e0ow8g7vjdfh","content":"<h1 id=\"Tylor-Expansion-Example\"><a href=\"#Tylor-Expansion-Example\" class=\"headerlink\" title=\"Tylor Expansion Example\"></a>Tylor Expansion Example</h1><blockquote>\n<p>Tylor Expansion is a powerful tool to deal with limits. Some examples are showed below.</p>\n</blockquote>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><p>See more about how to calculate derivative at this link and differential rules at this link.</p>\n<h2 id=\"Definition-1\"><a href=\"#Definition-1\" class=\"headerlink\" title=\"Definition[1]\"></a>Definition[1]</h2><script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}</script><p>When a = 0, the formula is showed below.</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n\n\\end{align}</script><h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><h3 id=\"1-Example-1\"><a href=\"#1-Example-1\" class=\"headerlink\" title=\"1. Example 1\"></a>1. Example 1</h3><p>$f(x) = e^x$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{e^0}{ 0 !}x^0 + \\frac{e^0}{ 1 !}x^1 + \\frac{e^0}{ 2 !}x^2  + \\cdots + \\frac{e^0}{ n !}x^n \\\\\n&= \\frac{x^0}{ 0 !} + \\frac{x^1}{ 1 !} + \\frac{x^2}{ 2 !}  + \\cdots + \\frac{x^n}{ n !} \\\\\n\\end{align}</script><h3 id=\"1-Example-2\"><a href=\"#1-Example-2\" class=\"headerlink\" title=\"1. Example 2\"></a>1. Example 2</h3><p>$f(x) = \\sin x$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{\\sin 0}{ 0 !}x^0 + \\frac{\\cos 0}{ 1 !}x^1 + \\frac{-\\sin 0}{ 2 !}x^2  + \\cdots\\\\\n&= \\frac{0}{ 0 !} + \\frac{1}{ 1 !}x^1 + \\frac{0}{ 2 !}  + \\cdots + \\frac{x^n}{ n !}  + \\cdots\\\\\n&= \\frac{x^1}{ 1 !} - \\frac{x^3}{ 3 !} + \\frac{x^5}{ 5 !} - \\frac{x^7}{ 7 !} + \\cdots \\\\\n\\end{align}</script><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] <a href=\"https://en.wikipedia.org/wiki/Taylor_series\" target=\"_blank\" rel=\"external\">wikipedia-Taylor series</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Tylor-Expansion-Example\"><a href=\"#Tylor-Expansion-Example\" class=\"headerlink\" title=\"Tylor Expansion Example\"></a>Tylor Expansion Example</h1><blockquote>\n<p>Tylor Expansion is a powerful tool to deal with limits. Some examples are showed below.</p>\n</blockquote>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><p>See more about how to calculate derivative at this link and differential rules at this link.</p>\n<h2 id=\"Definition-1\"><a href=\"#Definition-1\" class=\"headerlink\" title=\"Definition[1]\"></a>Definition[1]</h2><script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}\\left( x - a \\right) ^ 0 + \\frac{f'\\left( a \\right)}{ 1 !}\\left( x - a \\right) ^ 1 + \\frac{f''\\left( a \\right)}{ 2 !}\\left( x - a \\right) ^ 2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}\\left( x - a \\right) ^ n\n\\end{align}</script><p>When a = 0, the formula is showed below.</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow a} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\sum\\limits_{n=0}^{\\infty} \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n\n\\end{align}</script><h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><h3 id=\"1-Example-1\"><a href=\"#1-Example-1\" class=\"headerlink\" title=\"1. Example 1\"></a>1. Example 1</h3><p>$f(x) = e^x$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{e^0}{ 0 !}x^0 + \\frac{e^0}{ 1 !}x^1 + \\frac{e^0}{ 2 !}x^2  + \\cdots + \\frac{e^0}{ n !}x^n \\\\\n&= \\frac{x^0}{ 0 !} + \\frac{x^1}{ 1 !} + \\frac{x^2}{ 2 !}  + \\cdots + \\frac{x^n}{ n !} \\\\\n\\end{align}</script><h3 id=\"1-Example-2\"><a href=\"#1-Example-2\" class=\"headerlink\" title=\"1. Example 2\"></a>1. Example 2</h3><p>$f(x) = \\sin x$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\lim\\limits_{x \\rightarrow 0} f(x)\n&= \\frac{f\\left( a \\right)}{ 0 !}x^0 + \\frac{f'\\left( a \\right)}{ 1 !}x^1 + \\frac{f''\\left( a \\right)}{ 2 !}x^2  + \\cdots + \\frac{f^{(n)}\\left( a \\right)}{ n !}x^n \\\\\n&= \\frac{\\sin 0}{ 0 !}x^0 + \\frac{\\cos 0}{ 1 !}x^1 + \\frac{-\\sin 0}{ 2 !}x^2  + \\cdots\\\\\n&= \\frac{0}{ 0 !} + \\frac{1}{ 1 !}x^1 + \\frac{0}{ 2 !}  + \\cdots + \\frac{x^n}{ n !}  + \\cdots\\\\\n&= \\frac{x^1}{ 1 !} - \\frac{x^3}{ 3 !} + \\frac{x^5}{ 5 !} - \\frac{x^7}{ 7 !} + \\cdots \\\\\n\\end{align}</script><h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] <a href=\"https://en.wikipedia.org/wiki/Taylor_series\" target=\"_blank\" rel=\"external\">wikipedia-Taylor series</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Git Bash Save Credential - Push without Entering Usename and Password Every Time (git bash in windows)","date":"2018-08-23T04:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\nIn Git Bash window, run the following command\n```\ngit config --global credential.helper wincred\n```\n\nThen run `git push` once again and enter your credentials (username and password). Then all this information will be saved.\n\n\n<br>\n<br>\n---------------------------------------","source":"_posts/Others/Git/2018-08-23-Git Bash Save Credential - Push without Entering Usename and Password Every Time (git bash in windows).md","raw":"---\ntitle: Git Bash Save Credential - Push without Entering Usename and Password Every Time (git bash in windows)\ndate: 2018-08-23 12:23:19\ncategories: [Git]\ntags: [Git]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\nIn Git Bash window, run the following command\n```\ngit config --global credential.helper wincred\n```\n\nThen run `git push` once again and enter your credentials (username and password). Then all this information will be saved.\n\n\n<br>\n<br>\n---------------------------------------","slug":"Others/Git/2018-08-23-Git Bash Save Credential - Push without Entering Usename and Password Every Time (git bash in windows)","published":1,"updated":"2018-10-27T04:30:42.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0e40044e0owpywjcj7k","content":"<p>In Git Bash window, run the following command<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global credential.helper wincred</div></pre></td></tr></table></figure></p>\n<p>Then run <code>git push</code> once again and enter your credentials (username and password). Then all this information will be saved.</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<p>In Git Bash window, run the following command<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global credential.helper wincred</div></pre></td></tr></table></figure></p>\n<p>Then run <code>git push</code> once again and enter your credentials (username and password). Then all this information will be saved.</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Workflow of Resolve Comflicts","date":"2018-08-21T03:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n\n1. Get up-to-date commits\n    ```\n    git pull\n    ```\n\n2. Then get comflicts when merging.\n    ```\n    computer:my-repository emmap$ git pull origin master\n     * master            master     -> FETCH_HEAD\n    Auto-merging team_contact_info.txt\n    CONFLICT (content): Merge conflict in team_contact_info.txt\n    Automatic merge failed; fix conflicts and then commit the result.\n    ```\n\n3. Resolve the conflict by doing the following\n\n4. Add and commit the change\n    ```\n    git add -A\n    git commit -am \"resolve conflict\n    ```\n\n5. Push the change to remote repository\n    ```\n    git push\n    ```\n\nRef: [Resolve merge conflicts](https://confluence.atlassian.com/bitbucket/resolve-merge-conflicts-704414003.html)\n\n<br>\n<br>\n---------------------------------------","source":"_posts/Others/Git/2018-08-21-Workflow of Resolve Comflicts.md","raw":"---\ntitle: Workflow of Resolve Comflicts\ndate: 2018-08-21 11:23:19\ncategories: [Git]\ntags: [Git]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n\n1. Get up-to-date commits\n    ```\n    git pull\n    ```\n\n2. Then get comflicts when merging.\n    ```\n    computer:my-repository emmap$ git pull origin master\n     * master            master     -> FETCH_HEAD\n    Auto-merging team_contact_info.txt\n    CONFLICT (content): Merge conflict in team_contact_info.txt\n    Automatic merge failed; fix conflicts and then commit the result.\n    ```\n\n3. Resolve the conflict by doing the following\n\n4. Add and commit the change\n    ```\n    git add -A\n    git commit -am \"resolve conflict\n    ```\n\n5. Push the change to remote repository\n    ```\n    git push\n    ```\n\nRef: [Resolve merge conflicts](https://confluence.atlassian.com/bitbucket/resolve-merge-conflicts-704414003.html)\n\n<br>\n<br>\n---------------------------------------","slug":"Others/Git/2018-08-21-Workflow of Resolve Comflicts","published":1,"updated":"2018-10-27T04:30:42.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0e50048e0owg9bo971w","content":"<ol>\n<li><p>Get up-to-date commits</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div></pre></td></tr></table></figure>\n</li>\n<li><p>Then get comflicts when merging.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">computer:my-repository emmap$ git pull origin master</div><div class=\"line\"> * master            master     -&gt; FETCH_HEAD</div><div class=\"line\">Auto-merging team_contact_info.txt</div><div class=\"line\">CONFLICT (content): Merge conflict in team_contact_info.txt</div><div class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>\n</li>\n<li><p>Resolve the conflict by doing the following</p>\n</li>\n<li><p>Add and commit the change</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add -A</div><div class=\"line\">git commit -am &quot;resolve conflict</div></pre></td></tr></table></figure>\n</li>\n<li><p>Push the change to remote repository</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Ref: <a href=\"https://confluence.atlassian.com/bitbucket/resolve-merge-conflicts-704414003.html\" target=\"_blank\" rel=\"external\">Resolve merge conflicts</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Get up-to-date commits</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div></pre></td></tr></table></figure>\n</li>\n<li><p>Then get comflicts when merging.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">computer:my-repository emmap$ git pull origin master</div><div class=\"line\"> * master            master     -&gt; FETCH_HEAD</div><div class=\"line\">Auto-merging team_contact_info.txt</div><div class=\"line\">CONFLICT (content): Merge conflict in team_contact_info.txt</div><div class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>\n</li>\n<li><p>Resolve the conflict by doing the following</p>\n</li>\n<li><p>Add and commit the change</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add -A</div><div class=\"line\">git commit -am &quot;resolve conflict</div></pre></td></tr></table></figure>\n</li>\n<li><p>Push the change to remote repository</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Ref: <a href=\"https://confluence.atlassian.com/bitbucket/resolve-merge-conflicts-704414003.html\" target=\"_blank\" rel=\"external\">Resolve merge conflicts</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Deploy Blog With Hexo And Github Page","date":"2017-11-22T03:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n# Deploy Blog With Hexo And Github Page\n\nThis blog aims to write down the process of deploying a personal website, and the difficulties which I have met.\n\n## Platform:\n1. Hexo\n2. Github Page\n3. Windows 10\n\n## Prerequisite\n1. Regist Github and Create a repository for github page\n2. Install Node.js in you local PC.\n3. Add the ssh key to your Github\n> Test: ssh -T git@github.com\n> If you run this command without error, it means you are good to go.\n\n## Hexo Installation and Deployment\n\n### Install Hexo\n1. mkdir <Folder for Hexo>\n2. cd <Folder for Hexo>\n3. npm install -g hexo-cli\n4. hexo\n> you should have get this message.\n\n```\nD:\\Blog\\zhichengML> hexo\nUsage: hexo <command>\nCommands:\n  clean     Remove generated files and cache.\n  config    Get or set configurations.\n  deploy    Deploy your website.\n  generate  Generate static files.\n  help      Get help on a command.\n  init      Create a new Hexo folder.\n  list      List the information of the site\n  migrate   Migrate your site from other system to Hexo.\n  new       Create a new post.\n  publish   Moves a draft post from _drafts to _posts folder.\n  render    Render files with renderer plugins.\n  server    Start the server.\n  version   Display version information.\n\nGlobal Options:\n  --config  Specify config file instead of using _config.yml\n  --cwd     Specify the CWD\n  --debug   Display all verbose messages in the terminal\n  --draft   Display draft posts\n  --safe    Disable all plugins and scripts\n  --silent  Hide output on console\n\nFor more help, you can use 'hexo help [command]' for the detailed information\nor you can check the docs: http://hexo.io/docs/\n```\n\n### Deploy Website\n#### Init Hexo\n1. hexo init <blog name>\n2. cd <blog name>\n3. npm install\n\n#### Config Hexo\n1. Open \"_config.yml\" file and override this file with your information\n>The Origin file\n```\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: # The title of your website\nsubtitle: # The subtitle of your website\ndescription: # The description of your website\nauthor: # Your name\nlanguage: # The language of your website\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com/child\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: landscape\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type:\n```\n\n> You should override at least \"# Site\" and \"# Deployment\" session\nE.g.\n```\n# Site\ntitle: zhichengML\nsubtitle:\ndescription: Personal Website\nauthor: zhichengML\nlanguage: en\ntimezone: Asia/Shanghai\n```\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhichengML/zhichengML.github.io.git\n  branch: master\n```\nNote that, there must be a blank space \" \" between label and information, e.g., \"type: git\"\n\n#### Preview Your Website in Local PC\n1. hexo server\n> The default port is 4000. You may want to change that with command hexo server -p <port>.\n2. Open you local pc for test.\n\n#### Deploy Website\n1. hexo generate\n2. hexo deploy\n> You may met problem when deploying.\n> See the troubleshoot for more information\n\n## Troubleshoots\n1. There is no response when running \"hexo deploy\"\n> Open \"_config.yml\" file and check if you have a space between the label and information. E.g., \"type: git\".\n\n2. Deployer not found: git\n> Becaue the older hexo use github, while the latest one(3.0) use git. So make sure you had typed \"type: git\" instead of \"type: github\". Then, install the git delopyer with command \"npm install hexo-deployer-git --save\"\n\n3. fatal: Not a git repository (or any of the parent directories): .git\n> Make sure you could run \"ssh -T git@github.com\" correctly. Then, delte the \".deploy_git\" directory, and run \"hexo deploy\" again.\n\n\n## Reference\n[1] [20分钟教你使用hexo搭建github博客](http://www.jianshu.com/p/e99ed60390a8)\n[2] [针对github权限导致hexo部署失败的解决方案][http://www.cnblogs.com/xsilence/p/6001938.html]\n\n\n\n<br>\n<br>\n---------------------------------------","source":"_posts/Others/Hexos/2017-11-22-Deploy Blog With Hexo And Github Page.md","raw":"---\ntitle: Deploy Blog With Hexo And Github Page\ndate: 2017-11-22 11:23:19\ncategories: [Hexo]\ntags: [Hexo]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n# Deploy Blog With Hexo And Github Page\n\nThis blog aims to write down the process of deploying a personal website, and the difficulties which I have met.\n\n## Platform:\n1. Hexo\n2. Github Page\n3. Windows 10\n\n## Prerequisite\n1. Regist Github and Create a repository for github page\n2. Install Node.js in you local PC.\n3. Add the ssh key to your Github\n> Test: ssh -T git@github.com\n> If you run this command without error, it means you are good to go.\n\n## Hexo Installation and Deployment\n\n### Install Hexo\n1. mkdir <Folder for Hexo>\n2. cd <Folder for Hexo>\n3. npm install -g hexo-cli\n4. hexo\n> you should have get this message.\n\n```\nD:\\Blog\\zhichengML> hexo\nUsage: hexo <command>\nCommands:\n  clean     Remove generated files and cache.\n  config    Get or set configurations.\n  deploy    Deploy your website.\n  generate  Generate static files.\n  help      Get help on a command.\n  init      Create a new Hexo folder.\n  list      List the information of the site\n  migrate   Migrate your site from other system to Hexo.\n  new       Create a new post.\n  publish   Moves a draft post from _drafts to _posts folder.\n  render    Render files with renderer plugins.\n  server    Start the server.\n  version   Display version information.\n\nGlobal Options:\n  --config  Specify config file instead of using _config.yml\n  --cwd     Specify the CWD\n  --debug   Display all verbose messages in the terminal\n  --draft   Display draft posts\n  --safe    Disable all plugins and scripts\n  --silent  Hide output on console\n\nFor more help, you can use 'hexo help [command]' for the detailed information\nor you can check the docs: http://hexo.io/docs/\n```\n\n### Deploy Website\n#### Init Hexo\n1. hexo init <blog name>\n2. cd <blog name>\n3. npm install\n\n#### Config Hexo\n1. Open \"_config.yml\" file and override this file with your information\n>The Origin file\n```\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: # The title of your website\nsubtitle: # The subtitle of your website\ndescription: # The description of your website\nauthor: # Your name\nlanguage: # The language of your website\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com/child\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: landscape\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type:\n```\n\n> You should override at least \"# Site\" and \"# Deployment\" session\nE.g.\n```\n# Site\ntitle: zhichengML\nsubtitle:\ndescription: Personal Website\nauthor: zhichengML\nlanguage: en\ntimezone: Asia/Shanghai\n```\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:zhichengML/zhichengML.github.io.git\n  branch: master\n```\nNote that, there must be a blank space \" \" between label and information, e.g., \"type: git\"\n\n#### Preview Your Website in Local PC\n1. hexo server\n> The default port is 4000. You may want to change that with command hexo server -p <port>.\n2. Open you local pc for test.\n\n#### Deploy Website\n1. hexo generate\n2. hexo deploy\n> You may met problem when deploying.\n> See the troubleshoot for more information\n\n## Troubleshoots\n1. There is no response when running \"hexo deploy\"\n> Open \"_config.yml\" file and check if you have a space between the label and information. E.g., \"type: git\".\n\n2. Deployer not found: git\n> Becaue the older hexo use github, while the latest one(3.0) use git. So make sure you had typed \"type: git\" instead of \"type: github\". Then, install the git delopyer with command \"npm install hexo-deployer-git --save\"\n\n3. fatal: Not a git repository (or any of the parent directories): .git\n> Make sure you could run \"ssh -T git@github.com\" correctly. Then, delte the \".deploy_git\" directory, and run \"hexo deploy\" again.\n\n\n## Reference\n[1] [20分钟教你使用hexo搭建github博客](http://www.jianshu.com/p/e99ed60390a8)\n[2] [针对github权限导致hexo部署失败的解决方案][http://www.cnblogs.com/xsilence/p/6001938.html]\n\n\n\n<br>\n<br>\n---------------------------------------","slug":"Others/Hexos/2017-11-22-Deploy Blog With Hexo And Github Page","published":1,"updated":"2018-10-27T04:30:42.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0e8004ce0ow5hg4k3kq","content":"<h1 id=\"Deploy-Blog-With-Hexo-And-Github-Page\"><a href=\"#Deploy-Blog-With-Hexo-And-Github-Page\" class=\"headerlink\" title=\"Deploy Blog With Hexo And Github Page\"></a>Deploy Blog With Hexo And Github Page</h1><p>This blog aims to write down the process of deploying a personal website, and the difficulties which I have met.</p>\n<h2 id=\"Platform\"><a href=\"#Platform\" class=\"headerlink\" title=\"Platform:\"></a>Platform:</h2><ol>\n<li>Hexo</li>\n<li>Github Page</li>\n<li>Windows 10</li>\n</ol>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><ol>\n<li>Regist Github and Create a repository for github page</li>\n<li>Install Node.js in you local PC.</li>\n<li>Add the ssh key to your Github<blockquote>\n<p>Test: ssh -T git@github.com<br>If you run this command without error, it means you are good to go.</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Hexo-Installation-and-Deployment\"><a href=\"#Hexo-Installation-and-Deployment\" class=\"headerlink\" title=\"Hexo Installation and Deployment\"></a>Hexo Installation and Deployment</h2><h3 id=\"Install-Hexo\"><a href=\"#Install-Hexo\" class=\"headerlink\" title=\"Install Hexo\"></a>Install Hexo</h3><ol>\n<li>mkdir <folder for=\"\" hexo=\"\"></folder></li>\n<li>cd <folder for=\"\" hexo=\"\"></folder></li>\n<li>npm install -g hexo-cli</li>\n<li>hexo<blockquote>\n<p>you should have get this message.</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\Blog\\zhichengML&gt; hexo</div><div class=\"line\">Usage: hexo &lt;command&gt;</div><div class=\"line\">Commands:</div><div class=\"line\">  clean     Remove generated files and cache.</div><div class=\"line\">  config    Get or set configurations.</div><div class=\"line\">  deploy    Deploy your website.</div><div class=\"line\">  generate  Generate static files.</div><div class=\"line\">  help      Get help on a command.</div><div class=\"line\">  init      Create a new Hexo folder.</div><div class=\"line\">  list      List the information of the site</div><div class=\"line\">  migrate   Migrate your site from other system to Hexo.</div><div class=\"line\">  new       Create a new post.</div><div class=\"line\">  publish   Moves a draft post from _drafts to _posts folder.</div><div class=\"line\">  render    Render files with renderer plugins.</div><div class=\"line\">  server    Start the server.</div><div class=\"line\">  version   Display version information.</div><div class=\"line\"></div><div class=\"line\">Global Options:</div><div class=\"line\">  --config  Specify config file instead of using _config.yml</div><div class=\"line\">  --cwd     Specify the CWD</div><div class=\"line\">  --debug   Display all verbose messages in the terminal</div><div class=\"line\">  --draft   Display draft posts</div><div class=\"line\">  --safe    Disable all plugins and scripts</div><div class=\"line\">  --silent  Hide output on console</div><div class=\"line\"></div><div class=\"line\">For more help, you can use &apos;hexo help [command]&apos; for the detailed information</div><div class=\"line\">or you can check the docs: http://hexo.io/docs/</div></pre></td></tr></table></figure>\n<h3 id=\"Deploy-Website\"><a href=\"#Deploy-Website\" class=\"headerlink\" title=\"Deploy Website\"></a>Deploy Website</h3><h4 id=\"Init-Hexo\"><a href=\"#Init-Hexo\" class=\"headerlink\" title=\"Init Hexo\"></a>Init Hexo</h4><ol>\n<li>hexo init <blog name=\"\"></blog></li>\n<li>cd <blog name=\"\"></blog></li>\n<li>npm install</li>\n</ol>\n<h4 id=\"Config-Hexo\"><a href=\"#Config-Hexo\" class=\"headerlink\" title=\"Config Hexo\"></a>Config Hexo</h4><ol>\n<li>Open “_config.yml” file and override this file with your information<blockquote>\n<p>The Origin file</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: https://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: # The title of your website</div><div class=\"line\">subtitle: # The subtitle of your website</div><div class=\"line\">description: # The description of your website</div><div class=\"line\">author: # Your name</div><div class=\"line\">language: # The language of your website</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com/child</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: false</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 10</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: https://hexo.io/plugins/</div><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: landscape</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type:</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>You should override at least “# Site” and “# Deployment” session<br>E.g.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Site</div><div class=\"line\">title: zhichengML</div><div class=\"line\">subtitle:</div><div class=\"line\">description: Personal Website</div><div class=\"line\">author: zhichengML</div><div class=\"line\">language: en</div><div class=\"line\">timezone: Asia/Shanghai</div></pre></td></tr></table></figure></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo: git@github.com:zhichengML/zhichengML.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>Note that, there must be a blank space “ “ between label and information, e.g., “type: git”</p>\n<h4 id=\"Preview-Your-Website-in-Local-PC\"><a href=\"#Preview-Your-Website-in-Local-PC\" class=\"headerlink\" title=\"Preview Your Website in Local PC\"></a>Preview Your Website in Local PC</h4><ol>\n<li>hexo server<blockquote>\n<p>The default port is 4000. You may want to change that with command hexo server -p <port>.</port></p>\n</blockquote>\n</li>\n<li>Open you local pc for test.</li>\n</ol>\n<h4 id=\"Deploy-Website-1\"><a href=\"#Deploy-Website-1\" class=\"headerlink\" title=\"Deploy Website\"></a>Deploy Website</h4><ol>\n<li>hexo generate</li>\n<li>hexo deploy<blockquote>\n<p>You may met problem when deploying.<br>See the troubleshoot for more information</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Troubleshoots\"><a href=\"#Troubleshoots\" class=\"headerlink\" title=\"Troubleshoots\"></a>Troubleshoots</h2><ol>\n<li><p>There is no response when running “hexo deploy”</p>\n<blockquote>\n<p>Open “_config.yml” file and check if you have a space between the label and information. E.g., “type: git”.</p>\n</blockquote>\n</li>\n<li><p>Deployer not found: git</p>\n<blockquote>\n<p>Becaue the older hexo use github, while the latest one(3.0) use git. So make sure you had typed “type: git” instead of “type: github”. Then, install the git delopyer with command “npm install hexo-deployer-git —save”</p>\n</blockquote>\n</li>\n<li><p>fatal: Not a git repository (or any of the parent directories): .git</p>\n<blockquote>\n<p>Make sure you could run “ssh -T git@github.com” correctly. Then, delte the “.deploy_git” directory, and run “hexo deploy” again.</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] <a href=\"http://www.jianshu.com/p/e99ed60390a8\" target=\"_blank\" rel=\"external\">20分钟教你使用hexo搭建github博客</a><br>[2] [针对github权限导致hexo部署失败的解决方案][<a href=\"http://www.cnblogs.com/xsilence/p/6001938.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/xsilence/p/6001938.html</a>]</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Deploy-Blog-With-Hexo-And-Github-Page\"><a href=\"#Deploy-Blog-With-Hexo-And-Github-Page\" class=\"headerlink\" title=\"Deploy Blog With Hexo And Github Page\"></a>Deploy Blog With Hexo And Github Page</h1><p>This blog aims to write down the process of deploying a personal website, and the difficulties which I have met.</p>\n<h2 id=\"Platform\"><a href=\"#Platform\" class=\"headerlink\" title=\"Platform:\"></a>Platform:</h2><ol>\n<li>Hexo</li>\n<li>Github Page</li>\n<li>Windows 10</li>\n</ol>\n<h2 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h2><ol>\n<li>Regist Github and Create a repository for github page</li>\n<li>Install Node.js in you local PC.</li>\n<li>Add the ssh key to your Github<blockquote>\n<p>Test: ssh -T git@github.com<br>If you run this command without error, it means you are good to go.</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Hexo-Installation-and-Deployment\"><a href=\"#Hexo-Installation-and-Deployment\" class=\"headerlink\" title=\"Hexo Installation and Deployment\"></a>Hexo Installation and Deployment</h2><h3 id=\"Install-Hexo\"><a href=\"#Install-Hexo\" class=\"headerlink\" title=\"Install Hexo\"></a>Install Hexo</h3><ol>\n<li>mkdir <folder for=\"\" hexo=\"\"></folder></li>\n<li>cd <folder for=\"\" hexo=\"\"></folder></li>\n<li>npm install -g hexo-cli</li>\n<li>hexo<blockquote>\n<p>you should have get this message.</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\Blog\\zhichengML&gt; hexo</div><div class=\"line\">Usage: hexo &lt;command&gt;</div><div class=\"line\">Commands:</div><div class=\"line\">  clean     Remove generated files and cache.</div><div class=\"line\">  config    Get or set configurations.</div><div class=\"line\">  deploy    Deploy your website.</div><div class=\"line\">  generate  Generate static files.</div><div class=\"line\">  help      Get help on a command.</div><div class=\"line\">  init      Create a new Hexo folder.</div><div class=\"line\">  list      List the information of the site</div><div class=\"line\">  migrate   Migrate your site from other system to Hexo.</div><div class=\"line\">  new       Create a new post.</div><div class=\"line\">  publish   Moves a draft post from _drafts to _posts folder.</div><div class=\"line\">  render    Render files with renderer plugins.</div><div class=\"line\">  server    Start the server.</div><div class=\"line\">  version   Display version information.</div><div class=\"line\"></div><div class=\"line\">Global Options:</div><div class=\"line\">  --config  Specify config file instead of using _config.yml</div><div class=\"line\">  --cwd     Specify the CWD</div><div class=\"line\">  --debug   Display all verbose messages in the terminal</div><div class=\"line\">  --draft   Display draft posts</div><div class=\"line\">  --safe    Disable all plugins and scripts</div><div class=\"line\">  --silent  Hide output on console</div><div class=\"line\"></div><div class=\"line\">For more help, you can use &apos;hexo help [command]&apos; for the detailed information</div><div class=\"line\">or you can check the docs: http://hexo.io/docs/</div></pre></td></tr></table></figure>\n<h3 id=\"Deploy-Website\"><a href=\"#Deploy-Website\" class=\"headerlink\" title=\"Deploy Website\"></a>Deploy Website</h3><h4 id=\"Init-Hexo\"><a href=\"#Init-Hexo\" class=\"headerlink\" title=\"Init Hexo\"></a>Init Hexo</h4><ol>\n<li>hexo init <blog name=\"\"></blog></li>\n<li>cd <blog name=\"\"></blog></li>\n<li>npm install</li>\n</ol>\n<h4 id=\"Config-Hexo\"><a href=\"#Config-Hexo\" class=\"headerlink\" title=\"Config Hexo\"></a>Config Hexo</h4><ol>\n<li>Open “_config.yml” file and override this file with your information<blockquote>\n<p>The Origin file</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: https://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: # The title of your website</div><div class=\"line\">subtitle: # The subtitle of your website</div><div class=\"line\">description: # The description of your website</div><div class=\"line\">author: # Your name</div><div class=\"line\">language: # The language of your website</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com/child</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: false</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 10</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: https://hexo.io/plugins/</div><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: landscape</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type:</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>You should override at least “# Site” and “# Deployment” session<br>E.g.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Site</div><div class=\"line\">title: zhichengML</div><div class=\"line\">subtitle:</div><div class=\"line\">description: Personal Website</div><div class=\"line\">author: zhichengML</div><div class=\"line\">language: en</div><div class=\"line\">timezone: Asia/Shanghai</div></pre></td></tr></table></figure></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo: git@github.com:zhichengML/zhichengML.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>Note that, there must be a blank space “ “ between label and information, e.g., “type: git”</p>\n<h4 id=\"Preview-Your-Website-in-Local-PC\"><a href=\"#Preview-Your-Website-in-Local-PC\" class=\"headerlink\" title=\"Preview Your Website in Local PC\"></a>Preview Your Website in Local PC</h4><ol>\n<li>hexo server<blockquote>\n<p>The default port is 4000. You may want to change that with command hexo server -p <port>.</port></p>\n</blockquote>\n</li>\n<li>Open you local pc for test.</li>\n</ol>\n<h4 id=\"Deploy-Website-1\"><a href=\"#Deploy-Website-1\" class=\"headerlink\" title=\"Deploy Website\"></a>Deploy Website</h4><ol>\n<li>hexo generate</li>\n<li>hexo deploy<blockquote>\n<p>You may met problem when deploying.<br>See the troubleshoot for more information</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Troubleshoots\"><a href=\"#Troubleshoots\" class=\"headerlink\" title=\"Troubleshoots\"></a>Troubleshoots</h2><ol>\n<li><p>There is no response when running “hexo deploy”</p>\n<blockquote>\n<p>Open “_config.yml” file and check if you have a space between the label and information. E.g., “type: git”.</p>\n</blockquote>\n</li>\n<li><p>Deployer not found: git</p>\n<blockquote>\n<p>Becaue the older hexo use github, while the latest one(3.0) use git. So make sure you had typed “type: git” instead of “type: github”. Then, install the git delopyer with command “npm install hexo-deployer-git —save”</p>\n</blockquote>\n</li>\n<li><p>fatal: Not a git repository (or any of the parent directories): .git</p>\n<blockquote>\n<p>Make sure you could run “ssh -T git@github.com” correctly. Then, delte the “.deploy_git” directory, and run “hexo deploy” again.</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>[1] <a href=\"http://www.jianshu.com/p/e99ed60390a8\" target=\"_blank\" rel=\"external\">20分钟教你使用hexo搭建github博客</a><br>[2] [针对github权限导致hexo部署失败的解决方案][<a href=\"http://www.cnblogs.com/xsilence/p/6001938.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/xsilence/p/6001938.html</a>]</p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"How to Render the Hyperlink with Braces","date":"2017-12-03T03:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n# How to Render the Hyperlink with Braces\n\n## Here is the code\n\n```\n![Reorganized Dichotomies of B(4,3) - 1][11]\n\n[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\n```\n\n\n## Here is the result\n\n![Reorganized Dichotomies of B(4,3) - 1][11]\n\n[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\n\n\n<br>\n<br>\n---------------------------------------","source":"_posts/Others/Markdown/2017-12-03-How to Render the Hyperlink with Braces.md","raw":"---\ntitle: How to Render the Hyperlink with Braces\ndate: 2017-12-03 11:23:19\ncategories: [Markdown]\ntags: [Markdown]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n# How to Render the Hyperlink with Braces\n\n## Here is the code\n\n```\n![Reorganized Dichotomies of B(4,3) - 1][11]\n\n[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\n```\n\n\n## Here is the result\n\n![Reorganized Dichotomies of B(4,3) - 1][11]\n\n[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\n\n\n<br>\n<br>\n---------------------------------------","slug":"Others/Markdown/2017-12-03-How to Render the Hyperlink with Braces","published":1,"updated":"2018-10-27T04:30:42.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0e9004ge0ow8vlyt5wb","content":"<h1 id=\"How-to-Render-the-Hyperlink-with-Braces\"><a href=\"#How-to-Render-the-Hyperlink-with-Braces\" class=\"headerlink\" title=\"How to Render the Hyperlink with Braces\"></a>How to Render the Hyperlink with Braces</h1><h2 id=\"Here-is-the-code\"><a href=\"#Here-is-the-code\" class=\"headerlink\" title=\"Here is the code\"></a>Here is the code</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">![Reorganized Dichotomies of B(4,3) - 1][11]</div><div class=\"line\"></div><div class=\"line\">[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png</div></pre></td></tr></table></figure>\n<h2 id=\"Here-is-the-result\"><a href=\"#Here-is-the-result\" class=\"headerlink\" title=\"Here is the result\"></a>Here is the result</h2><p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\" alt=\"Reorganized Dichotomies of B(4,3) - 1\"></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-to-Render-the-Hyperlink-with-Braces\"><a href=\"#How-to-Render-the-Hyperlink-with-Braces\" class=\"headerlink\" title=\"How to Render the Hyperlink with Braces\"></a>How to Render the Hyperlink with Braces</h1><h2 id=\"Here-is-the-code\"><a href=\"#Here-is-the-code\" class=\"headerlink\" title=\"Here is the code\"></a>Here is the code</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">![Reorganized Dichotomies of B(4,3) - 1][11]</div><div class=\"line\"></div><div class=\"line\">[11]:https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png</div></pre></td></tr></table></figure>\n<h2 id=\"Here-is-the-result\"><a href=\"#Here-is-the-result\" class=\"headerlink\" title=\"Here is the result\"></a>Here is the result</h2><p><img src=\"https://raw.githubusercontent.com/zhichengML/MarkdownPhoto/master/MachineLearning/Machine%20Learning%20Foundation%20--%20Hsuan-Tien%20Lin%20in%20NTU/chapter5-11%20B(4%2C3)%20-%201.png\" alt=\"Reorganized Dichotomies of B(4,3) - 1\"></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"Hexo Next Theme Beautification","date":"2017-11-23T03:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n\n# Hexo Next Theme Beautification\n\n> There are a lot of other blog which demostrate how to beautify the Hexo-Next Theme.\n\n1. [hexo下新建页面下如何放多个文章？](http://www.zhihu.com/question/33324071/answer/58775540?group_id=654307162210365440#comment-106092511)\n2. [玩转Hexo博客之Next](http://www.jianshu.com/p/f869d1940985)\n3. [动动手指，NexT主题与Hexo更搭哦（基础篇） ](http://www.arao.me/2015/hexo-next-theme-optimize-base/#hexo_NexT%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5title%E7%9A%84%E4%BC%98%E5%8C%96)\n4. [动动手指，不限于NexT主题的Hexo优化（SEO篇）](http://www.arao.me/2015/hexo-next-theme-optimize-seo/)\n5. [动动手指，给你的Hexo站点添加最近访客（多说篇）](http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/)\n6. [hexo的next主题个性化教程：打造炫酷网站 ](http://blog.csdn.net/qq_33699981/article/details/72716951)\n7. [Hexo-Next-主题优化(四)](http://www.jianshu.com/p/4ef35521fee9)\n\n<br>\n<br>\n---------------------------------------","source":"_posts/Others/Hexos/2017-11-23-Hexo Next Theme Beautification.md","raw":"---\ntitle: Hexo Next Theme Beautification\ndate: 2017-11-23 11:23:19\ncategories: [Hexo]\ntags: [Hexo]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n\n# Hexo Next Theme Beautification\n\n> There are a lot of other blog which demostrate how to beautify the Hexo-Next Theme.\n\n1. [hexo下新建页面下如何放多个文章？](http://www.zhihu.com/question/33324071/answer/58775540?group_id=654307162210365440#comment-106092511)\n2. [玩转Hexo博客之Next](http://www.jianshu.com/p/f869d1940985)\n3. [动动手指，NexT主题与Hexo更搭哦（基础篇） ](http://www.arao.me/2015/hexo-next-theme-optimize-base/#hexo_NexT%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5title%E7%9A%84%E4%BC%98%E5%8C%96)\n4. [动动手指，不限于NexT主题的Hexo优化（SEO篇）](http://www.arao.me/2015/hexo-next-theme-optimize-seo/)\n5. [动动手指，给你的Hexo站点添加最近访客（多说篇）](http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/)\n6. [hexo的next主题个性化教程：打造炫酷网站 ](http://blog.csdn.net/qq_33699981/article/details/72716951)\n7. [Hexo-Next-主题优化(四)](http://www.jianshu.com/p/4ef35521fee9)\n\n<br>\n<br>\n---------------------------------------","slug":"Others/Hexos/2017-11-23-Hexo Next Theme Beautification","published":1,"updated":"2018-10-27T04:30:42.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0ea004je0ow3wpz8bt0","content":"<h1 id=\"Hexo-Next-Theme-Beautification\"><a href=\"#Hexo-Next-Theme-Beautification\" class=\"headerlink\" title=\"Hexo Next Theme Beautification\"></a>Hexo Next Theme Beautification</h1><blockquote>\n<p>There are a lot of other blog which demostrate how to beautify the Hexo-Next Theme.</p>\n</blockquote>\n<ol>\n<li><a href=\"http://www.zhihu.com/question/33324071/answer/58775540?group_id=654307162210365440#comment-106092511\" target=\"_blank\" rel=\"external\">hexo下新建页面下如何放多个文章？</a></li>\n<li><a href=\"http://www.jianshu.com/p/f869d1940985\" target=\"_blank\" rel=\"external\">玩转Hexo博客之Next</a></li>\n<li><a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-base/#hexo_NexT%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5title%E7%9A%84%E4%BC%98%E5%8C%96\" target=\"_blank\" rel=\"external\">动动手指，NexT主题与Hexo更搭哦（基础篇） </a></li>\n<li><a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-seo/\" target=\"_blank\" rel=\"external\">动动手指，不限于NexT主题的Hexo优化（SEO篇）</a></li>\n<li><a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/\" target=\"_blank\" rel=\"external\">动动手指，给你的Hexo站点添加最近访客（多说篇）</a></li>\n<li><a href=\"http://blog.csdn.net/qq_33699981/article/details/72716951\" target=\"_blank\" rel=\"external\">hexo的next主题个性化教程：打造炫酷网站 </a></li>\n<li><a href=\"http://www.jianshu.com/p/4ef35521fee9\" target=\"_blank\" rel=\"external\">Hexo-Next-主题优化(四)</a></li>\n</ol>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hexo-Next-Theme-Beautification\"><a href=\"#Hexo-Next-Theme-Beautification\" class=\"headerlink\" title=\"Hexo Next Theme Beautification\"></a>Hexo Next Theme Beautification</h1><blockquote>\n<p>There are a lot of other blog which demostrate how to beautify the Hexo-Next Theme.</p>\n</blockquote>\n<ol>\n<li><a href=\"http://www.zhihu.com/question/33324071/answer/58775540?group_id=654307162210365440#comment-106092511\" target=\"_blank\" rel=\"external\">hexo下新建页面下如何放多个文章？</a></li>\n<li><a href=\"http://www.jianshu.com/p/f869d1940985\" target=\"_blank\" rel=\"external\">玩转Hexo博客之Next</a></li>\n<li><a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-base/#hexo_NexT%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5title%E7%9A%84%E4%BC%98%E5%8C%96\" target=\"_blank\" rel=\"external\">动动手指，NexT主题与Hexo更搭哦（基础篇） </a></li>\n<li><a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-seo/\" target=\"_blank\" rel=\"external\">动动手指，不限于NexT主题的Hexo优化（SEO篇）</a></li>\n<li><a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/\" target=\"_blank\" rel=\"external\">动动手指，给你的Hexo站点添加最近访客（多说篇）</a></li>\n<li><a href=\"http://blog.csdn.net/qq_33699981/article/details/72716951\" target=\"_blank\" rel=\"external\">hexo的next主题个性化教程：打造炫酷网站 </a></li>\n<li><a href=\"http://www.jianshu.com/p/4ef35521fee9\" target=\"_blank\" rel=\"external\">Hexo-Next-主题优化(四)</a></li>\n</ol>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"},{"title":"How to use MathJax in Markdown","date":"2017-11-30T03:23:19.000Z","mathjax":false,"copyright":true,"top":100,"_content":"\n# How to use MathJax in Markdown\n\n\n## When to Use MathJax?\n When using markdown to write blog, especially using Github Page to do it. You may have trouble to display formula. There are several ways[1] to do that. But the simplest way is to use MathJax.\n\n## How to Use MathJax?\nAdd the code below to your markdown file, and that's it!\n\n```\n<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n```\n\n\nFor example, add the test code to your blog.md file\n```\n<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\ntest: $$n==x$$\n```\n\n\n# Reference\n[1] [Markdown中插入数学公式的方法](http://blog.csdn.net/xiahouzuoxin/article/details/26478179)\n\n[2] [MathJax Chinese Doc 2.0 documentation](http://mathjax-chinese-doc.readthedocs.io/en/latest/start.html)\n\n[3] [MathJax basic tutorial and quick reference](https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference)\n\n[4] [docs.mathjax.org](http://docs.mathjax.org/en/latest/configuration.html#loading)\n\n<br>\n<br>\n---------------------------------------","source":"_posts/Others/Markdown/2017-11-30-How to use MathJax in Markdown.md","raw":"---\ntitle: How to use MathJax in Markdown\ndate: 2017-11-30 11:23:19\ncategories: [Markdown]\ntags: [Markdown, Mathjax]\nmathjax: false\ncopyright: true\ntop: 100\n---\n\n# How to use MathJax in Markdown\n\n\n## When to Use MathJax?\n When using markdown to write blog, especially using Github Page to do it. You may have trouble to display formula. There are several ways[1] to do that. But the simplest way is to use MathJax.\n\n## How to Use MathJax?\nAdd the code below to your markdown file, and that's it!\n\n```\n<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n```\n\n\nFor example, add the test code to your blog.md file\n```\n<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\ntest: $$n==x$$\n```\n\n\n# Reference\n[1] [Markdown中插入数学公式的方法](http://blog.csdn.net/xiahouzuoxin/article/details/26478179)\n\n[2] [MathJax Chinese Doc 2.0 documentation](http://mathjax-chinese-doc.readthedocs.io/en/latest/start.html)\n\n[3] [MathJax basic tutorial and quick reference](https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference)\n\n[4] [docs.mathjax.org](http://docs.mathjax.org/en/latest/configuration.html#loading)\n\n<br>\n<br>\n---------------------------------------","slug":"Others/Markdown/2017-11-30-How to use MathJax in Markdown","published":1,"updated":"2018-10-27T04:30:42.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9tw0ej005he0owzhjmbjy7","content":"<h1 id=\"How-to-use-MathJax-in-Markdown\"><a href=\"#How-to-use-MathJax-in-Markdown\" class=\"headerlink\" title=\"How to use MathJax in Markdown\"></a>How to use MathJax in Markdown</h1><h2 id=\"When-to-Use-MathJax\"><a href=\"#When-to-Use-MathJax\" class=\"headerlink\" title=\"When to Use MathJax?\"></a>When to Use MathJax?</h2><p> When using markdown to write blog, especially using Github Page to do it. You may have trouble to display formula. There are several ways[1] to do that. But the simplest way is to use MathJax.</p>\n<h2 id=\"How-to-Use-MathJax\"><a href=\"#How-to-Use-MathJax\" class=\"headerlink\" title=\"How to Use MathJax?\"></a>How to Use MathJax?</h2><p>Add the code below to your markdown file, and that’s it!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; &lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>For example, add the test code to your blog.md file<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; &lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">test: $$n==x$$</div></pre></td></tr></table></figure></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] <a href=\"http://blog.csdn.net/xiahouzuoxin/article/details/26478179\" target=\"_blank\" rel=\"external\">Markdown中插入数学公式的方法</a></p>\n<p>[2] <a href=\"http://mathjax-chinese-doc.readthedocs.io/en/latest/start.html\" target=\"_blank\" rel=\"external\">MathJax Chinese Doc 2.0 documentation</a></p>\n<p>[3] <a href=\"https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"external\">MathJax basic tutorial and quick reference</a></p>\n<p>[4] <a href=\"http://docs.mathjax.org/en/latest/configuration.html#loading\" target=\"_blank\" rel=\"external\">docs.mathjax.org</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"How-to-use-MathJax-in-Markdown\"><a href=\"#How-to-use-MathJax-in-Markdown\" class=\"headerlink\" title=\"How to use MathJax in Markdown\"></a>How to use MathJax in Markdown</h1><h2 id=\"When-to-Use-MathJax\"><a href=\"#When-to-Use-MathJax\" class=\"headerlink\" title=\"When to Use MathJax?\"></a>When to Use MathJax?</h2><p> When using markdown to write blog, especially using Github Page to do it. You may have trouble to display formula. There are several ways[1] to do that. But the simplest way is to use MathJax.</p>\n<h2 id=\"How-to-Use-MathJax\"><a href=\"#How-to-Use-MathJax\" class=\"headerlink\" title=\"How to Use MathJax?\"></a>How to Use MathJax?</h2><p>Add the code below to your markdown file, and that’s it!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; &lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>For example, add the test code to your blog.md file<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; &lt;/script&gt;</div><div class=\"line\"></div><div class=\"line\">test: $$n==x$$</div></pre></td></tr></table></figure></p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[1] <a href=\"http://blog.csdn.net/xiahouzuoxin/article/details/26478179\" target=\"_blank\" rel=\"external\">Markdown中插入数学公式的方法</a></p>\n<p>[2] <a href=\"http://mathjax-chinese-doc.readthedocs.io/en/latest/start.html\" target=\"_blank\" rel=\"external\">MathJax Chinese Doc 2.0 documentation</a></p>\n<p>[3] <a href=\"https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"external\">MathJax basic tutorial and quick reference</a></p>\n<p>[4] <a href=\"http://docs.mathjax.org/en/latest/configuration.html#loading\" target=\"_blank\" rel=\"external\">docs.mathjax.org</a></p>\n<p><br></p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><br></h2>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjp9tw08f0000e0owujk2gwv5","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw08s0005e0owalttne2h"},{"post_id":"cjp9tw0ax0009e0oww8m6xv71","category_id":"cjp9tw0az000be0ow95to30rn","_id":"cjp9tw0bb000le0ownopzcn8p"},{"post_id":"cjp9tw0ay000ae0ow8dw3l8d0","category_id":"cjp9tw0b9000ge0owqcknzvvm","_id":"cjp9tw0bd000re0ow974c2dp2"},{"post_id":"cjp9tw0az000de0owzjxcnxqb","category_id":"cjp9tw0bb000me0owcgjsm0pu","_id":"cjp9tw0bf000xe0ownq0qxj4z"},{"post_id":"cjp9tw0bd000ue0owbp2oz2e8","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0bi0012e0ow9kucq5xy"},{"post_id":"cjp9tw0b7000ee0owdqzebmjx","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0bj0016e0ow4xc06std"},{"post_id":"cjp9tw0bf0010e0owye60ddf0","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0bk001ae0ow7gq4lpwl"},{"post_id":"cjp9tw0b8000fe0owi3y1b9w9","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0bl001ee0owyhb08wco"},{"post_id":"cjp9tw0bh0011e0owplnwkpkg","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0bn001ie0owybdb7vd5"},{"post_id":"cjp9tw0bi0015e0owy1wg923m","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0bo001me0owutned3vz"},{"post_id":"cjp9tw0b9000je0owmdx6bmjs","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0bq001qe0owj8wtkh51"},{"post_id":"cjp9tw0bk0019e0owgkc7jmyh","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0bs001ue0owfltfhqak"},{"post_id":"cjp9tw0bl001de0owzjxss9bh","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0bv001ye0ow5bi7oe85"},{"post_id":"cjp9tw0ba000ke0owxftlzlhm","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0bx0022e0owgjaq4hh7"},{"post_id":"cjp9tw0bm001he0owidmai8wx","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0by0026e0owlf1mqrxi"},{"post_id":"cjp9tw0bn001le0ow19w5btxs","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0bz0029e0owxvkvkyly"},{"post_id":"cjp9tw0bb000oe0owm1zv95rq","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0c1002de0owoo71h0bw"},{"post_id":"cjp9tw0bp001pe0ow87oyxsty","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c2002ge0owd6h9witf"},{"post_id":"cjp9tw0br001te0owen0lbkxt","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c3002ke0owkil3ihva"},{"post_id":"cjp9tw0bc000qe0own10xp805","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0c3002me0owr70zx3vc"},{"post_id":"cjp9tw0bu001xe0owi5mfl839","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c4002pe0ow4tcvopwh"},{"post_id":"cjp9tw0bw0021e0ow3pd6wdkl","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c4002re0owvmm2i0u6"},{"post_id":"cjp9tw0by0025e0owha4rylud","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c5002ue0owi4jwvqvn"},{"post_id":"cjp9tw0be000we0ow7nusv3qv","category_id":"cjp9tw0bw0020e0owbnbqvrzh","_id":"cjp9tw0c5002we0ow4y622lg1"},{"post_id":"cjp9tw0bz0028e0owk2sh41zi","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c5002ze0owgses2u9n"},{"post_id":"cjp9tw0c0002ce0ows105c1c8","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c60031e0owtxtensx9"},{"post_id":"cjp9tw0c1002fe0owigimkmsw","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c60034e0ow3hocgtpn"},{"post_id":"cjp9tw0c2002je0owcwyu0qob","category_id":"cjp9tw08o0002e0owbxutgmyc","_id":"cjp9tw0c60036e0oww2bzy8fe"},{"post_id":"cjp9tw0dv003je0ow2m3gupmy","category_id":"cjp9tw0du003ge0owwcuf7rf4","_id":"cjp9tw0dz003re0owap2osdx8"},{"post_id":"cjp9tw0dt003ee0owf26ssr3f","category_id":"cjp9tw0du003ge0owwcuf7rf4","_id":"cjp9tw0e0003we0own7b0752k"},{"post_id":"cjp9tw0dw003ke0owlpl5fupi","category_id":"cjp9tw0du003ge0owwcuf7rf4","_id":"cjp9tw0e1003ze0owqo2dyrxp"},{"post_id":"cjp9tw0dx003oe0owzm7ki0lw","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0e30043e0owvqs0lt9k"},{"post_id":"cjp9tw0dt003fe0ow9zh3bpco","category_id":"cjp9tw0du003ge0owwcuf7rf4","_id":"cjp9tw0e40045e0owwm16nd5m"},{"post_id":"cjp9tw0dy003qe0owh7mmrxe1","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0e60049e0owxs0x1e1b"},{"post_id":"cjp9tw0e0003ve0ow73ij0ucx","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0e8004de0owxsdwqkiw"},{"post_id":"cjp9tw0du003ie0owk3dqvqil","category_id":"cjp9tw0du003ge0owwcuf7rf4","_id":"cjp9tw0e9004he0owcwnh00so"},{"post_id":"cjp9tw0e1003ye0ow96x5tt73","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0ea004le0owsmk9iv6l"},{"post_id":"cjp9tw0e20042e0ow8g7vjdfh","category_id":"cjp9tw0bd000se0owzjytez8s","_id":"cjp9tw0eb004oe0owiy82jpg3"},{"post_id":"cjp9tw0e40044e0owpywjcj7k","category_id":"cjp9tw0e7004ae0ow42i4bmuw","_id":"cjp9tw0ec004re0owrl4lz8o3"},{"post_id":"cjp9tw0e50048e0owg9bo971w","category_id":"cjp9tw0e7004ae0ow42i4bmuw","_id":"cjp9tw0ed004ve0ow8ys5357a"},{"post_id":"cjp9tw0e8004ce0ow5hg4k3kq","category_id":"cjp9tw0ec004qe0ow8gt3tql7","_id":"cjp9tw0ed0050e0ow1el25a7p"},{"post_id":"cjp9tw0e9004ge0ow8vlyt5wb","category_id":"cjp9tw0ed004we0ows9wrbegb","_id":"cjp9tw0ee0055e0ow3m3p9waj"},{"post_id":"cjp9tw0ea004je0ow3wpz8bt0","category_id":"cjp9tw0ec004qe0ow8gt3tql7","_id":"cjp9tw0ef0059e0owwa6eaug6"},{"post_id":"cjp9tw0ej005he0owzhjmbjy7","category_id":"cjp9tw0ed004we0ows9wrbegb","_id":"cjp9tw0ek005je0ow9y3pmafw"}],"PostTag":[{"post_id":"cjp9tw08f0000e0owujk2gwv5","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw08r0004e0owtjxku324"},{"post_id":"cjp9tw0ax0009e0oww8m6xv71","tag_id":"cjp9tw0az000ce0owexatzpal","_id":"cjp9tw0b9000ie0owr47lzq97"},{"post_id":"cjp9tw0ay000ae0ow8dw3l8d0","tag_id":"cjp9tw0b9000he0ow822l2dm3","_id":"cjp9tw0bc000pe0ow4lwhm0oa"},{"post_id":"cjp9tw0az000de0owzjxcnxqb","tag_id":"cjp9tw0bb000ne0owyuzhf8q7","_id":"cjp9tw0be000ve0owiusnk4q1"},{"post_id":"cjp9tw0bf0010e0owye60ddf0","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0bi0013e0owjg7eeesv"},{"post_id":"cjp9tw0bh0011e0owplnwkpkg","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0bk0018e0owz6xhbq0g"},{"post_id":"cjp9tw0b7000ee0owdqzebmjx","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0bk001be0ow4gcjy2pm"},{"post_id":"cjp9tw0b7000ee0owdqzebmjx","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0bm001ge0owyuhwbpnm"},{"post_id":"cjp9tw0bi0015e0owy1wg923m","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0bn001je0owym62m97n"},{"post_id":"cjp9tw0bk0019e0owgkc7jmyh","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0bp001oe0owtttoo4fz"},{"post_id":"cjp9tw0bl001de0owzjxss9bh","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0bq001re0ow2ifuyb1z"},{"post_id":"cjp9tw0bm001he0owidmai8wx","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0bt001we0ow0ipy1wli"},{"post_id":"cjp9tw0b8000fe0owi3y1b9w9","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0bv001ze0owhodkrlrp"},{"post_id":"cjp9tw0b8000fe0owi3y1b9w9","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0by0024e0owmcdpyngo"},{"post_id":"cjp9tw0bn001le0ow19w5btxs","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0bz0027e0ow85jxecxv"},{"post_id":"cjp9tw0bp001pe0ow87oyxsty","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c0002be0owdmopseod"},{"post_id":"cjp9tw0br001te0owen0lbkxt","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c1002ee0ow7yzdypee"},{"post_id":"cjp9tw0bu001xe0owi5mfl839","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c2002ie0owcnivvcrd"},{"post_id":"cjp9tw0b9000je0owmdx6bmjs","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0c3002le0owau5wmn9u"},{"post_id":"cjp9tw0b9000je0owmdx6bmjs","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0c4002oe0owqfmjxa59"},{"post_id":"cjp9tw0bw0021e0ow3pd6wdkl","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c4002qe0ow2hsycpas"},{"post_id":"cjp9tw0by0025e0owha4rylud","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c5002te0ow7f38c020"},{"post_id":"cjp9tw0bz0028e0owk2sh41zi","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c5002ve0owzzo1zopa"},{"post_id":"cjp9tw0c0002ce0ows105c1c8","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c5002ye0ow93prhf9x"},{"post_id":"cjp9tw0ba000ke0owxftlzlhm","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0c60030e0owx1qxizin"},{"post_id":"cjp9tw0ba000ke0owxftlzlhm","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0c60033e0owy9ua3847"},{"post_id":"cjp9tw0c1002fe0owigimkmsw","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c60035e0owmte9e7sz"},{"post_id":"cjp9tw0c2002je0owcwyu0qob","tag_id":"cjp9tw08p0003e0owm5uvb684","_id":"cjp9tw0c60037e0owfo3atmbc"},{"post_id":"cjp9tw0bb000oe0owm1zv95rq","tag_id":"cjp9tw0c2002he0owcixn0735","_id":"cjp9tw0c70038e0ow71fpku9y"},{"post_id":"cjp9tw0bc000qe0own10xp805","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0c70039e0ow1tfns4es"},{"post_id":"cjp9tw0bc000qe0own10xp805","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0c7003ae0owtni7wttu"},{"post_id":"cjp9tw0bd000ue0owbp2oz2e8","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0c7003be0owbq0h6hdg"},{"post_id":"cjp9tw0bd000ue0owbp2oz2e8","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0c7003ce0owbcdn1enn"},{"post_id":"cjp9tw0be000we0ow7nusv3qv","tag_id":"cjp9tw0c60032e0ow222pf4t7","_id":"cjp9tw0c8003de0owgxndkn7g"},{"post_id":"cjp9tw0dv003je0ow2m3gupmy","tag_id":"cjp9tw0du003he0owm8ojxuak","_id":"cjp9tw0dx003ne0owamyf855g"},{"post_id":"cjp9tw0dt003ee0owf26ssr3f","tag_id":"cjp9tw0du003he0owm8ojxuak","_id":"cjp9tw0dy003pe0owcaxb68y0"},{"post_id":"cjp9tw0dw003ke0owlpl5fupi","tag_id":"cjp9tw0du003he0owm8ojxuak","_id":"cjp9tw0dz003ue0ow7uprzff6"},{"post_id":"cjp9tw0dt003fe0ow9zh3bpco","tag_id":"cjp9tw0du003he0owm8ojxuak","_id":"cjp9tw0e0003xe0owgbbzoc6l"},{"post_id":"cjp9tw0du003ie0owk3dqvqil","tag_id":"cjp9tw0du003he0owm8ojxuak","_id":"cjp9tw0e10041e0owp0dchhcs"},{"post_id":"cjp9tw0e20042e0ow8g7vjdfh","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0e50047e0owlqe4dphu"},{"post_id":"cjp9tw0e20042e0ow8g7vjdfh","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0e7004be0owlvqalf24"},{"post_id":"cjp9tw0e20042e0ow8g7vjdfh","tag_id":"cjp9tw0e10040e0ow0bmmb2dc","_id":"cjp9tw0e9004fe0ow2g9q28wb"},{"post_id":"cjp9tw0dx003oe0owzm7ki0lw","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0ea004ie0owiggdc8nw"},{"post_id":"cjp9tw0dx003oe0owzm7ki0lw","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0eb004ne0owxt38en2c"},{"post_id":"cjp9tw0dx003oe0owzm7ki0lw","tag_id":"cjp9tw0e10040e0ow0bmmb2dc","_id":"cjp9tw0ec004pe0owcfcl45ea"},{"post_id":"cjp9tw0dy003qe0owh7mmrxe1","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0ec004te0owi2qme82z"},{"post_id":"cjp9tw0dy003qe0owh7mmrxe1","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0ed004ue0owihewwfnk"},{"post_id":"cjp9tw0dy003qe0owh7mmrxe1","tag_id":"cjp9tw0e10040e0ow0bmmb2dc","_id":"cjp9tw0ed004ye0owcg1u8ylx"},{"post_id":"cjp9tw0e0003ve0ow73ij0ucx","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0ed004ze0owfnd1y1xn"},{"post_id":"cjp9tw0e0003ve0ow73ij0ucx","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0ee0053e0owcswd4q62"},{"post_id":"cjp9tw0e0003ve0ow73ij0ucx","tag_id":"cjp9tw0e10040e0ow0bmmb2dc","_id":"cjp9tw0ee0054e0ow0qkdaz68"},{"post_id":"cjp9tw0e1003ye0ow96x5tt73","tag_id":"cjp9tw0bd000te0owwfzdlejp","_id":"cjp9tw0ee0056e0owxr6uuttm"},{"post_id":"cjp9tw0e1003ye0ow96x5tt73","tag_id":"cjp9tw0bf000ze0owq9j88qzy","_id":"cjp9tw0ef0058e0owt2mtly7a"},{"post_id":"cjp9tw0e1003ye0ow96x5tt73","tag_id":"cjp9tw0e10040e0ow0bmmb2dc","_id":"cjp9tw0ef005ae0owz1pp3vxs"},{"post_id":"cjp9tw0e40044e0owpywjcj7k","tag_id":"cjp9tw0ec004se0ow3p5i9iic","_id":"cjp9tw0ef005ce0owe1bzk41a"},{"post_id":"cjp9tw0e50048e0owg9bo971w","tag_id":"cjp9tw0ec004se0ow3p5i9iic","_id":"cjp9tw0ef005de0owrltiup8s"},{"post_id":"cjp9tw0e8004ce0ow5hg4k3kq","tag_id":"cjp9tw0ee0052e0owhasholit","_id":"cjp9tw0eg005ee0owtewjz2q6"},{"post_id":"cjp9tw0e9004ge0ow8vlyt5wb","tag_id":"cjp9tw0ee0057e0ow5joplvyh","_id":"cjp9tw0eg005fe0owdxnetkfl"},{"post_id":"cjp9tw0ea004je0ow3wpz8bt0","tag_id":"cjp9tw0ee0052e0owhasholit","_id":"cjp9tw0eg005ge0owf8sa157p"},{"post_id":"cjp9tw0ej005he0owzhjmbjy7","tag_id":"cjp9tw0ee0057e0ow5joplvyh","_id":"cjp9tw0el005ke0owzw9chncf"},{"post_id":"cjp9tw0ej005he0owzhjmbjy7","tag_id":"cjp9tw0ek005ie0owlro5mvx5","_id":"cjp9tw0el005le0ow3jn5ufmt"}],"Tag":[{"name":"ReadNote-Machine-Learning-Foundation","_id":"cjp9tw08p0003e0owm5uvb684"},{"name":"MySQL","_id":"cjp9tw0az000ce0owexatzpal"},{"name":"Latex","_id":"cjp9tw0b9000he0ow822l2dm3"},{"name":"Machine-Learning-System-Tips","_id":"cjp9tw0bb000ne0owyuzhf8q7"},{"name":"Machine-Learning","_id":"cjp9tw0bd000te0owwfzdlejp"},{"name":"Mathematics","_id":"cjp9tw0bf000ze0owq9j88qzy"},{"name":"Machine-Learning-Mathematics","_id":"cjp9tw0c2002he0owcixn0735"},{"name":"Visualization","_id":"cjp9tw0c60032e0ow222pf4t7"},{"name":"Machine-Learning-Algorithm","_id":"cjp9tw0du003he0owm8ojxuak"},{"name":"Calculus","_id":"cjp9tw0e10040e0ow0bmmb2dc"},{"name":"Git","_id":"cjp9tw0ec004se0ow3p5i9iic"},{"name":"Hexo","_id":"cjp9tw0ee0052e0owhasholit"},{"name":"Markdown","_id":"cjp9tw0ee0057e0ow5joplvyh"},{"name":"Mathjax","_id":"cjp9tw0ek005ie0owlro5mvx5"}]}}